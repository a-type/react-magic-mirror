(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var moment = require('moment');

var greetings = [{ start: 0, end: 6, text: 'You\'re up late.' }, { start: 6, end: 12, text: 'Good morning, %N.' }, { start: 12, end: 19, text: 'Good afternoon, %N.' }, { start: 19, end: 24, text: 'Good evening, %N.' }];

var generateGreeting = function generateGreeting(name) {
    var hour = moment().hour();
    var text = "";
    greetings.forEach(function (greeting) {
        if (hour >= greeting.start && hour < greeting.end) {
            text = greeting.text.replace('%N', name);
        }
    });

    return text;
};

var generateState = function generateState(name) {
    var now = moment();
    return {
        time: now.format('h:mma'),
        date: now.format('ddd, MMM Do YYYY'),
        greeting: generateGreeting(name)
    };
};

var Greeting = function (_Component) {
    _inherits(Greeting, _Component);

    function Greeting() {
        _classCallCheck(this, Greeting);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Greeting).apply(this, arguments));
    }

    _createClass(Greeting, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var self = this;
            (function refresh() {
                self.forceUpdate();
                setTimeout(refresh, 60 * 1000);
            })();
        }
    }, {
        key: 'render',
        value: function render() {
            var state = generateState(this.props.user.name);
            return _react2.default.createElement(
                'div',
                { className: 'greeting' },
                _react2.default.createElement(
                    'h1',
                    null,
                    state.time
                ),
                _react2.default.createElement(
                    'h2',
                    null,
                    state.date
                ),
                _react2.default.createElement(
                    'h3',
                    null,
                    state.greeting
                )
            );
        }
    }]);

    return Greeting;
}(_react.Component);

exports.default = Greeting;

},{"moment":34,"react":164}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Greeting = require('./Greeting');

var _Greeting2 = _interopRequireDefault(_Greeting);

var _Weather = require('./Weather');

var _Weather2 = _interopRequireDefault(_Weather);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var request = require('browser-request');
var moment = require('moment');

var numBackgrounds = 20;

var getTime = function getTime() {
    return moment().format('h:mm a');
};

var getRandomBackground = function getRandomBackground() {
    var idx = Math.floor(Math.random(numBackgrounds));
    return 'url(/img/idle/' + idx + '.jpg)';
};

var Home = function (_Component) {
    _inherits(Home, _Component);

    function Home(props) {
        _classCallCheck(this, Home);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Home).call(this, props));

        _this.state = {
            user: { name: '' },
            forecast: null,
            idle: true,
            time: getTime(),
            idleBackground: getRandomBackground()
        };
        return _this;
    }

    _createClass(Home, [{
        key: 'update',
        value: function update() {
            var self = this;

            request.get('/user', function (er, response) {
                self.setState({
                    user: JSON.parse(response.body)
                });
            });

            request.get('/weather', function (er, response) {
                self.setState({
                    forecast: JSON.parse(response.body)
                });
            });
        }
    }, {
        key: 'goIdle',
        value: function goIdle() {
            self.setState({ idle: true });
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.update();

            var self = this;

            window.addEventListener('keydown', function (e) {
                if (e.code === 'KeyA') {
                    self.setState({ idle: false });

                    setTimeout(self.goIdle, 5 * 60 * 1000);
                }
            });

            (function updateTime() {
                self.setState({ time: getTime() });

                setTimeout(updateTime, 60 * 1000);
            })();

            (function nextBackground() {
                self.setState({ idleBackground: getRandomBackground() });

                setTimeout(nextBackground, 60 * 60 * 1000);
            })();
        }
    }, {
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                { className: 'home' },
                _react2.default.createElement(
                    'div',
                    { className: 'info' },
                    _react2.default.createElement(_Greeting2.default, { user: this.state.user }),
                    _react2.default.createElement(_Weather2.default, { forecast: this.state.forecast })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'idle', style: {
                            opacity: this.state.idle ? 1 : 0,
                            backgroundImage: this.state.idleBackground
                        } },
                    _react2.default.createElement(
                        'div',
                        { className: 'idle-time' },
                        this.state.time
                    )
                )
            );
        }
    }]);

    return Home;
}(_react.Component);

exports.default = Home;

},{"./Greeting":1,"./Weather":3,"browser-request":5,"moment":34,"react":164}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Weather = function (_Component) {
    _inherits(Weather, _Component);

    function Weather() {
        _classCallCheck(this, Weather);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Weather).apply(this, arguments));
    }

    _createClass(Weather, [{
        key: 'render',
        value: function render() {
            var forecast = this.props.forecast;
            if (!forecast) {
                return _react2.default.createElement(
                    'div',
                    { className: 'weather' },
                    'Loading weather...'
                );
            } else {
                var high = forecast.daily.data[0].temperatureMax + '°';
                var low = forecast.daily.data[0].temperatureMin + '°';
                return _react2.default.createElement(
                    'div',
                    { className: 'weather' },
                    _react2.default.createElement(
                        'div',
                        { className: 'weather-currently' },
                        _react2.default.createElement(
                            'h4',
                            { className: 'weather-header' },
                            'currently'
                        ),
                        _react2.default.createElement(
                            'div',
                            { className: 'weather-icon-composite' },
                            _react2.default.createElement('div', { className: 'weather-icon ' + forecast.currently.icon }),
                            _react2.default.createElement(
                                'div',
                                { className: 'weather-details' },
                                _react2.default.createElement(
                                    'h1',
                                    null,
                                    forecast.currently.temperature
                                )
                            )
                        ),
                        _react2.default.createElement(
                            'h2',
                            null,
                            forecast.currently.summary
                        )
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: 'weather-today' },
                        _react2.default.createElement(
                            'h4',
                            { className: 'weather-header' },
                            'forecast'
                        ),
                        _react2.default.createElement(
                            'div',
                            { className: 'weather-icon-composite' },
                            _react2.default.createElement('div', { className: 'weather-icon ' + forecast.daily.icon }),
                            _react2.default.createElement(
                                'div',
                                { className: 'weather-details' },
                                _react2.default.createElement(
                                    'h1',
                                    { className: 'weather-daily-high' },
                                    high
                                ),
                                _react2.default.createElement(
                                    'h1',
                                    { className: 'weather-daily-low' },
                                    low
                                )
                            )
                        ),
                        _react2.default.createElement(
                            'h2',
                            null,
                            forecast.daily.summary
                        )
                    )
                );
            }
        }
    }]);

    return Weather;
}(_react.Component);

exports.default = Weather;

},{"react":164}],4:[function(require,module,exports){
'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _Home = require('./components/Home');

var _Home2 = _interopRequireDefault(_Home);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactDom2.default.render(_react2.default.createElement(_Home2.default, null), document.getElementById('main'));

},{"./components/Home":2,"react":164,"react-dom":35}],5:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// UMD HEADER START
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.returnExports = factory();
  }
})(undefined, function () {
  // UMD HEADER END

  var XHR = XMLHttpRequest;
  if (!XHR) throw new Error('missing XMLHttpRequest');
  request.log = {
    'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
  };

  var DEFAULT_TIMEOUT = 3 * 60 * 1000; // 3 minutes

  //
  // request
  //

  function request(options, callback) {
    // The entry-point to the API: prep the options object and pass the real work to run_xhr.
    if (typeof callback !== 'function') throw new Error('Bad callback given: ' + callback);

    if (!options) throw new Error('No options given');

    var options_onResponse = options.onResponse; // Save this for later.

    if (typeof options === 'string') options = { 'uri': options };else options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

    options.onResponse = options_onResponse; // And put it back.

    if (options.verbose) request.log = getLogger();

    if (options.url) {
      options.uri = options.url;
      delete options.url;
    }

    if (!options.uri && options.uri !== "") throw new Error("options.uri is a required argument");

    if (typeof options.uri != "string") throw new Error("options.uri must be a string");

    var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect'];
    for (var i = 0; i < unsupported_options.length; i++) {
      if (options[unsupported_options[i]]) throw new Error("options." + unsupported_options[i] + " is not supported");
    }options.callback = callback;
    options.method = options.method || 'GET';
    options.headers = options.headers || {};
    options.body = options.body || null;
    options.timeout = options.timeout || request.DEFAULT_TIMEOUT;

    if (options.headers.host) throw new Error("Options.headers.host is not supported");

    if (options.json) {
      options.headers.accept = options.headers.accept || 'application/json';
      if (options.method !== 'GET') options.headers['content-type'] = 'application/json';

      if (typeof options.json !== 'boolean') options.body = JSON.stringify(options.json);else if (typeof options.body !== 'string') options.body = JSON.stringify(options.body);
    }

    //BEGIN QS Hack
    var serialize = function serialize(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }return str.join("&");
    };

    if (options.qs) {
      var qs = typeof options.qs == 'string' ? options.qs : serialize(options.qs);
      if (options.uri.indexOf('?') !== -1) {
        //no get params
        options.uri = options.uri + '&' + qs;
      } else {
        //existing get params
        options.uri = options.uri + '?' + qs;
      }
    }
    //END QS Hack

    //BEGIN FORM Hack
    var multipart = function multipart(obj) {
      //todo: support file type (useful?)
      var result = {};
      result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);
      var lines = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          lines.push('--' + result.boundry + "\n" + 'Content-Disposition: form-data; name="' + p + '"' + "\n" + "\n" + obj[p] + "\n");
        }
      }
      lines.push('--' + result.boundry + '--');
      result.body = lines.join('');
      result.length = result.body.length;
      result.type = 'multipart/form-data; boundary=' + result.boundry;
      return result;
    };

    if (options.form) {
      if (typeof options.form == 'string') throw 'form name unsupported';
      if (options.method === 'POST') {
        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
        options.headers['content-type'] = encoding;
        switch (encoding) {
          case 'application/x-www-form-urlencoded':
            options.body = serialize(options.form).replace(/%20/g, "+");
            break;
          case 'multipart/form-data':
            var multi = multipart(options.form);
            //options.headers['content-length'] = multi.length;
            options.body = multi.body;
            options.headers['content-type'] = multi.type;
            break;
          default:
            throw new Error('unsupported encoding:' + encoding);
        }
      }
    }
    //END FORM Hack

    // If onResponse is boolean true, call back immediately when the response is known,
    // not when the full request is complete.
    options.onResponse = options.onResponse || noop;
    if (options.onResponse === true) {
      options.onResponse = callback;
      options.callback = noop;
    }

    // XXX Browsers do not like this.
    //if(options.body)
    //  options.headers['content-length'] = options.body.length;

    // HTTP basic authentication
    if (!options.headers.authorization && options.auth) options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

    return run_xhr(options);
  }

  var req_seq = 0;
  function run_xhr(options) {
    var xhr = new XHR(),
        timed_out = false,
        is_cors = is_crossDomain(options.uri),
        supports_cors = 'withCredentials' in xhr;

    req_seq += 1;
    xhr.seq_id = req_seq;
    xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;
    xhr._id = xhr.id; // I know I will type "_id" from habit all the time.

    if (is_cors && !supports_cors) {
      var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);
      cors_err.cors = 'unsupported';
      return options.callback(cors_err, xhr);
    }

    xhr.timeoutTimer = setTimeout(too_late, options.timeout);
    function too_late() {
      timed_out = true;
      var er = new Error('ETIMEDOUT');
      er.code = 'ETIMEDOUT';
      er.duration = options.timeout;

      request.log.error('Timeout', { 'id': xhr._id, 'milliseconds': options.timeout });
      return options.callback(er, xhr);
    }

    // Some states can be skipped over, so remember what is still incomplete.
    var did = { 'response': false, 'loading': false, 'end': false };

    xhr.onreadystatechange = on_state_change;
    xhr.open(options.method, options.uri, true); // asynchronous
    if (is_cors) xhr.withCredentials = !!options.withCredentials;
    xhr.send(options.body);
    return xhr;

    function on_state_change(event) {
      if (timed_out) return request.log.debug('Ignoring timed out state change', { 'state': xhr.readyState, 'id': xhr.id });

      request.log.debug('State change', { 'state': xhr.readyState, 'id': xhr.id, 'timed_out': timed_out });

      if (xhr.readyState === XHR.OPENED) {
        request.log.debug('Request started', { 'id': xhr.id });
        for (var key in options.headers) {
          xhr.setRequestHeader(key, options.headers[key]);
        }
      } else if (xhr.readyState === XHR.HEADERS_RECEIVED) on_response();else if (xhr.readyState === XHR.LOADING) {
        on_response();
        on_loading();
      } else if (xhr.readyState === XHR.DONE) {
        on_response();
        on_loading();
        on_end();
      }
    }

    function on_response() {
      if (did.response) return;

      did.response = true;
      request.log.debug('Got response', { 'id': xhr.id, 'status': xhr.status });
      clearTimeout(xhr.timeoutTimer);
      xhr.statusCode = xhr.status; // Node request compatibility

      // Detect failed CORS requests.
      if (is_cors && xhr.statusCode == 0) {
        var cors_err = new Error('CORS request rejected: ' + options.uri);
        cors_err.cors = 'rejected';

        // Do not process this request further.
        did.loading = true;
        did.end = true;

        return options.callback(cors_err, xhr);
      }

      options.onResponse(null, xhr);
    }

    function on_loading() {
      if (did.loading) return;

      did.loading = true;
      request.log.debug('Response body loading', { 'id': xhr.id });
      // TODO: Maybe simulate "data" events by watching xhr.responseText
    }

    function on_end() {
      if (did.end) return;

      did.end = true;
      request.log.debug('Request done', { 'id': xhr.id });

      xhr.body = xhr.responseText;
      if (options.json) {
        try {
          xhr.body = JSON.parse(xhr.responseText);
        } catch (er) {
          return options.callback(er, xhr);
        }
      }

      options.callback(null, xhr, xhr.body);
    }
  } // request

  request.withCredentials = false;
  request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

  //
  // defaults
  //

  request.defaults = function (options, requester) {
    var def = function def(method) {
      var d = function d(params, callback) {
        if (typeof params === 'string') params = { 'uri': params };else {
          params = JSON.parse(JSON.stringify(params));
        }
        for (var i in options) {
          if (params[i] === undefined) params[i] = options[i];
        }
        return method(params, callback);
      };
      return d;
    };
    var de = def(request);
    de.get = def(request.get);
    de.post = def(request.post);
    de.put = def(request.put);
    de.head = def(request.head);
    return de;
  };

  //
  // HTTP method shortcuts
  //

  var shortcuts = ['get', 'put', 'post', 'head'];
  shortcuts.forEach(function (shortcut) {
    var method = shortcut.toUpperCase();
    var func = shortcut.toLowerCase();

    request[func] = function (opts) {
      if (typeof opts === 'string') opts = { 'method': method, 'uri': opts };else {
        opts = JSON.parse(JSON.stringify(opts));
        opts.method = method;
      }

      var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
      return request.apply(this, args);
    };
  });

  //
  // CouchDB shortcut
  //

  request.couch = function (options, callback) {
    if (typeof options === 'string') options = { 'uri': options };

    // Just use the request API to do JSON.
    options.json = true;
    if (options.body) options.json = options.body;
    delete options.body;

    callback = callback || noop;

    var xhr = request(options, couch_handler);
    return xhr;

    function couch_handler(er, resp, body) {
      if (er) return callback(er, resp, body);

      if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
        // The body is a Couch JSON object indicating the error.
        er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));
        for (var key in body) {
          er[key] = body[key];
        }return callback(er, resp, body);
      }

      return callback(er, resp, body);
    }
  };

  //
  // Utility
  //

  function noop() {}

  function getLogger() {
    var logger = {},
        levels = ['trace', 'debug', 'info', 'warn', 'error'],
        level,
        i;

    for (i = 0; i < levels.length; i++) {
      level = levels[i];

      logger[level] = noop;
      if (typeof console !== 'undefined' && console && console[level]) logger[level] = formatted(console, level);
    }

    return logger;
  }

  function formatted(obj, method) {
    return formatted_logger;

    function formatted_logger(str, context) {
      if ((typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object') str += ' ' + JSON.stringify(context);

      return obj[method].call(obj, str);
    }
  }

  // Return whether a URL is a cross-domain request.
  function is_crossDomain(url) {
    var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/;

    // jQuery #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    var ajaxLocation;
    try {
      ajaxLocation = location.href;
    } catch (e) {
      // Use the href attribute of an A element since IE will modify it given document.location
      ajaxLocation = document.createElement("a");
      ajaxLocation.href = "";
      ajaxLocation = ajaxLocation.href;
    }

    var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [],
        parts = rurl.exec(url.toLowerCase());

    var result = !!(parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));

    //console.debug('is_crossDomain('+url+') -> ' + result)
    return result;
  }

  // MIT License from http://phpjs.org/functions/base64_encode:358
  function b64_enc(data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1,
        o2,
        o3,
        h1,
        h2,
        h3,
        h4,
        bits,
        i = 0,
        ac = 0,
        enc = "",
        tmp_arr = [];

    if (!data) {
      return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do {
      // pack three octets into four hexets
      o1 = data.charCodeAt(i++);
      o2 = data.charCodeAt(i++);
      o3 = data.charCodeAt(i++);

      bits = o1 << 16 | o2 << 8 | o3;

      h1 = bits >> 18 & 0x3f;
      h2 = bits >> 12 & 0x3f;
      h3 = bits >> 6 & 0x3f;
      h4 = bits & 0x3f;

      // use hexets to index into b64, and append result to encoded string
      tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
      case 1:
        enc = enc.slice(0, -2) + '==';
        break;
      case 2:
        enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
  }
  return request;
  //UMD FOOTER START
});
//UMD FOOTER END

},{}],6:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

}).call(this,require("XJF/FV"))
},{"./emptyFunction":13,"XJF/FV":33}],7:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

},{}],8:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

},{}],9:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

},{"./camelize":8}],10:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

'use strict';

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(_x, _x2) {
  var _again = true;

  _function: while (_again) {
    var outerNode = _x,
        innerNode = _x2;
    _again = false;

    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      _x = outerNode;
      _x2 = innerNode.parentNode;
      _again = true;
      continue _function;
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
}

module.exports = containsNode;

},{"./isTextNode":23}],11:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFromMixed
 * @typechecks
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var toArray = require('./toArray');

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return(
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;

},{"./toArray":31}],12:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = createArrayFromMixed(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;

}).call(this,require("XJF/FV"))
},{"./ExecutionEnvironment":7,"./createArrayFromMixed":11,"./getMarkupWrap":17,"./invariant":21,"XJF/FV":33}],13:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

},{}],14:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

'use strict';

var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33}],15:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

},{}],16:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
'use strict';

function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;

},{}],17:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

/*eslint-disable fb-www/unsafe-html */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;

}).call(this,require("XJF/FV"))
},{"./ExecutionEnvironment":7,"./invariant":21,"XJF/FV":33}],18:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

},{}],19:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

'use strict';

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

},{}],20:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

},{"./hyphenate":19}],21:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33}],22:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

},{}],23:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

'use strict';

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

},{"./isNode":22}],24:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require('./invariant');

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function keyMirror(obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require("XJF/FV"))
},{"./invariant":21,"XJF/FV":33}],25:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without losing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
"use strict";

var keyOf = function keyOf(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;

},{}],26:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;

},{}],27:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;

},{}],28:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};

},{"./ExecutionEnvironment":7}],29:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

'use strict';

var performance = require('./performance');

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;

},{"./performance":28}],30:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 * @typechecks
 * 
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

},{}],31:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;

}).call(this,require("XJF/FV"))
},{"./invariant":21,"XJF/FV":33}],32:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  warning = function warning(condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;

}).call(this,require("XJF/FV"))
},{"./emptyFunction":13,"XJF/FV":33}],33:[function(require,module,exports){
'use strict';

// shim for using process in browser

var process = module.exports = {};

process.nextTick = function () {
    var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
    var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;

    if (canSetImmediate) {
        return function (f) {
            return window.setImmediate(f);
        };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
}();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],34:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;}; //! moment.js
//! version : 2.11.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
;(function(global,factory){(typeof exports==='undefined'?'undefined':_typeof(exports))==='object'&&typeof module!=='undefined'?module.exports=factory():typeof define==='function'&&define.amd?define(factory):global.moment=factory();})(undefined,function(){'use strict';var hookCallback;function utils_hooks__hooks(){return hookCallback.apply(null,arguments);} // This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback(callback){hookCallback=callback;}function isArray(input){return Object.prototype.toString.call(input)==='[object Array]';}function isDate(input){return input instanceof Date||Object.prototype.toString.call(input)==='[object Date]';}function map(arr,fn){var res=[],i;for(i=0;i<arr.length;++i){res.push(fn(arr[i],i));}return res;}function hasOwnProp(a,b){return Object.prototype.hasOwnProperty.call(a,b);}function extend(a,b){for(var i in b){if(hasOwnProp(b,i)){a[i]=b[i];}}if(hasOwnProp(b,'toString')){a.toString=b.toString;}if(hasOwnProp(b,'valueOf')){a.valueOf=b.valueOf;}return a;}function create_utc__createUTC(input,format,locale,strict){return createLocalOrUTC(input,format,locale,strict,true).utc();}function defaultParsingFlags(){ // We need to deep clone this object.
return {empty:false,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:false,invalidMonth:null,invalidFormat:false,userInvalidated:false,iso:false};}function getParsingFlags(m){if(m._pf==null){m._pf=defaultParsingFlags();}return m._pf;}function valid__isValid(m){if(m._isValid==null){var flags=getParsingFlags(m);m._isValid=!isNaN(m._d.getTime())&&flags.overflow<0&&!flags.empty&&!flags.invalidMonth&&!flags.invalidWeekday&&!flags.nullInput&&!flags.invalidFormat&&!flags.userInvalidated;if(m._strict){m._isValid=m._isValid&&flags.charsLeftOver===0&&flags.unusedTokens.length===0&&flags.bigHour===undefined;}}return m._isValid;}function valid__createInvalid(flags){var m=create_utc__createUTC(NaN);if(flags!=null){extend(getParsingFlags(m),flags);}else {getParsingFlags(m).userInvalidated=true;}return m;}function isUndefined(input){return input===void 0;} // Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties=utils_hooks__hooks.momentProperties=[];function copyConfig(to,from){var i,prop,val;if(!isUndefined(from._isAMomentObject)){to._isAMomentObject=from._isAMomentObject;}if(!isUndefined(from._i)){to._i=from._i;}if(!isUndefined(from._f)){to._f=from._f;}if(!isUndefined(from._l)){to._l=from._l;}if(!isUndefined(from._strict)){to._strict=from._strict;}if(!isUndefined(from._tzm)){to._tzm=from._tzm;}if(!isUndefined(from._isUTC)){to._isUTC=from._isUTC;}if(!isUndefined(from._offset)){to._offset=from._offset;}if(!isUndefined(from._pf)){to._pf=getParsingFlags(from);}if(!isUndefined(from._locale)){to._locale=from._locale;}if(momentProperties.length>0){for(i in momentProperties){prop=momentProperties[i];val=from[prop];if(!isUndefined(val)){to[prop]=val;}}}return to;}var updateInProgress=false; // Moment prototype object
function Moment(config){copyConfig(this,config);this._d=new Date(config._d!=null?config._d.getTime():NaN); // Prevent infinite loop in case updateOffset creates new moment
// objects.
if(updateInProgress===false){updateInProgress=true;utils_hooks__hooks.updateOffset(this);updateInProgress=false;}}function isMoment(obj){return obj instanceof Moment||obj!=null&&obj._isAMomentObject!=null;}function absFloor(number){if(number<0){return Math.ceil(number);}else {return Math.floor(number);}}function toInt(argumentForCoercion){var coercedNumber=+argumentForCoercion,value=0;if(coercedNumber!==0&&isFinite(coercedNumber)){value=absFloor(coercedNumber);}return value;} // compare two arrays, return the number of differences
function compareArrays(array1,array2,dontConvert){var len=Math.min(array1.length,array2.length),lengthDiff=Math.abs(array1.length-array2.length),diffs=0,i;for(i=0;i<len;i++){if(dontConvert&&array1[i]!==array2[i]||!dontConvert&&toInt(array1[i])!==toInt(array2[i])){diffs++;}}return diffs+lengthDiff;}function Locale(){} // internal storage for locale config files
var locales={};var globalLocale;function normalizeLocale(key){return key?key.toLowerCase().replace('_','-'):key;} // pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names){var i=0,j,next,locale,split;while(i<names.length){split=normalizeLocale(names[i]).split('-');j=split.length;next=normalizeLocale(names[i+1]);next=next?next.split('-'):null;while(j>0){locale=loadLocale(split.slice(0,j).join('-'));if(locale){return locale;}if(next&&next.length>=j&&compareArrays(split,next,true)>=j-1){ //the next array item is better than a shallower substring of this one
break;}j--;}i++;}return null;}function loadLocale(name){var oldLocale=null; // TODO: Find a better way to register and load all the locales in Node
if(!locales[name]&&typeof module!=='undefined'&&module&&module.exports){try{oldLocale=globalLocale._abbr;require('./locale/'+name); // because defineLocale currently also sets the global locale, we
// want to undo that for lazy loaded locales
locale_locales__getSetGlobalLocale(oldLocale);}catch(e){}}return locales[name];} // This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function locale_locales__getSetGlobalLocale(key,values){var data;if(key){if(isUndefined(values)){data=locale_locales__getLocale(key);}else {data=defineLocale(key,values);}if(data){ // moment.duration._locale = moment._locale = data;
globalLocale=data;}}return globalLocale._abbr;}function defineLocale(name,values){if(values!==null){values.abbr=name;locales[name]=locales[name]||new Locale();locales[name].set(values); // backwards compat for now: also set the locale
locale_locales__getSetGlobalLocale(name);return locales[name];}else { // useful for testing
delete locales[name];return null;}} // returns locale data
function locale_locales__getLocale(key){var locale;if(key&&key._locale&&key._locale._abbr){key=key._locale._abbr;}if(!key){return globalLocale;}if(!isArray(key)){ //short-circuit everything else
locale=loadLocale(key);if(locale){return locale;}key=[key];}return chooseLocale(key);}var aliases={};function addUnitAlias(unit,shorthand){var lowerCase=unit.toLowerCase();aliases[lowerCase]=aliases[lowerCase+'s']=aliases[shorthand]=unit;}function normalizeUnits(units){return typeof units==='string'?aliases[units]||aliases[units.toLowerCase()]:undefined;}function normalizeObjectUnits(inputObject){var normalizedInput={},normalizedProp,prop;for(prop in inputObject){if(hasOwnProp(inputObject,prop)){normalizedProp=normalizeUnits(prop);if(normalizedProp){normalizedInput[normalizedProp]=inputObject[prop];}}}return normalizedInput;}function isFunction(input){return input instanceof Function||Object.prototype.toString.call(input)==='[object Function]';}function makeGetSet(unit,keepTime){return function(value){if(value!=null){get_set__set(this,unit,value);utils_hooks__hooks.updateOffset(this,keepTime);return this;}else {return get_set__get(this,unit);}};}function get_set__get(mom,unit){return mom.isValid()?mom._d['get'+(mom._isUTC?'UTC':'')+unit]():NaN;}function get_set__set(mom,unit,value){if(mom.isValid()){mom._d['set'+(mom._isUTC?'UTC':'')+unit](value);}} // MOMENTS
function getSet(units,value){var unit;if((typeof units==='undefined'?'undefined':_typeof(units))==='object'){for(unit in units){this.set(unit,units[unit]);}}else {units=normalizeUnits(units);if(isFunction(this[units])){return this[units](value);}}return this;}function zeroFill(number,targetLength,forceSign){var absNumber=''+Math.abs(number),zerosToFill=targetLength-absNumber.length,sign=number>=0;return (sign?forceSign?'+':'':'-')+Math.pow(10,Math.max(0,zerosToFill)).toString().substr(1)+absNumber;}var formattingTokens=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;var localFormattingTokens=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;var formatFunctions={};var formatTokenFunctions={}; // token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken(token,padded,ordinal,callback){var func=callback;if(typeof callback==='string'){func=function func(){return this[callback]();};}if(token){formatTokenFunctions[token]=func;}if(padded){formatTokenFunctions[padded[0]]=function(){return zeroFill(func.apply(this,arguments),padded[1],padded[2]);};}if(ordinal){formatTokenFunctions[ordinal]=function(){return this.localeData().ordinal(func.apply(this,arguments),token);};}}function removeFormattingTokens(input){if(input.match(/\[[\s\S]/)){return input.replace(/^\[|\]$/g,'');}return input.replace(/\\/g,'');}function makeFormatFunction(format){var array=format.match(formattingTokens),i,length;for(i=0,length=array.length;i<length;i++){if(formatTokenFunctions[array[i]]){array[i]=formatTokenFunctions[array[i]];}else {array[i]=removeFormattingTokens(array[i]);}}return function(mom){var output='';for(i=0;i<length;i++){output+=array[i] instanceof Function?array[i].call(mom,format):array[i];}return output;};} // format date using native date object
function formatMoment(m,format){if(!m.isValid()){return m.localeData().invalidDate();}format=expandFormat(format,m.localeData());formatFunctions[format]=formatFunctions[format]||makeFormatFunction(format);return formatFunctions[format](m);}function expandFormat(format,locale){var i=5;function replaceLongDateFormatTokens(input){return locale.longDateFormat(input)||input;}localFormattingTokens.lastIndex=0;while(i>=0&&localFormattingTokens.test(format)){format=format.replace(localFormattingTokens,replaceLongDateFormatTokens);localFormattingTokens.lastIndex=0;i-=1;}return format;}var match1=/\d/; //       0 - 9
var match2=/\d\d/; //      00 - 99
var match3=/\d{3}/; //     000 - 999
var match4=/\d{4}/; //    0000 - 9999
var match6=/[+-]?\d{6}/; // -999999 - 999999
var match1to2=/\d\d?/; //       0 - 99
var match3to4=/\d\d\d\d?/; //     999 - 9999
var match5to6=/\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3=/\d{1,3}/; //       0 - 999
var match1to4=/\d{1,4}/; //       0 - 9999
var match1to6=/[+-]?\d{1,6}/; // -999999 - 999999
var matchUnsigned=/\d+/; //       0 - inf
var matchSigned=/[+-]?\d+/; //    -inf - inf
var matchOffset=/Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset=/Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
var matchTimestamp=/[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;var regexes={};function addRegexToken(token,regex,strictRegex){regexes[token]=isFunction(regex)?regex:function(isStrict,localeData){return isStrict&&strictRegex?strictRegex:regex;};}function getParseRegexForToken(token,config){if(!hasOwnProp(regexes,token)){return new RegExp(unescapeFormat(token));}return regexes[token](config._strict,config._locale);} // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s){return regexEscape(s.replace('\\','').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(matched,p1,p2,p3,p4){return p1||p2||p3||p4;}));}function regexEscape(s){return s.replace(/[-\/\\^$*+?.()|[\]{}]/g,'\\$&');}var tokens={};function addParseToken(token,callback){var i,func=callback;if(typeof token==='string'){token=[token];}if(typeof callback==='number'){func=function func(input,array){array[callback]=toInt(input);};}for(i=0;i<token.length;i++){tokens[token[i]]=func;}}function addWeekParseToken(token,callback){addParseToken(token,function(input,array,config,token){config._w=config._w||{};callback(input,config._w,config,token);});}function addTimeToArrayFromToken(token,input,config){if(input!=null&&hasOwnProp(tokens,token)){tokens[token](input,config._a,config,token);}}var YEAR=0;var MONTH=1;var DATE=2;var HOUR=3;var MINUTE=4;var SECOND=5;var MILLISECOND=6;var WEEK=7;var WEEKDAY=8;function daysInMonth(year,month){return new Date(Date.UTC(year,month+1,0)).getUTCDate();} // FORMATTING
addFormatToken('M',['MM',2],'Mo',function(){return this.month()+1;});addFormatToken('MMM',0,0,function(format){return this.localeData().monthsShort(this,format);});addFormatToken('MMMM',0,0,function(format){return this.localeData().months(this,format);}); // ALIASES
addUnitAlias('month','M'); // PARSING
addRegexToken('M',match1to2);addRegexToken('MM',match1to2,match2);addRegexToken('MMM',function(isStrict,locale){return locale.monthsShortRegex(isStrict);});addRegexToken('MMMM',function(isStrict,locale){return locale.monthsRegex(isStrict);});addParseToken(['M','MM'],function(input,array){array[MONTH]=toInt(input)-1;});addParseToken(['MMM','MMMM'],function(input,array,config,token){var month=config._locale.monthsParse(input,token,config._strict); // if we didn't find a month name, mark the date as invalid.
if(month!=null){array[MONTH]=month;}else {getParsingFlags(config).invalidMonth=input;}}); // LOCALES
var MONTHS_IN_FORMAT=/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;var defaultLocaleMonths='January_February_March_April_May_June_July_August_September_October_November_December'.split('_');function localeMonths(m,format){return isArray(this._months)?this._months[m.month()]:this._months[MONTHS_IN_FORMAT.test(format)?'format':'standalone'][m.month()];}var defaultLocaleMonthsShort='Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');function localeMonthsShort(m,format){return isArray(this._monthsShort)?this._monthsShort[m.month()]:this._monthsShort[MONTHS_IN_FORMAT.test(format)?'format':'standalone'][m.month()];}function localeMonthsParse(monthName,format,strict){var i,mom,regex;if(!this._monthsParse){this._monthsParse=[];this._longMonthsParse=[];this._shortMonthsParse=[];}for(i=0;i<12;i++){ // make the regex if we don't have it already
mom=create_utc__createUTC([2000,i]);if(strict&&!this._longMonthsParse[i]){this._longMonthsParse[i]=new RegExp('^'+this.months(mom,'').replace('.','')+'$','i');this._shortMonthsParse[i]=new RegExp('^'+this.monthsShort(mom,'').replace('.','')+'$','i');}if(!strict&&!this._monthsParse[i]){regex='^'+this.months(mom,'')+'|^'+this.monthsShort(mom,'');this._monthsParse[i]=new RegExp(regex.replace('.',''),'i');} // test the regex
if(strict&&format==='MMMM'&&this._longMonthsParse[i].test(monthName)){return i;}else if(strict&&format==='MMM'&&this._shortMonthsParse[i].test(monthName)){return i;}else if(!strict&&this._monthsParse[i].test(monthName)){return i;}}} // MOMENTS
function setMonth(mom,value){var dayOfMonth;if(!mom.isValid()){ // No op
return mom;} // TODO: Move this out of here!
if(typeof value==='string'){value=mom.localeData().monthsParse(value); // TODO: Another silent failure?
if(typeof value!=='number'){return mom;}}dayOfMonth=Math.min(mom.date(),daysInMonth(mom.year(),value));mom._d['set'+(mom._isUTC?'UTC':'')+'Month'](value,dayOfMonth);return mom;}function getSetMonth(value){if(value!=null){setMonth(this,value);utils_hooks__hooks.updateOffset(this,true);return this;}else {return get_set__get(this,'Month');}}function getDaysInMonth(){return daysInMonth(this.year(),this.month());}var defaultMonthsShortRegex=matchWord;function monthsShortRegex(isStrict){if(this._monthsParseExact){if(!hasOwnProp(this,'_monthsRegex')){computeMonthsParse.call(this);}if(isStrict){return this._monthsShortStrictRegex;}else {return this._monthsShortRegex;}}else {return this._monthsShortStrictRegex&&isStrict?this._monthsShortStrictRegex:this._monthsShortRegex;}}var defaultMonthsRegex=matchWord;function monthsRegex(isStrict){if(this._monthsParseExact){if(!hasOwnProp(this,'_monthsRegex')){computeMonthsParse.call(this);}if(isStrict){return this._monthsStrictRegex;}else {return this._monthsRegex;}}else {return this._monthsStrictRegex&&isStrict?this._monthsStrictRegex:this._monthsRegex;}}function computeMonthsParse(){function cmpLenRev(a,b){return b.length-a.length;}var shortPieces=[],longPieces=[],mixedPieces=[],i,mom;for(i=0;i<12;i++){ // make the regex if we don't have it already
mom=create_utc__createUTC([2000,i]);shortPieces.push(this.monthsShort(mom,''));longPieces.push(this.months(mom,''));mixedPieces.push(this.months(mom,''));mixedPieces.push(this.monthsShort(mom,''));} // Sorting makes sure if one month (or abbr) is a prefix of another it
// will match the longer piece.
shortPieces.sort(cmpLenRev);longPieces.sort(cmpLenRev);mixedPieces.sort(cmpLenRev);for(i=0;i<12;i++){shortPieces[i]=regexEscape(shortPieces[i]);longPieces[i]=regexEscape(longPieces[i]);mixedPieces[i]=regexEscape(mixedPieces[i]);}this._monthsRegex=new RegExp('^('+mixedPieces.join('|')+')','i');this._monthsShortRegex=this._monthsRegex;this._monthsStrictRegex=new RegExp('^('+longPieces.join('|')+')$','i');this._monthsShortStrictRegex=new RegExp('^('+shortPieces.join('|')+')$','i');}function checkOverflow(m){var overflow;var a=m._a;if(a&&getParsingFlags(m).overflow===-2){overflow=a[MONTH]<0||a[MONTH]>11?MONTH:a[DATE]<1||a[DATE]>daysInMonth(a[YEAR],a[MONTH])?DATE:a[HOUR]<0||a[HOUR]>24||a[HOUR]===24&&(a[MINUTE]!==0||a[SECOND]!==0||a[MILLISECOND]!==0)?HOUR:a[MINUTE]<0||a[MINUTE]>59?MINUTE:a[SECOND]<0||a[SECOND]>59?SECOND:a[MILLISECOND]<0||a[MILLISECOND]>999?MILLISECOND:-1;if(getParsingFlags(m)._overflowDayOfYear&&(overflow<YEAR||overflow>DATE)){overflow=DATE;}if(getParsingFlags(m)._overflowWeeks&&overflow===-1){overflow=WEEK;}if(getParsingFlags(m)._overflowWeekday&&overflow===-1){overflow=WEEKDAY;}getParsingFlags(m).overflow=overflow;}return m;}function warn(msg){if(utils_hooks__hooks.suppressDeprecationWarnings===false&&typeof console!=='undefined'&&console.warn){console.warn('Deprecation warning: '+msg);}}function deprecate(msg,fn){var firstTime=true;return extend(function(){if(firstTime){warn(msg+'\nArguments: '+Array.prototype.slice.call(arguments).join(', ')+'\n'+new Error().stack);firstTime=false;}return fn.apply(this,arguments);},fn);}var deprecations={};function deprecateSimple(name,msg){if(!deprecations[name]){warn(msg);deprecations[name]=true;}}utils_hooks__hooks.suppressDeprecationWarnings=false; // iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;var basicIsoRegex=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;var tzRegex=/Z|[+-]\d\d(?::?\d\d)?/;var isoDates=[['YYYYYY-MM-DD',/[+-]\d{6}-\d\d-\d\d/],['YYYY-MM-DD',/\d{4}-\d\d-\d\d/],['GGGG-[W]WW-E',/\d{4}-W\d\d-\d/],['GGGG-[W]WW',/\d{4}-W\d\d/,false],['YYYY-DDD',/\d{4}-\d{3}/],['YYYY-MM',/\d{4}-\d\d/,false],['YYYYYYMMDD',/[+-]\d{10}/],['YYYYMMDD',/\d{8}/], // YYYYMM is NOT allowed by the standard
['GGGG[W]WWE',/\d{4}W\d{3}/],['GGGG[W]WW',/\d{4}W\d{2}/,false],['YYYYDDD',/\d{7}/]]; // iso time formats and regexes
var isoTimes=[['HH:mm:ss.SSSS',/\d\d:\d\d:\d\d\.\d+/],['HH:mm:ss,SSSS',/\d\d:\d\d:\d\d,\d+/],['HH:mm:ss',/\d\d:\d\d:\d\d/],['HH:mm',/\d\d:\d\d/],['HHmmss.SSSS',/\d\d\d\d\d\d\.\d+/],['HHmmss,SSSS',/\d\d\d\d\d\d,\d+/],['HHmmss',/\d\d\d\d\d\d/],['HHmm',/\d\d\d\d/],['HH',/\d\d/]];var aspNetJsonRegex=/^\/?Date\((\-?\d+)/i; // date from iso format
function configFromISO(config){var i,l,string=config._i,match=extendedIsoRegex.exec(string)||basicIsoRegex.exec(string),allowTime,dateFormat,timeFormat,tzFormat;if(match){getParsingFlags(config).iso=true;for(i=0,l=isoDates.length;i<l;i++){if(isoDates[i][1].exec(match[1])){dateFormat=isoDates[i][0];allowTime=isoDates[i][2]!==false;break;}}if(dateFormat==null){config._isValid=false;return;}if(match[3]){for(i=0,l=isoTimes.length;i<l;i++){if(isoTimes[i][1].exec(match[3])){ // match[2] should be 'T' or space
timeFormat=(match[2]||' ')+isoTimes[i][0];break;}}if(timeFormat==null){config._isValid=false;return;}}if(!allowTime&&timeFormat!=null){config._isValid=false;return;}if(match[4]){if(tzRegex.exec(match[4])){tzFormat='Z';}else {config._isValid=false;return;}}config._f=dateFormat+(timeFormat||'')+(tzFormat||'');configFromStringAndFormat(config);}else {config._isValid=false;}} // date from iso format or fallback
function configFromString(config){var matched=aspNetJsonRegex.exec(config._i);if(matched!==null){config._d=new Date(+matched[1]);return;}configFromISO(config);if(config._isValid===false){delete config._isValid;utils_hooks__hooks.createFromInputFallback(config);}}utils_hooks__hooks.createFromInputFallback=deprecate('moment construction falls back to js Date. This is '+'discouraged and will be removed in upcoming major '+'release. Please refer to '+'https://github.com/moment/moment/issues/1407 for more info.',function(config){config._d=new Date(config._i+(config._useUTC?' UTC':''));});function createDate(y,m,d,h,M,s,ms){ //can't just apply() to create a date:
//http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
var date=new Date(y,m,d,h,M,s,ms); //the date constructor remaps years 0-99 to 1900-1999
if(y<100&&y>=0&&isFinite(date.getFullYear())){date.setFullYear(y);}return date;}function createUTCDate(y){var date=new Date(Date.UTC.apply(null,arguments)); //the Date.UTC function remaps years 0-99 to 1900-1999
if(y<100&&y>=0&&isFinite(date.getUTCFullYear())){date.setUTCFullYear(y);}return date;} // FORMATTING
addFormatToken('Y',0,0,function(){var y=this.year();return y<=9999?''+y:'+'+y;});addFormatToken(0,['YY',2],0,function(){return this.year()%100;});addFormatToken(0,['YYYY',4],0,'year');addFormatToken(0,['YYYYY',5],0,'year');addFormatToken(0,['YYYYYY',6,true],0,'year'); // ALIASES
addUnitAlias('year','y'); // PARSING
addRegexToken('Y',matchSigned);addRegexToken('YY',match1to2,match2);addRegexToken('YYYY',match1to4,match4);addRegexToken('YYYYY',match1to6,match6);addRegexToken('YYYYYY',match1to6,match6);addParseToken(['YYYYY','YYYYYY'],YEAR);addParseToken('YYYY',function(input,array){array[YEAR]=input.length===2?utils_hooks__hooks.parseTwoDigitYear(input):toInt(input);});addParseToken('YY',function(input,array){array[YEAR]=utils_hooks__hooks.parseTwoDigitYear(input);});addParseToken('Y',function(input,array){array[YEAR]=parseInt(input,10);}); // HELPERS
function daysInYear(year){return isLeapYear(year)?366:365;}function isLeapYear(year){return year%4===0&&year%100!==0||year%400===0;} // HOOKS
utils_hooks__hooks.parseTwoDigitYear=function(input){return toInt(input)+(toInt(input)>68?1900:2000);}; // MOMENTS
var getSetYear=makeGetSet('FullYear',false);function getIsLeapYear(){return isLeapYear(this.year());} // start-of-first-week - start-of-year
function firstWeekOffset(year,dow,doy){var  // first-week day -- which january is always in the first week (4 for iso, 1 for other)
fwd=7+dow-doy, // first-week day local weekday -- which local weekday is fwd
fwdlw=(7+createUTCDate(year,0,fwd).getUTCDay()-dow)%7;return -fwdlw+fwd-1;} //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year,week,weekday,dow,doy){var localWeekday=(7+weekday-dow)%7,weekOffset=firstWeekOffset(year,dow,doy),dayOfYear=1+7*(week-1)+localWeekday+weekOffset,resYear,resDayOfYear;if(dayOfYear<=0){resYear=year-1;resDayOfYear=daysInYear(resYear)+dayOfYear;}else if(dayOfYear>daysInYear(year)){resYear=year+1;resDayOfYear=dayOfYear-daysInYear(year);}else {resYear=year;resDayOfYear=dayOfYear;}return {year:resYear,dayOfYear:resDayOfYear};}function weekOfYear(mom,dow,doy){var weekOffset=firstWeekOffset(mom.year(),dow,doy),week=Math.floor((mom.dayOfYear()-weekOffset-1)/7)+1,resWeek,resYear;if(week<1){resYear=mom.year()-1;resWeek=week+weeksInYear(resYear,dow,doy);}else if(week>weeksInYear(mom.year(),dow,doy)){resWeek=week-weeksInYear(mom.year(),dow,doy);resYear=mom.year()+1;}else {resYear=mom.year();resWeek=week;}return {week:resWeek,year:resYear};}function weeksInYear(year,dow,doy){var weekOffset=firstWeekOffset(year,dow,doy),weekOffsetNext=firstWeekOffset(year+1,dow,doy);return (daysInYear(year)-weekOffset+weekOffsetNext)/7;} // Pick the first defined of two or three arguments.
function defaults(a,b,c){if(a!=null){return a;}if(b!=null){return b;}return c;}function currentDateArray(config){ // hooks is actually the exported moment object
var nowValue=new Date(utils_hooks__hooks.now());if(config._useUTC){return [nowValue.getUTCFullYear(),nowValue.getUTCMonth(),nowValue.getUTCDate()];}return [nowValue.getFullYear(),nowValue.getMonth(),nowValue.getDate()];} // convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray(config){var i,date,input=[],currentDate,yearToUse;if(config._d){return;}currentDate=currentDateArray(config); //compute day of the year from weeks and weekdays
if(config._w&&config._a[DATE]==null&&config._a[MONTH]==null){dayOfYearFromWeekInfo(config);} //if the day of the year is set, figure out what it is
if(config._dayOfYear){yearToUse=defaults(config._a[YEAR],currentDate[YEAR]);if(config._dayOfYear>daysInYear(yearToUse)){getParsingFlags(config)._overflowDayOfYear=true;}date=createUTCDate(yearToUse,0,config._dayOfYear);config._a[MONTH]=date.getUTCMonth();config._a[DATE]=date.getUTCDate();} // Default to current date.
// * if no year, month, day of month are given, default to today
// * if day of month is given, default month and year
// * if month is given, default only year
// * if year is given, don't default anything
for(i=0;i<3&&config._a[i]==null;++i){config._a[i]=input[i]=currentDate[i];} // Zero out whatever was not defaulted, including time
for(;i<7;i++){config._a[i]=input[i]=config._a[i]==null?i===2?1:0:config._a[i];} // Check for 24:00:00.000
if(config._a[HOUR]===24&&config._a[MINUTE]===0&&config._a[SECOND]===0&&config._a[MILLISECOND]===0){config._nextDay=true;config._a[HOUR]=0;}config._d=(config._useUTC?createUTCDate:createDate).apply(null,input); // Apply timezone offset from input. The actual utcOffset can be changed
// with parseZone.
if(config._tzm!=null){config._d.setUTCMinutes(config._d.getUTCMinutes()-config._tzm);}if(config._nextDay){config._a[HOUR]=24;}}function dayOfYearFromWeekInfo(config){var w,weekYear,week,weekday,dow,doy,temp,weekdayOverflow;w=config._w;if(w.GG!=null||w.W!=null||w.E!=null){dow=1;doy=4; // TODO: We need to take the current isoWeekYear, but that depends on
// how we interpret now (local, utc, fixed offset). So create
// a now version of current config (take local/utc/offset flags, and
// create now).
weekYear=defaults(w.GG,config._a[YEAR],weekOfYear(local__createLocal(),1,4).year);week=defaults(w.W,1);weekday=defaults(w.E,1);if(weekday<1||weekday>7){weekdayOverflow=true;}}else {dow=config._locale._week.dow;doy=config._locale._week.doy;weekYear=defaults(w.gg,config._a[YEAR],weekOfYear(local__createLocal(),dow,doy).year);week=defaults(w.w,1);if(w.d!=null){ // weekday -- low day numbers are considered next week
weekday=w.d;if(weekday<0||weekday>6){weekdayOverflow=true;}}else if(w.e!=null){ // local weekday -- counting starts from begining of week
weekday=w.e+dow;if(w.e<0||w.e>6){weekdayOverflow=true;}}else { // default to begining of week
weekday=dow;}}if(week<1||week>weeksInYear(weekYear,dow,doy)){getParsingFlags(config)._overflowWeeks=true;}else if(weekdayOverflow!=null){getParsingFlags(config)._overflowWeekday=true;}else {temp=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy);config._a[YEAR]=temp.year;config._dayOfYear=temp.dayOfYear;}} // constant that refers to the ISO standard
utils_hooks__hooks.ISO_8601=function(){}; // date from string and format string
function configFromStringAndFormat(config){ // TODO: Move this to another part of the creation flow to prevent circular deps
if(config._f===utils_hooks__hooks.ISO_8601){configFromISO(config);return;}config._a=[];getParsingFlags(config).empty=true; // This array is used to make a Date, either with `new Date` or `Date.UTC`
var string=''+config._i,i,parsedInput,tokens,token,skipped,stringLength=string.length,totalParsedInputLength=0;tokens=expandFormat(config._f,config._locale).match(formattingTokens)||[];for(i=0;i<tokens.length;i++){token=tokens[i];parsedInput=(string.match(getParseRegexForToken(token,config))||[])[0]; // console.log('token', token, 'parsedInput', parsedInput,
//         'regex', getParseRegexForToken(token, config));
if(parsedInput){skipped=string.substr(0,string.indexOf(parsedInput));if(skipped.length>0){getParsingFlags(config).unusedInput.push(skipped);}string=string.slice(string.indexOf(parsedInput)+parsedInput.length);totalParsedInputLength+=parsedInput.length;} // don't parse if it's not a known token
if(formatTokenFunctions[token]){if(parsedInput){getParsingFlags(config).empty=false;}else {getParsingFlags(config).unusedTokens.push(token);}addTimeToArrayFromToken(token,parsedInput,config);}else if(config._strict&&!parsedInput){getParsingFlags(config).unusedTokens.push(token);}} // add remaining unparsed input length to the string
getParsingFlags(config).charsLeftOver=stringLength-totalParsedInputLength;if(string.length>0){getParsingFlags(config).unusedInput.push(string);} // clear _12h flag if hour is <= 12
if(getParsingFlags(config).bigHour===true&&config._a[HOUR]<=12&&config._a[HOUR]>0){getParsingFlags(config).bigHour=undefined;} // handle meridiem
config._a[HOUR]=meridiemFixWrap(config._locale,config._a[HOUR],config._meridiem);configFromArray(config);checkOverflow(config);}function meridiemFixWrap(locale,hour,meridiem){var isPm;if(meridiem==null){ // nothing to do
return hour;}if(locale.meridiemHour!=null){return locale.meridiemHour(hour,meridiem);}else if(locale.isPM!=null){ // Fallback
isPm=locale.isPM(meridiem);if(isPm&&hour<12){hour+=12;}if(!isPm&&hour===12){hour=0;}return hour;}else { // this is not supposed to happen
return hour;}} // date from string and array of format strings
function configFromStringAndArray(config){var tempConfig,bestMoment,scoreToBeat,i,currentScore;if(config._f.length===0){getParsingFlags(config).invalidFormat=true;config._d=new Date(NaN);return;}for(i=0;i<config._f.length;i++){currentScore=0;tempConfig=copyConfig({},config);if(config._useUTC!=null){tempConfig._useUTC=config._useUTC;}tempConfig._f=config._f[i];configFromStringAndFormat(tempConfig);if(!valid__isValid(tempConfig)){continue;} // if there is any input that was not parsed add a penalty for that format
currentScore+=getParsingFlags(tempConfig).charsLeftOver; //or tokens
currentScore+=getParsingFlags(tempConfig).unusedTokens.length*10;getParsingFlags(tempConfig).score=currentScore;if(scoreToBeat==null||currentScore<scoreToBeat){scoreToBeat=currentScore;bestMoment=tempConfig;}}extend(config,bestMoment||tempConfig);}function configFromObject(config){if(config._d){return;}var i=normalizeObjectUnits(config._i);config._a=map([i.year,i.month,i.day||i.date,i.hour,i.minute,i.second,i.millisecond],function(obj){return obj&&parseInt(obj,10);});configFromArray(config);}function createFromConfig(config){var res=new Moment(checkOverflow(prepareConfig(config)));if(res._nextDay){ // Adding is smart enough around DST
res.add(1,'d');res._nextDay=undefined;}return res;}function prepareConfig(config){var input=config._i,format=config._f;config._locale=config._locale||locale_locales__getLocale(config._l);if(input===null||format===undefined&&input===''){return valid__createInvalid({nullInput:true});}if(typeof input==='string'){config._i=input=config._locale.preparse(input);}if(isMoment(input)){return new Moment(checkOverflow(input));}else if(isArray(format)){configFromStringAndArray(config);}else if(format){configFromStringAndFormat(config);}else if(isDate(input)){config._d=input;}else {configFromInput(config);}if(!valid__isValid(config)){config._d=null;}return config;}function configFromInput(config){var input=config._i;if(input===undefined){config._d=new Date(utils_hooks__hooks.now());}else if(isDate(input)){config._d=new Date(+input);}else if(typeof input==='string'){configFromString(config);}else if(isArray(input)){config._a=map(input.slice(0),function(obj){return parseInt(obj,10);});configFromArray(config);}else if((typeof input==='undefined'?'undefined':_typeof(input))==='object'){configFromObject(config);}else if(typeof input==='number'){ // from milliseconds
config._d=new Date(input);}else {utils_hooks__hooks.createFromInputFallback(config);}}function createLocalOrUTC(input,format,locale,strict,isUTC){var c={};if(typeof locale==='boolean'){strict=locale;locale=undefined;} // object construction must be done this way.
// https://github.com/moment/moment/issues/1423
c._isAMomentObject=true;c._useUTC=c._isUTC=isUTC;c._l=locale;c._i=input;c._f=format;c._strict=strict;return createFromConfig(c);}function local__createLocal(input,format,locale,strict){return createLocalOrUTC(input,format,locale,strict,false);}var prototypeMin=deprecate('moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',function(){var other=local__createLocal.apply(null,arguments);if(this.isValid()&&other.isValid()){return other<this?this:other;}else {return valid__createInvalid();}});var prototypeMax=deprecate('moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',function(){var other=local__createLocal.apply(null,arguments);if(this.isValid()&&other.isValid()){return other>this?this:other;}else {return valid__createInvalid();}}); // Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn,moments){var res,i;if(moments.length===1&&isArray(moments[0])){moments=moments[0];}if(!moments.length){return local__createLocal();}res=moments[0];for(i=1;i<moments.length;++i){if(!moments[i].isValid()||moments[i][fn](res)){res=moments[i];}}return res;} // TODO: Use [].sort instead?
function min(){var args=[].slice.call(arguments,0);return pickBy('isBefore',args);}function max(){var args=[].slice.call(arguments,0);return pickBy('isAfter',args);}var now=function now(){return Date.now?Date.now():+new Date();};function Duration(duration){var normalizedInput=normalizeObjectUnits(duration),years=normalizedInput.year||0,quarters=normalizedInput.quarter||0,months=normalizedInput.month||0,weeks=normalizedInput.week||0,days=normalizedInput.day||0,hours=normalizedInput.hour||0,minutes=normalizedInput.minute||0,seconds=normalizedInput.second||0,milliseconds=normalizedInput.millisecond||0; // representation for dateAddRemove
this._milliseconds=+milliseconds+seconds*1e3+ // 1000
minutes*6e4+ // 1000 * 60
hours*36e5; // 1000 * 60 * 60
// Because of dateAddRemove treats 24 hours as different from a
// day when working around DST, we need to store them separately
this._days=+days+weeks*7; // It is impossible translate months into days without knowing
// which months you are are talking about, so we have to store
// it separately.
this._months=+months+quarters*3+years*12;this._data={};this._locale=locale_locales__getLocale();this._bubble();}function isDuration(obj){return obj instanceof Duration;} // FORMATTING
function offset(token,separator){addFormatToken(token,0,0,function(){var offset=this.utcOffset();var sign='+';if(offset<0){offset=-offset;sign='-';}return sign+zeroFill(~ ~(offset/60),2)+separator+zeroFill(~ ~offset%60,2);});}offset('Z',':');offset('ZZ',''); // PARSING
addRegexToken('Z',matchShortOffset);addRegexToken('ZZ',matchShortOffset);addParseToken(['Z','ZZ'],function(input,array,config){config._useUTC=true;config._tzm=offsetFromString(matchShortOffset,input);}); // HELPERS
// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset=/([\+\-]|\d\d)/gi;function offsetFromString(matcher,string){var matches=(string||'').match(matcher)||[];var chunk=matches[matches.length-1]||[];var parts=(chunk+'').match(chunkOffset)||['-',0,0];var minutes=+(parts[1]*60)+toInt(parts[2]);return parts[0]==='+'?minutes:-minutes;} // Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input,model){var res,diff;if(model._isUTC){res=model.clone();diff=(isMoment(input)||isDate(input)?+input:+local__createLocal(input))-+res; // Use low-level api, because this fn is low-level api.
res._d.setTime(+res._d+diff);utils_hooks__hooks.updateOffset(res,false);return res;}else {return local__createLocal(input).local();}}function getDateOffset(m){ // On Firefox.24 Date#getTimezoneOffset returns a floating point.
// https://github.com/moment/moment/pull/1871
return -Math.round(m._d.getTimezoneOffset()/15)*15;} // HOOKS
// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
utils_hooks__hooks.updateOffset=function(){}; // MOMENTS
// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset(input,keepLocalTime){var offset=this._offset||0,localAdjust;if(!this.isValid()){return input!=null?this:NaN;}if(input!=null){if(typeof input==='string'){input=offsetFromString(matchShortOffset,input);}else if(Math.abs(input)<16){input=input*60;}if(!this._isUTC&&keepLocalTime){localAdjust=getDateOffset(this);}this._offset=input;this._isUTC=true;if(localAdjust!=null){this.add(localAdjust,'m');}if(offset!==input){if(!keepLocalTime||this._changeInProgress){add_subtract__addSubtract(this,create__createDuration(input-offset,'m'),1,false);}else if(!this._changeInProgress){this._changeInProgress=true;utils_hooks__hooks.updateOffset(this,true);this._changeInProgress=null;}}return this;}else {return this._isUTC?offset:getDateOffset(this);}}function getSetZone(input,keepLocalTime){if(input!=null){if(typeof input!=='string'){input=-input;}this.utcOffset(input,keepLocalTime);return this;}else {return -this.utcOffset();}}function setOffsetToUTC(keepLocalTime){return this.utcOffset(0,keepLocalTime);}function setOffsetToLocal(keepLocalTime){if(this._isUTC){this.utcOffset(0,keepLocalTime);this._isUTC=false;if(keepLocalTime){this.subtract(getDateOffset(this),'m');}}return this;}function setOffsetToParsedOffset(){if(this._tzm){this.utcOffset(this._tzm);}else if(typeof this._i==='string'){this.utcOffset(offsetFromString(matchOffset,this._i));}return this;}function hasAlignedHourOffset(input){if(!this.isValid()){return false;}input=input?local__createLocal(input).utcOffset():0;return (this.utcOffset()-input)%60===0;}function isDaylightSavingTime(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset();}function isDaylightSavingTimeShifted(){if(!isUndefined(this._isDSTShifted)){return this._isDSTShifted;}var c={};copyConfig(c,this);c=prepareConfig(c);if(c._a){var other=c._isUTC?create_utc__createUTC(c._a):local__createLocal(c._a);this._isDSTShifted=this.isValid()&&compareArrays(c._a,other.toArray())>0;}else {this._isDSTShifted=false;}return this._isDSTShifted;}function isLocal(){return this.isValid()?!this._isUTC:false;}function isUtcOffset(){return this.isValid()?this._isUTC:false;}function isUtc(){return this.isValid()?this._isUTC&&this._offset===0:false;} // ASP.NET json date format regex
var aspNetRegex=/^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
var isoRegex=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;function create__createDuration(input,key){var duration=input, // matching against regexp is expensive, do it on demand
match=null,sign,ret,diffRes;if(isDuration(input)){duration={ms:input._milliseconds,d:input._days,M:input._months};}else if(typeof input==='number'){duration={};if(key){duration[key]=input;}else {duration.milliseconds=input;}}else if(!!(match=aspNetRegex.exec(input))){sign=match[1]==='-'?-1:1;duration={y:0,d:toInt(match[DATE])*sign,h:toInt(match[HOUR])*sign,m:toInt(match[MINUTE])*sign,s:toInt(match[SECOND])*sign,ms:toInt(match[MILLISECOND])*sign};}else if(!!(match=isoRegex.exec(input))){sign=match[1]==='-'?-1:1;duration={y:parseIso(match[2],sign),M:parseIso(match[3],sign),d:parseIso(match[4],sign),h:parseIso(match[5],sign),m:parseIso(match[6],sign),s:parseIso(match[7],sign),w:parseIso(match[8],sign)};}else if(duration==null){ // checks for null or undefined
duration={};}else if((typeof duration==='undefined'?'undefined':_typeof(duration))==='object'&&('from' in duration||'to' in duration)){diffRes=momentsDifference(local__createLocal(duration.from),local__createLocal(duration.to));duration={};duration.ms=diffRes.milliseconds;duration.M=diffRes.months;}ret=new Duration(duration);if(isDuration(input)&&hasOwnProp(input,'_locale')){ret._locale=input._locale;}return ret;}create__createDuration.fn=Duration.prototype;function parseIso(inp,sign){ // We'd normally use ~~inp for this, but unfortunately it also
// converts floats to ints.
// inp may be undefined, so careful calling replace on it.
var res=inp&&parseFloat(inp.replace(',','.')); // apply sign while we're at it
return (isNaN(res)?0:res)*sign;}function positiveMomentsDifference(base,other){var res={milliseconds:0,months:0};res.months=other.month()-base.month()+(other.year()-base.year())*12;if(base.clone().add(res.months,'M').isAfter(other)){--res.months;}res.milliseconds=+other-+base.clone().add(res.months,'M');return res;}function momentsDifference(base,other){var res;if(!(base.isValid()&&other.isValid())){return {milliseconds:0,months:0};}other=cloneWithOffset(other,base);if(base.isBefore(other)){res=positiveMomentsDifference(base,other);}else {res=positiveMomentsDifference(other,base);res.milliseconds=-res.milliseconds;res.months=-res.months;}return res;} // TODO: remove 'name' arg after deprecation is removed
function createAdder(direction,name){return function(val,period){var dur,tmp; //invert the arguments, but complain about it
if(period!==null&&!isNaN(+period)){deprecateSimple(name,'moment().'+name+'(period, number) is deprecated. Please use moment().'+name+'(number, period).');tmp=val;val=period;period=tmp;}val=typeof val==='string'?+val:val;dur=create__createDuration(val,period);add_subtract__addSubtract(this,dur,direction);return this;};}function add_subtract__addSubtract(mom,duration,isAdding,updateOffset){var milliseconds=duration._milliseconds,days=duration._days,months=duration._months;if(!mom.isValid()){ // No op
return;}updateOffset=updateOffset==null?true:updateOffset;if(milliseconds){mom._d.setTime(+mom._d+milliseconds*isAdding);}if(days){get_set__set(mom,'Date',get_set__get(mom,'Date')+days*isAdding);}if(months){setMonth(mom,get_set__get(mom,'Month')+months*isAdding);}if(updateOffset){utils_hooks__hooks.updateOffset(mom,days||months);}}var add_subtract__add=createAdder(1,'add');var add_subtract__subtract=createAdder(-1,'subtract');function moment_calendar__calendar(time,formats){ // We want to compare the start of today, vs this.
// Getting start-of-today depends on whether we're local/utc/offset or not.
var now=time||local__createLocal(),sod=cloneWithOffset(now,this).startOf('day'),diff=this.diff(sod,'days',true),format=diff<-6?'sameElse':diff<-1?'lastWeek':diff<0?'lastDay':diff<1?'sameDay':diff<2?'nextDay':diff<7?'nextWeek':'sameElse';var output=formats&&(isFunction(formats[format])?formats[format]():formats[format]);return this.format(output||this.localeData().calendar(format,this,local__createLocal(now)));}function clone(){return new Moment(this);}function isAfter(input,units){var localInput=isMoment(input)?input:local__createLocal(input);if(!(this.isValid()&&localInput.isValid())){return false;}units=normalizeUnits(!isUndefined(units)?units:'millisecond');if(units==='millisecond'){return +this>+localInput;}else {return +localInput<+this.clone().startOf(units);}}function isBefore(input,units){var localInput=isMoment(input)?input:local__createLocal(input);if(!(this.isValid()&&localInput.isValid())){return false;}units=normalizeUnits(!isUndefined(units)?units:'millisecond');if(units==='millisecond'){return +this<+localInput;}else {return +this.clone().endOf(units)<+localInput;}}function isBetween(from,to,units){return this.isAfter(from,units)&&this.isBefore(to,units);}function isSame(input,units){var localInput=isMoment(input)?input:local__createLocal(input),inputMs;if(!(this.isValid()&&localInput.isValid())){return false;}units=normalizeUnits(units||'millisecond');if(units==='millisecond'){return +this===+localInput;}else {inputMs=+localInput;return +this.clone().startOf(units)<=inputMs&&inputMs<=+this.clone().endOf(units);}}function isSameOrAfter(input,units){return this.isSame(input,units)||this.isAfter(input,units);}function isSameOrBefore(input,units){return this.isSame(input,units)||this.isBefore(input,units);}function diff(input,units,asFloat){var that,zoneDelta,delta,output;if(!this.isValid()){return NaN;}that=cloneWithOffset(input,this);if(!that.isValid()){return NaN;}zoneDelta=(that.utcOffset()-this.utcOffset())*6e4;units=normalizeUnits(units);if(units==='year'||units==='month'||units==='quarter'){output=monthDiff(this,that);if(units==='quarter'){output=output/3;}else if(units==='year'){output=output/12;}}else {delta=this-that;output=units==='second'?delta/1e3: // 1000
units==='minute'?delta/6e4: // 1000 * 60
units==='hour'?delta/36e5: // 1000 * 60 * 60
units==='day'?(delta-zoneDelta)/864e5: // 1000 * 60 * 60 * 24, negate dst
units==='week'?(delta-zoneDelta)/6048e5: // 1000 * 60 * 60 * 24 * 7, negate dst
delta;}return asFloat?output:absFloor(output);}function monthDiff(a,b){ // difference in months
var wholeMonthDiff=(b.year()-a.year())*12+(b.month()-a.month()), // b is in (anchor - 1 month, anchor + 1 month)
anchor=a.clone().add(wholeMonthDiff,'months'),anchor2,adjust;if(b-anchor<0){anchor2=a.clone().add(wholeMonthDiff-1,'months'); // linear across the month
adjust=(b-anchor)/(anchor-anchor2);}else {anchor2=a.clone().add(wholeMonthDiff+1,'months'); // linear across the month
adjust=(b-anchor)/(anchor2-anchor);}return -(wholeMonthDiff+adjust);}utils_hooks__hooks.defaultFormat='YYYY-MM-DDTHH:mm:ssZ';function toString(){return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');}function moment_format__toISOString(){var m=this.clone().utc();if(0<m.year()&&m.year()<=9999){if(isFunction(Date.prototype.toISOString)){ // native implementation is ~50x faster, use it when we can
return this.toDate().toISOString();}else {return formatMoment(m,'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');}}else {return formatMoment(m,'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');}}function format(inputString){var output=formatMoment(this,inputString||utils_hooks__hooks.defaultFormat);return this.localeData().postformat(output);}function from(time,withoutSuffix){if(this.isValid()&&(isMoment(time)&&time.isValid()||local__createLocal(time).isValid())){return create__createDuration({to:this,from:time}).locale(this.locale()).humanize(!withoutSuffix);}else {return this.localeData().invalidDate();}}function fromNow(withoutSuffix){return this.from(local__createLocal(),withoutSuffix);}function to(time,withoutSuffix){if(this.isValid()&&(isMoment(time)&&time.isValid()||local__createLocal(time).isValid())){return create__createDuration({from:this,to:time}).locale(this.locale()).humanize(!withoutSuffix);}else {return this.localeData().invalidDate();}}function toNow(withoutSuffix){return this.to(local__createLocal(),withoutSuffix);} // If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale(key){var newLocaleData;if(key===undefined){return this._locale._abbr;}else {newLocaleData=locale_locales__getLocale(key);if(newLocaleData!=null){this._locale=newLocaleData;}return this;}}var lang=deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',function(key){if(key===undefined){return this.localeData();}else {return this.locale(key);}});function localeData(){return this._locale;}function startOf(units){units=normalizeUnits(units); // the following switch intentionally omits break keywords
// to utilize falling through the cases.
switch(units){case 'year':this.month(0); /* falls through */case 'quarter':case 'month':this.date(1); /* falls through */case 'week':case 'isoWeek':case 'day':this.hours(0); /* falls through */case 'hour':this.minutes(0); /* falls through */case 'minute':this.seconds(0); /* falls through */case 'second':this.milliseconds(0);} // weeks are a special case
if(units==='week'){this.weekday(0);}if(units==='isoWeek'){this.isoWeekday(1);} // quarters are also special
if(units==='quarter'){this.month(Math.floor(this.month()/3)*3);}return this;}function endOf(units){units=normalizeUnits(units);if(units===undefined||units==='millisecond'){return this;}return this.startOf(units).add(1,units==='isoWeek'?'week':units).subtract(1,'ms');}function to_type__valueOf(){return +this._d-(this._offset||0)*60000;}function unix(){return Math.floor(+this/1000);}function toDate(){return this._offset?new Date(+this):this._d;}function toArray(){var m=this;return [m.year(),m.month(),m.date(),m.hour(),m.minute(),m.second(),m.millisecond()];}function toObject(){var m=this;return {years:m.year(),months:m.month(),date:m.date(),hours:m.hours(),minutes:m.minutes(),seconds:m.seconds(),milliseconds:m.milliseconds()};}function toJSON(){ // JSON.stringify(new Date(NaN)) === 'null'
return this.isValid()?this.toISOString():'null';}function moment_valid__isValid(){return valid__isValid(this);}function parsingFlags(){return extend({},getParsingFlags(this));}function invalidAt(){return getParsingFlags(this).overflow;}function creationData(){return {input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict};} // FORMATTING
addFormatToken(0,['gg',2],0,function(){return this.weekYear()%100;});addFormatToken(0,['GG',2],0,function(){return this.isoWeekYear()%100;});function addWeekYearFormatToken(token,getter){addFormatToken(0,[token,token.length],0,getter);}addWeekYearFormatToken('gggg','weekYear');addWeekYearFormatToken('ggggg','weekYear');addWeekYearFormatToken('GGGG','isoWeekYear');addWeekYearFormatToken('GGGGG','isoWeekYear'); // ALIASES
addUnitAlias('weekYear','gg');addUnitAlias('isoWeekYear','GG'); // PARSING
addRegexToken('G',matchSigned);addRegexToken('g',matchSigned);addRegexToken('GG',match1to2,match2);addRegexToken('gg',match1to2,match2);addRegexToken('GGGG',match1to4,match4);addRegexToken('gggg',match1to4,match4);addRegexToken('GGGGG',match1to6,match6);addRegexToken('ggggg',match1to6,match6);addWeekParseToken(['gggg','ggggg','GGGG','GGGGG'],function(input,week,config,token){week[token.substr(0,2)]=toInt(input);});addWeekParseToken(['gg','GG'],function(input,week,config,token){week[token]=utils_hooks__hooks.parseTwoDigitYear(input);}); // MOMENTS
function getSetWeekYear(input){return getSetWeekYearHelper.call(this,input,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy);}function getSetISOWeekYear(input){return getSetWeekYearHelper.call(this,input,this.isoWeek(),this.isoWeekday(),1,4);}function getISOWeeksInYear(){return weeksInYear(this.year(),1,4);}function getWeeksInYear(){var weekInfo=this.localeData()._week;return weeksInYear(this.year(),weekInfo.dow,weekInfo.doy);}function getSetWeekYearHelper(input,week,weekday,dow,doy){var weeksTarget;if(input==null){return weekOfYear(this,dow,doy).year;}else {weeksTarget=weeksInYear(input,dow,doy);if(week>weeksTarget){week=weeksTarget;}return setWeekAll.call(this,input,week,weekday,dow,doy);}}function setWeekAll(weekYear,week,weekday,dow,doy){var dayOfYearData=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy),date=createUTCDate(dayOfYearData.year,0,dayOfYearData.dayOfYear); // console.log("got", weekYear, week, weekday, "set", date.toISOString());
this.year(date.getUTCFullYear());this.month(date.getUTCMonth());this.date(date.getUTCDate());return this;} // FORMATTING
addFormatToken('Q',0,'Qo','quarter'); // ALIASES
addUnitAlias('quarter','Q'); // PARSING
addRegexToken('Q',match1);addParseToken('Q',function(input,array){array[MONTH]=(toInt(input)-1)*3;}); // MOMENTS
function getSetQuarter(input){return input==null?Math.ceil((this.month()+1)/3):this.month((input-1)*3+this.month()%3);} // FORMATTING
addFormatToken('w',['ww',2],'wo','week');addFormatToken('W',['WW',2],'Wo','isoWeek'); // ALIASES
addUnitAlias('week','w');addUnitAlias('isoWeek','W'); // PARSING
addRegexToken('w',match1to2);addRegexToken('ww',match1to2,match2);addRegexToken('W',match1to2);addRegexToken('WW',match1to2,match2);addWeekParseToken(['w','ww','W','WW'],function(input,week,config,token){week[token.substr(0,1)]=toInt(input);}); // HELPERS
// LOCALES
function localeWeek(mom){return weekOfYear(mom,this._week.dow,this._week.doy).week;}var defaultLocaleWeek={dow:0, // Sunday is the first day of the week.
doy:6 // The week that contains Jan 1st is the first week of the year.
};function localeFirstDayOfWeek(){return this._week.dow;}function localeFirstDayOfYear(){return this._week.doy;} // MOMENTS
function getSetWeek(input){var week=this.localeData().week(this);return input==null?week:this.add((input-week)*7,'d');}function getSetISOWeek(input){var week=weekOfYear(this,1,4).week;return input==null?week:this.add((input-week)*7,'d');} // FORMATTING
addFormatToken('D',['DD',2],'Do','date'); // ALIASES
addUnitAlias('date','D'); // PARSING
addRegexToken('D',match1to2);addRegexToken('DD',match1to2,match2);addRegexToken('Do',function(isStrict,locale){return isStrict?locale._ordinalParse:locale._ordinalParseLenient;});addParseToken(['D','DD'],DATE);addParseToken('Do',function(input,array){array[DATE]=toInt(input.match(match1to2)[0],10);}); // MOMENTS
var getSetDayOfMonth=makeGetSet('Date',true); // FORMATTING
addFormatToken('d',0,'do','day');addFormatToken('dd',0,0,function(format){return this.localeData().weekdaysMin(this,format);});addFormatToken('ddd',0,0,function(format){return this.localeData().weekdaysShort(this,format);});addFormatToken('dddd',0,0,function(format){return this.localeData().weekdays(this,format);});addFormatToken('e',0,0,'weekday');addFormatToken('E',0,0,'isoWeekday'); // ALIASES
addUnitAlias('day','d');addUnitAlias('weekday','e');addUnitAlias('isoWeekday','E'); // PARSING
addRegexToken('d',match1to2);addRegexToken('e',match1to2);addRegexToken('E',match1to2);addRegexToken('dd',matchWord);addRegexToken('ddd',matchWord);addRegexToken('dddd',matchWord);addWeekParseToken(['dd','ddd','dddd'],function(input,week,config,token){var weekday=config._locale.weekdaysParse(input,token,config._strict); // if we didn't get a weekday name, mark the date as invalid
if(weekday!=null){week.d=weekday;}else {getParsingFlags(config).invalidWeekday=input;}});addWeekParseToken(['d','e','E'],function(input,week,config,token){week[token]=toInt(input);}); // HELPERS
function parseWeekday(input,locale){if(typeof input!=='string'){return input;}if(!isNaN(input)){return parseInt(input,10);}input=locale.weekdaysParse(input);if(typeof input==='number'){return input;}return null;} // LOCALES
var defaultLocaleWeekdays='Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');function localeWeekdays(m,format){return isArray(this._weekdays)?this._weekdays[m.day()]:this._weekdays[this._weekdays.isFormat.test(format)?'format':'standalone'][m.day()];}var defaultLocaleWeekdaysShort='Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');function localeWeekdaysShort(m){return this._weekdaysShort[m.day()];}var defaultLocaleWeekdaysMin='Su_Mo_Tu_We_Th_Fr_Sa'.split('_');function localeWeekdaysMin(m){return this._weekdaysMin[m.day()];}function localeWeekdaysParse(weekdayName,format,strict){var i,mom,regex;if(!this._weekdaysParse){this._weekdaysParse=[];this._minWeekdaysParse=[];this._shortWeekdaysParse=[];this._fullWeekdaysParse=[];}for(i=0;i<7;i++){ // make the regex if we don't have it already
mom=local__createLocal([2000,1]).day(i);if(strict&&!this._fullWeekdaysParse[i]){this._fullWeekdaysParse[i]=new RegExp('^'+this.weekdays(mom,'').replace('.','\.?')+'$','i');this._shortWeekdaysParse[i]=new RegExp('^'+this.weekdaysShort(mom,'').replace('.','\.?')+'$','i');this._minWeekdaysParse[i]=new RegExp('^'+this.weekdaysMin(mom,'').replace('.','\.?')+'$','i');}if(!this._weekdaysParse[i]){regex='^'+this.weekdays(mom,'')+'|^'+this.weekdaysShort(mom,'')+'|^'+this.weekdaysMin(mom,'');this._weekdaysParse[i]=new RegExp(regex.replace('.',''),'i');} // test the regex
if(strict&&format==='dddd'&&this._fullWeekdaysParse[i].test(weekdayName)){return i;}else if(strict&&format==='ddd'&&this._shortWeekdaysParse[i].test(weekdayName)){return i;}else if(strict&&format==='dd'&&this._minWeekdaysParse[i].test(weekdayName)){return i;}else if(!strict&&this._weekdaysParse[i].test(weekdayName)){return i;}}} // MOMENTS
function getSetDayOfWeek(input){if(!this.isValid()){return input!=null?this:NaN;}var day=this._isUTC?this._d.getUTCDay():this._d.getDay();if(input!=null){input=parseWeekday(input,this.localeData());return this.add(input-day,'d');}else {return day;}}function getSetLocaleDayOfWeek(input){if(!this.isValid()){return input!=null?this:NaN;}var weekday=(this.day()+7-this.localeData()._week.dow)%7;return input==null?weekday:this.add(input-weekday,'d');}function getSetISODayOfWeek(input){if(!this.isValid()){return input!=null?this:NaN;} // behaves the same as moment#day except
// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
// as a setter, sunday should belong to the previous week.
return input==null?this.day()||7:this.day(this.day()%7?input:input-7);} // FORMATTING
addFormatToken('DDD',['DDDD',3],'DDDo','dayOfYear'); // ALIASES
addUnitAlias('dayOfYear','DDD'); // PARSING
addRegexToken('DDD',match1to3);addRegexToken('DDDD',match3);addParseToken(['DDD','DDDD'],function(input,array,config){config._dayOfYear=toInt(input);}); // HELPERS
// MOMENTS
function getSetDayOfYear(input){var dayOfYear=Math.round((this.clone().startOf('day')-this.clone().startOf('year'))/864e5)+1;return input==null?dayOfYear:this.add(input-dayOfYear,'d');} // FORMATTING
function hFormat(){return this.hours()%12||12;}addFormatToken('H',['HH',2],0,'hour');addFormatToken('h',['hh',2],0,hFormat);addFormatToken('hmm',0,0,function(){return ''+hFormat.apply(this)+zeroFill(this.minutes(),2);});addFormatToken('hmmss',0,0,function(){return ''+hFormat.apply(this)+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2);});addFormatToken('Hmm',0,0,function(){return ''+this.hours()+zeroFill(this.minutes(),2);});addFormatToken('Hmmss',0,0,function(){return ''+this.hours()+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2);});function meridiem(token,lowercase){addFormatToken(token,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),lowercase);});}meridiem('a',true);meridiem('A',false); // ALIASES
addUnitAlias('hour','h'); // PARSING
function matchMeridiem(isStrict,locale){return locale._meridiemParse;}addRegexToken('a',matchMeridiem);addRegexToken('A',matchMeridiem);addRegexToken('H',match1to2);addRegexToken('h',match1to2);addRegexToken('HH',match1to2,match2);addRegexToken('hh',match1to2,match2);addRegexToken('hmm',match3to4);addRegexToken('hmmss',match5to6);addRegexToken('Hmm',match3to4);addRegexToken('Hmmss',match5to6);addParseToken(['H','HH'],HOUR);addParseToken(['a','A'],function(input,array,config){config._isPm=config._locale.isPM(input);config._meridiem=input;});addParseToken(['h','hh'],function(input,array,config){array[HOUR]=toInt(input);getParsingFlags(config).bigHour=true;});addParseToken('hmm',function(input,array,config){var pos=input.length-2;array[HOUR]=toInt(input.substr(0,pos));array[MINUTE]=toInt(input.substr(pos));getParsingFlags(config).bigHour=true;});addParseToken('hmmss',function(input,array,config){var pos1=input.length-4;var pos2=input.length-2;array[HOUR]=toInt(input.substr(0,pos1));array[MINUTE]=toInt(input.substr(pos1,2));array[SECOND]=toInt(input.substr(pos2));getParsingFlags(config).bigHour=true;});addParseToken('Hmm',function(input,array,config){var pos=input.length-2;array[HOUR]=toInt(input.substr(0,pos));array[MINUTE]=toInt(input.substr(pos));});addParseToken('Hmmss',function(input,array,config){var pos1=input.length-4;var pos2=input.length-2;array[HOUR]=toInt(input.substr(0,pos1));array[MINUTE]=toInt(input.substr(pos1,2));array[SECOND]=toInt(input.substr(pos2));}); // LOCALES
function localeIsPM(input){ // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
// Using charAt should be more compatible.
return (input+'').toLowerCase().charAt(0)==='p';}var defaultLocaleMeridiemParse=/[ap]\.?m?\.?/i;function localeMeridiem(hours,minutes,isLower){if(hours>11){return isLower?'pm':'PM';}else {return isLower?'am':'AM';}} // MOMENTS
// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour=makeGetSet('Hours',true); // FORMATTING
addFormatToken('m',['mm',2],0,'minute'); // ALIASES
addUnitAlias('minute','m'); // PARSING
addRegexToken('m',match1to2);addRegexToken('mm',match1to2,match2);addParseToken(['m','mm'],MINUTE); // MOMENTS
var getSetMinute=makeGetSet('Minutes',false); // FORMATTING
addFormatToken('s',['ss',2],0,'second'); // ALIASES
addUnitAlias('second','s'); // PARSING
addRegexToken('s',match1to2);addRegexToken('ss',match1to2,match2);addParseToken(['s','ss'],SECOND); // MOMENTS
var getSetSecond=makeGetSet('Seconds',false); // FORMATTING
addFormatToken('S',0,0,function(){return ~ ~(this.millisecond()/100);});addFormatToken(0,['SS',2],0,function(){return ~ ~(this.millisecond()/10);});addFormatToken(0,['SSS',3],0,'millisecond');addFormatToken(0,['SSSS',4],0,function(){return this.millisecond()*10;});addFormatToken(0,['SSSSS',5],0,function(){return this.millisecond()*100;});addFormatToken(0,['SSSSSS',6],0,function(){return this.millisecond()*1000;});addFormatToken(0,['SSSSSSS',7],0,function(){return this.millisecond()*10000;});addFormatToken(0,['SSSSSSSS',8],0,function(){return this.millisecond()*100000;});addFormatToken(0,['SSSSSSSSS',9],0,function(){return this.millisecond()*1000000;}); // ALIASES
addUnitAlias('millisecond','ms'); // PARSING
addRegexToken('S',match1to3,match1);addRegexToken('SS',match1to3,match2);addRegexToken('SSS',match1to3,match3);var token;for(token='SSSS';token.length<=9;token+='S'){addRegexToken(token,matchUnsigned);}function parseMs(input,array){array[MILLISECOND]=toInt(('0.'+input)*1000);}for(token='S';token.length<=9;token+='S'){addParseToken(token,parseMs);} // MOMENTS
var getSetMillisecond=makeGetSet('Milliseconds',false); // FORMATTING
addFormatToken('z',0,0,'zoneAbbr');addFormatToken('zz',0,0,'zoneName'); // MOMENTS
function getZoneAbbr(){return this._isUTC?'UTC':'';}function getZoneName(){return this._isUTC?'Coordinated Universal Time':'';}var momentPrototype__proto=Moment.prototype;momentPrototype__proto.add=add_subtract__add;momentPrototype__proto.calendar=moment_calendar__calendar;momentPrototype__proto.clone=clone;momentPrototype__proto.diff=diff;momentPrototype__proto.endOf=endOf;momentPrototype__proto.format=format;momentPrototype__proto.from=from;momentPrototype__proto.fromNow=fromNow;momentPrototype__proto.to=to;momentPrototype__proto.toNow=toNow;momentPrototype__proto.get=getSet;momentPrototype__proto.invalidAt=invalidAt;momentPrototype__proto.isAfter=isAfter;momentPrototype__proto.isBefore=isBefore;momentPrototype__proto.isBetween=isBetween;momentPrototype__proto.isSame=isSame;momentPrototype__proto.isSameOrAfter=isSameOrAfter;momentPrototype__proto.isSameOrBefore=isSameOrBefore;momentPrototype__proto.isValid=moment_valid__isValid;momentPrototype__proto.lang=lang;momentPrototype__proto.locale=locale;momentPrototype__proto.localeData=localeData;momentPrototype__proto.max=prototypeMax;momentPrototype__proto.min=prototypeMin;momentPrototype__proto.parsingFlags=parsingFlags;momentPrototype__proto.set=getSet;momentPrototype__proto.startOf=startOf;momentPrototype__proto.subtract=add_subtract__subtract;momentPrototype__proto.toArray=toArray;momentPrototype__proto.toObject=toObject;momentPrototype__proto.toDate=toDate;momentPrototype__proto.toISOString=moment_format__toISOString;momentPrototype__proto.toJSON=toJSON;momentPrototype__proto.toString=toString;momentPrototype__proto.unix=unix;momentPrototype__proto.valueOf=to_type__valueOf;momentPrototype__proto.creationData=creationData; // Year
momentPrototype__proto.year=getSetYear;momentPrototype__proto.isLeapYear=getIsLeapYear; // Week Year
momentPrototype__proto.weekYear=getSetWeekYear;momentPrototype__proto.isoWeekYear=getSetISOWeekYear; // Quarter
momentPrototype__proto.quarter=momentPrototype__proto.quarters=getSetQuarter; // Month
momentPrototype__proto.month=getSetMonth;momentPrototype__proto.daysInMonth=getDaysInMonth; // Week
momentPrototype__proto.week=momentPrototype__proto.weeks=getSetWeek;momentPrototype__proto.isoWeek=momentPrototype__proto.isoWeeks=getSetISOWeek;momentPrototype__proto.weeksInYear=getWeeksInYear;momentPrototype__proto.isoWeeksInYear=getISOWeeksInYear; // Day
momentPrototype__proto.date=getSetDayOfMonth;momentPrototype__proto.day=momentPrototype__proto.days=getSetDayOfWeek;momentPrototype__proto.weekday=getSetLocaleDayOfWeek;momentPrototype__proto.isoWeekday=getSetISODayOfWeek;momentPrototype__proto.dayOfYear=getSetDayOfYear; // Hour
momentPrototype__proto.hour=momentPrototype__proto.hours=getSetHour; // Minute
momentPrototype__proto.minute=momentPrototype__proto.minutes=getSetMinute; // Second
momentPrototype__proto.second=momentPrototype__proto.seconds=getSetSecond; // Millisecond
momentPrototype__proto.millisecond=momentPrototype__proto.milliseconds=getSetMillisecond; // Offset
momentPrototype__proto.utcOffset=getSetOffset;momentPrototype__proto.utc=setOffsetToUTC;momentPrototype__proto.local=setOffsetToLocal;momentPrototype__proto.parseZone=setOffsetToParsedOffset;momentPrototype__proto.hasAlignedHourOffset=hasAlignedHourOffset;momentPrototype__proto.isDST=isDaylightSavingTime;momentPrototype__proto.isDSTShifted=isDaylightSavingTimeShifted;momentPrototype__proto.isLocal=isLocal;momentPrototype__proto.isUtcOffset=isUtcOffset;momentPrototype__proto.isUtc=isUtc;momentPrototype__proto.isUTC=isUtc; // Timezone
momentPrototype__proto.zoneAbbr=getZoneAbbr;momentPrototype__proto.zoneName=getZoneName; // Deprecations
momentPrototype__proto.dates=deprecate('dates accessor is deprecated. Use date instead.',getSetDayOfMonth);momentPrototype__proto.months=deprecate('months accessor is deprecated. Use month instead',getSetMonth);momentPrototype__proto.years=deprecate('years accessor is deprecated. Use year instead',getSetYear);momentPrototype__proto.zone=deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779',getSetZone);var momentPrototype=momentPrototype__proto;function moment__createUnix(input){return local__createLocal(input*1000);}function moment__createInZone(){return local__createLocal.apply(null,arguments).parseZone();}var defaultCalendar={sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'};function locale_calendar__calendar(key,mom,now){var output=this._calendar[key];return isFunction(output)?output.call(mom,now):output;}var defaultLongDateFormat={LTS:'h:mm:ss A',LT:'h:mm A',L:'MM/DD/YYYY',LL:'MMMM D, YYYY',LLL:'MMMM D, YYYY h:mm A',LLLL:'dddd, MMMM D, YYYY h:mm A'};function longDateFormat(key){var format=this._longDateFormat[key],formatUpper=this._longDateFormat[key.toUpperCase()];if(format||!formatUpper){return format;}this._longDateFormat[key]=formatUpper.replace(/MMMM|MM|DD|dddd/g,function(val){return val.slice(1);});return this._longDateFormat[key];}var defaultInvalidDate='Invalid date';function invalidDate(){return this._invalidDate;}var defaultOrdinal='%d';var defaultOrdinalParse=/\d{1,2}/;function ordinal(number){return this._ordinal.replace('%d',number);}function preParsePostFormat(string){return string;}var defaultRelativeTime={future:'in %s',past:'%s ago',s:'a few seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'};function relative__relativeTime(number,withoutSuffix,string,isFuture){var output=this._relativeTime[string];return isFunction(output)?output(number,withoutSuffix,string,isFuture):output.replace(/%d/i,number);}function pastFuture(diff,output){var format=this._relativeTime[diff>0?'future':'past'];return isFunction(format)?format(output):format.replace(/%s/i,output);}function locale_set__set(config){var prop,i;for(i in config){prop=config[i];if(isFunction(prop)){this[i]=prop;}else {this['_'+i]=prop;}} // Lenient ordinal parsing accepts just a number in addition to
// number + (possibly) stuff coming from _ordinalParseLenient.
this._ordinalParseLenient=new RegExp(this._ordinalParse.source+'|'+/\d{1,2}/.source);}var prototype__proto=Locale.prototype;prototype__proto._calendar=defaultCalendar;prototype__proto.calendar=locale_calendar__calendar;prototype__proto._longDateFormat=defaultLongDateFormat;prototype__proto.longDateFormat=longDateFormat;prototype__proto._invalidDate=defaultInvalidDate;prototype__proto.invalidDate=invalidDate;prototype__proto._ordinal=defaultOrdinal;prototype__proto.ordinal=ordinal;prototype__proto._ordinalParse=defaultOrdinalParse;prototype__proto.preparse=preParsePostFormat;prototype__proto.postformat=preParsePostFormat;prototype__proto._relativeTime=defaultRelativeTime;prototype__proto.relativeTime=relative__relativeTime;prototype__proto.pastFuture=pastFuture;prototype__proto.set=locale_set__set; // Month
prototype__proto.months=localeMonths;prototype__proto._months=defaultLocaleMonths;prototype__proto.monthsShort=localeMonthsShort;prototype__proto._monthsShort=defaultLocaleMonthsShort;prototype__proto.monthsParse=localeMonthsParse;prototype__proto._monthsRegex=defaultMonthsRegex;prototype__proto.monthsRegex=monthsRegex;prototype__proto._monthsShortRegex=defaultMonthsShortRegex;prototype__proto.monthsShortRegex=monthsShortRegex; // Week
prototype__proto.week=localeWeek;prototype__proto._week=defaultLocaleWeek;prototype__proto.firstDayOfYear=localeFirstDayOfYear;prototype__proto.firstDayOfWeek=localeFirstDayOfWeek; // Day of Week
prototype__proto.weekdays=localeWeekdays;prototype__proto._weekdays=defaultLocaleWeekdays;prototype__proto.weekdaysMin=localeWeekdaysMin;prototype__proto._weekdaysMin=defaultLocaleWeekdaysMin;prototype__proto.weekdaysShort=localeWeekdaysShort;prototype__proto._weekdaysShort=defaultLocaleWeekdaysShort;prototype__proto.weekdaysParse=localeWeekdaysParse; // Hours
prototype__proto.isPM=localeIsPM;prototype__proto._meridiemParse=defaultLocaleMeridiemParse;prototype__proto.meridiem=localeMeridiem;function lists__get(format,index,field,setter){var locale=locale_locales__getLocale();var utc=create_utc__createUTC().set(setter,index);return locale[field](utc,format);}function list(format,index,field,count,setter){if(typeof format==='number'){index=format;format=undefined;}format=format||'';if(index!=null){return lists__get(format,index,field,setter);}var i;var out=[];for(i=0;i<count;i++){out[i]=lists__get(format,i,field,setter);}return out;}function lists__listMonths(format,index){return list(format,index,'months',12,'month');}function lists__listMonthsShort(format,index){return list(format,index,'monthsShort',12,'month');}function lists__listWeekdays(format,index){return list(format,index,'weekdays',7,'day');}function lists__listWeekdaysShort(format,index){return list(format,index,'weekdaysShort',7,'day');}function lists__listWeekdaysMin(format,index){return list(format,index,'weekdaysMin',7,'day');}locale_locales__getSetGlobalLocale('en',{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function ordinal(number){var b=number%10,output=toInt(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';return number+output;}}); // Side effect imports
utils_hooks__hooks.lang=deprecate('moment.lang is deprecated. Use moment.locale instead.',locale_locales__getSetGlobalLocale);utils_hooks__hooks.langData=deprecate('moment.langData is deprecated. Use moment.localeData instead.',locale_locales__getLocale);var mathAbs=Math.abs;function duration_abs__abs(){var data=this._data;this._milliseconds=mathAbs(this._milliseconds);this._days=mathAbs(this._days);this._months=mathAbs(this._months);data.milliseconds=mathAbs(data.milliseconds);data.seconds=mathAbs(data.seconds);data.minutes=mathAbs(data.minutes);data.hours=mathAbs(data.hours);data.months=mathAbs(data.months);data.years=mathAbs(data.years);return this;}function duration_add_subtract__addSubtract(duration,input,value,direction){var other=create__createDuration(input,value);duration._milliseconds+=direction*other._milliseconds;duration._days+=direction*other._days;duration._months+=direction*other._months;return duration._bubble();} // supports only 2.0-style add(1, 's') or add(duration)
function duration_add_subtract__add(input,value){return duration_add_subtract__addSubtract(this,input,value,1);} // supports only 2.0-style subtract(1, 's') or subtract(duration)
function duration_add_subtract__subtract(input,value){return duration_add_subtract__addSubtract(this,input,value,-1);}function absCeil(number){if(number<0){return Math.floor(number);}else {return Math.ceil(number);}}function bubble(){var milliseconds=this._milliseconds;var days=this._days;var months=this._months;var data=this._data;var seconds,minutes,hours,years,monthsFromDays; // if we have a mix of positive and negative values, bubble down first
// check: https://github.com/moment/moment/issues/2166
if(!(milliseconds>=0&&days>=0&&months>=0||milliseconds<=0&&days<=0&&months<=0)){milliseconds+=absCeil(monthsToDays(months)+days)*864e5;days=0;months=0;} // The following code bubbles up values, see the tests for
// examples of what that means.
data.milliseconds=milliseconds%1000;seconds=absFloor(milliseconds/1000);data.seconds=seconds%60;minutes=absFloor(seconds/60);data.minutes=minutes%60;hours=absFloor(minutes/60);data.hours=hours%24;days+=absFloor(hours/24); // convert days to months
monthsFromDays=absFloor(daysToMonths(days));months+=monthsFromDays;days-=absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year
years=absFloor(months/12);months%=12;data.days=days;data.months=months;data.years=years;return this;}function daysToMonths(days){ // 400 years have 146097 days (taking into account leap year rules)
// 400 years have 12 months === 4800
return days*4800/146097;}function monthsToDays(months){ // the reverse of daysToMonths
return months*146097/4800;}function as(units){var days;var months;var milliseconds=this._milliseconds;units=normalizeUnits(units);if(units==='month'||units==='year'){days=this._days+milliseconds/864e5;months=this._months+daysToMonths(days);return units==='month'?months:months/12;}else { // handle milliseconds separately because of floating point math errors (issue #1867)
days=this._days+Math.round(monthsToDays(this._months));switch(units){case 'week':return days/7+milliseconds/6048e5;case 'day':return days+milliseconds/864e5;case 'hour':return days*24+milliseconds/36e5;case 'minute':return days*1440+milliseconds/6e4;case 'second':return days*86400+milliseconds/1000; // Math.floor prevents floating point math errors here
case 'millisecond':return Math.floor(days*864e5)+milliseconds;default:throw new Error('Unknown unit '+units);}}} // TODO: Use this.as('ms')?
function duration_as__valueOf(){return this._milliseconds+this._days*864e5+this._months%12*2592e6+toInt(this._months/12)*31536e6;}function makeAs(alias){return function(){return this.as(alias);};}var asMilliseconds=makeAs('ms');var asSeconds=makeAs('s');var asMinutes=makeAs('m');var asHours=makeAs('h');var asDays=makeAs('d');var asWeeks=makeAs('w');var asMonths=makeAs('M');var asYears=makeAs('y');function duration_get__get(units){units=normalizeUnits(units);return this[units+'s']();}function makeGetter(name){return function(){return this._data[name];};}var milliseconds=makeGetter('milliseconds');var seconds=makeGetter('seconds');var minutes=makeGetter('minutes');var hours=makeGetter('hours');var days=makeGetter('days');var months=makeGetter('months');var years=makeGetter('years');function weeks(){return absFloor(this.days()/7);}var round=Math.round;var thresholds={s:45, // seconds to minute
m:45, // minutes to hour
h:22, // hours to day
d:26, // days to month
M:11 // months to year
}; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string,number,withoutSuffix,isFuture,locale){return locale.relativeTime(number||1,!!withoutSuffix,string,isFuture);}function duration_humanize__relativeTime(posNegDuration,withoutSuffix,locale){var duration=create__createDuration(posNegDuration).abs();var seconds=round(duration.as('s'));var minutes=round(duration.as('m'));var hours=round(duration.as('h'));var days=round(duration.as('d'));var months=round(duration.as('M'));var years=round(duration.as('y'));var a=seconds<thresholds.s&&['s',seconds]||minutes<=1&&['m']||minutes<thresholds.m&&['mm',minutes]||hours<=1&&['h']||hours<thresholds.h&&['hh',hours]||days<=1&&['d']||days<thresholds.d&&['dd',days]||months<=1&&['M']||months<thresholds.M&&['MM',months]||years<=1&&['y']||['yy',years];a[2]=withoutSuffix;a[3]=+posNegDuration>0;a[4]=locale;return substituteTimeAgo.apply(null,a);} // This function allows you to set a threshold for relative time strings
function duration_humanize__getSetRelativeTimeThreshold(threshold,limit){if(thresholds[threshold]===undefined){return false;}if(limit===undefined){return thresholds[threshold];}thresholds[threshold]=limit;return true;}function humanize(withSuffix){var locale=this.localeData();var output=duration_humanize__relativeTime(this,!withSuffix,locale);if(withSuffix){output=locale.pastFuture(+this,output);}return locale.postformat(output);}var iso_string__abs=Math.abs;function iso_string__toISOString(){ // for ISO strings we do not use the normal bubbling rules:
//  * milliseconds bubble up until they become hours
//  * days do not bubble at all
//  * months bubble up until they become years
// This is because there is no context-free conversion between hours and days
// (think of clock changes)
// and also not between days and months (28-31 days per month)
var seconds=iso_string__abs(this._milliseconds)/1000;var days=iso_string__abs(this._days);var months=iso_string__abs(this._months);var minutes,hours,years; // 3600 seconds -> 60 minutes -> 1 hour
minutes=absFloor(seconds/60);hours=absFloor(minutes/60);seconds%=60;minutes%=60; // 12 months -> 1 year
years=absFloor(months/12);months%=12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
var Y=years;var M=months;var D=days;var h=hours;var m=minutes;var s=seconds;var total=this.asSeconds();if(!total){ // this is the same as C#'s (Noda) and python (isodate)...
// but not other JS (goog.date)
return 'P0D';}return (total<0?'-':'')+'P'+(Y?Y+'Y':'')+(M?M+'M':'')+(D?D+'D':'')+(h||m||s?'T':'')+(h?h+'H':'')+(m?m+'M':'')+(s?s+'S':'');}var duration_prototype__proto=Duration.prototype;duration_prototype__proto.abs=duration_abs__abs;duration_prototype__proto.add=duration_add_subtract__add;duration_prototype__proto.subtract=duration_add_subtract__subtract;duration_prototype__proto.as=as;duration_prototype__proto.asMilliseconds=asMilliseconds;duration_prototype__proto.asSeconds=asSeconds;duration_prototype__proto.asMinutes=asMinutes;duration_prototype__proto.asHours=asHours;duration_prototype__proto.asDays=asDays;duration_prototype__proto.asWeeks=asWeeks;duration_prototype__proto.asMonths=asMonths;duration_prototype__proto.asYears=asYears;duration_prototype__proto.valueOf=duration_as__valueOf;duration_prototype__proto._bubble=bubble;duration_prototype__proto.get=duration_get__get;duration_prototype__proto.milliseconds=milliseconds;duration_prototype__proto.seconds=seconds;duration_prototype__proto.minutes=minutes;duration_prototype__proto.hours=hours;duration_prototype__proto.days=days;duration_prototype__proto.weeks=weeks;duration_prototype__proto.months=months;duration_prototype__proto.years=years;duration_prototype__proto.humanize=humanize;duration_prototype__proto.toISOString=iso_string__toISOString;duration_prototype__proto.toString=iso_string__toISOString;duration_prototype__proto.toJSON=iso_string__toISOString;duration_prototype__proto.locale=locale;duration_prototype__proto.localeData=localeData; // Deprecations
duration_prototype__proto.toIsoString=deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',iso_string__toISOString);duration_prototype__proto.lang=lang; // Side effect imports
// FORMATTING
addFormatToken('X',0,0,'unix');addFormatToken('x',0,0,'valueOf'); // PARSING
addRegexToken('x',matchSigned);addRegexToken('X',matchTimestamp);addParseToken('X',function(input,array,config){config._d=new Date(parseFloat(input,10)*1000);});addParseToken('x',function(input,array,config){config._d=new Date(toInt(input));}); // Side effect imports
utils_hooks__hooks.version='2.11.2';setHookCallback(local__createLocal);utils_hooks__hooks.fn=momentPrototype;utils_hooks__hooks.min=min;utils_hooks__hooks.max=max;utils_hooks__hooks.now=now;utils_hooks__hooks.utc=create_utc__createUTC;utils_hooks__hooks.unix=moment__createUnix;utils_hooks__hooks.months=lists__listMonths;utils_hooks__hooks.isDate=isDate;utils_hooks__hooks.locale=locale_locales__getSetGlobalLocale;utils_hooks__hooks.invalid=valid__createInvalid;utils_hooks__hooks.duration=create__createDuration;utils_hooks__hooks.isMoment=isMoment;utils_hooks__hooks.weekdays=lists__listWeekdays;utils_hooks__hooks.parseZone=moment__createInZone;utils_hooks__hooks.localeData=locale_locales__getLocale;utils_hooks__hooks.isDuration=isDuration;utils_hooks__hooks.monthsShort=lists__listMonthsShort;utils_hooks__hooks.weekdaysMin=lists__listWeekdaysMin;utils_hooks__hooks.defineLocale=defineLocale;utils_hooks__hooks.weekdaysShort=lists__listWeekdaysShort;utils_hooks__hooks.normalizeUnits=normalizeUnits;utils_hooks__hooks.relativeTimeThreshold=duration_humanize__getSetRelativeTimeThreshold;utils_hooks__hooks.prototype=momentPrototype;var _moment=utils_hooks__hooks;return _moment;});

},{}],35:[function(require,module,exports){
'use strict';

module.exports = require('react/lib/ReactDOM');

},{"react/lib/ReactDOM":70}],36:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusUtils
 * @typechecks static-only
 */

'use strict';

var ReactMount = require('./ReactMount');

var findDOMNode = require('./findDOMNode');
var focusNode = require('fbjs/lib/focusNode');

var Mixin = {
  componentDidMount: function componentDidMount() {
    if (this.props.autoFocus) {
      focusNode(findDOMNode(this));
    }
  }
};

var AutoFocusUtils = {
  Mixin: Mixin,

  focusDOMComponent: function focusDOMComponent() {
    focusNode(ReactMount.getNode(this._rootNodeID));
  }
};

module.exports = AutoFocusUtils;

},{"./ReactMount":100,"./findDOMNode":143,"fbjs/lib/focusNode":15}],37:[function(require,module,exports){
/**
 * Copyright 2013-2015 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var keyOf = require('fbjs/lib/keyOf');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;

},{"./EventConstants":49,"./EventPropagators":53,"./FallbackCompositionState":54,"./SyntheticCompositionEvent":125,"./SyntheticInputEvent":129,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/keyOf":25}],38:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

},{}],39:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactPerf = require('./ReactPerf');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};

  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
  };

  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
  };

  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
  };

  /**
   * @param {string} name
   * @param {*} value
   */
  var warnValidStyle = function warnValidStyle(name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function createMarkupForStyles(styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styleValue);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function setValueForStyles(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styles[styleName]);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
  setValueForStyles: 'setValueForStyles'
});

module.exports = CSSPropertyOperations;

}).call(this,require("XJF/FV"))
},{"./CSSProperty":38,"./ReactPerf":106,"./dangerousStyleValue":140,"XJF/FV":33,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/camelizeStyleName":9,"fbjs/lib/hyphenateStyleName":20,"fbjs/lib/memoizeStringOnly":27,"fbjs/lib/warning":32}],40:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function reset() {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function destructor() {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./PooledClass":58,"XJF/FV":33,"fbjs/lib/invariant":21}],41:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function get() {
    return activeElementValueProp.get.call(this);
  },
  set: function set(val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
      if (targetID) {
        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
    }
  }

};

module.exports = ChangeEventPlugin;

},{"./EventConstants":49,"./EventPluginHub":50,"./EventPropagators":53,"./ReactUpdates":118,"./SyntheticEvent":127,"./getEventTarget":149,"./isEventSupported":154,"./isTextInputElement":155,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/keyOf":25}],42:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

'use strict';

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function createReactRootIndex() {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;

},{}],43:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

'use strict';

var Danger = require('./Danger');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');
var ReactPerf = require('./ReactPerf');

var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');
var invariant = require('fbjs/lib/invariant');

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.

  // fix render order error in safari
  // IE8 will throw error when index out of list size.
  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

  parentNode.insertBefore(childNode, beforeChild);
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: setTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function processUpdates(updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; i < updates.length; i++) {
      update = updates[i];
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup;
    // markupList is either a list of markup or just a list of elements
    if (markupList.length && typeof markupList[0] === 'string') {
      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
    } else {
      renderedMarkup = markupList;
    }

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; k < updates.length; k++) {
      update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.SET_MARKUP:
          setInnerHTML(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
  updateTextContent: 'updateTextContent'
});

module.exports = DOMChildrenOperations;

}).call(this,require("XJF/FV"))
},{"./Danger":46,"./ReactMultiChildUpdateTypes":102,"./ReactPerf":106,"./setInnerHTML":159,"./setTextContent":160,"XJF/FV":33,"fbjs/lib/invariant":21}],44:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };

      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseAttribute:
   *   Whether the property must be accessed and mutated using `*Attribute()`.
   *   (This includes anything that fails `<propName> in <element>`.)
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasSideEffects:
   *   Whether or not setting a value causes side effects such as triggering
   *   resources to be loaded or text selection changes. If true, we read from
   *   the DOM before updating to ensure that the value is only set if it has
   *   changed.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function isCustomAttribute(attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function getDefaultValueForProperty(nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],45:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactPerf = require('./ReactPerf');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

// Simplified subset
var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function warnUnknownProperty(name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function createMarkupForID(id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function setAttributeForID(node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function createMarkupForProperty(name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function setValueForProperty(node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
      } else if (propertyInfo.mustUseAttribute) {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      } else {
        var propName = propertyInfo.propertyName;
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
  },

  setValueForAttribute: function setValueForAttribute(node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function deleteValueForProperty(node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseAttribute) {
        node.removeAttribute(propertyInfo.attributeName);
      } else {
        var propName = propertyInfo.propertyName;
        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
  }

};

ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
  setValueForProperty: 'setValueForProperty',
  setValueForAttribute: 'setValueForAttribute',
  deleteValueForProperty: 'deleteValueForProperty'
});

module.exports = DOMPropertyOperations;

}).call(this,require("XJF/FV"))
},{"./DOMProperty":44,"./ReactPerf":106,"./quoteAttributeValueForBrowser":157,"XJF/FV":33,"fbjs/lib/warning":32}],46:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var getMarkupWrap = require('fbjs/lib/getMarkupWrap');
var invariant = require('fbjs/lib/invariant');

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function dangerouslyRenderMarkup(markupList) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

    var newChild;
    if (typeof markup === 'string') {
      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    } else {
      newChild = markup;
    }
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/createNodesFromMarkup":12,"fbjs/lib/emptyFunction":13,"fbjs/lib/getMarkupWrap":17,"fbjs/lib/invariant":21}],47:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = require('fbjs/lib/keyOf');

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

module.exports = DefaultEventPluginOrder;

},{"fbjs/lib/keyOf":25}],48:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var ReactMount = require('./ReactMount');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    var fromID = '';
    var toID = '';
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      fromID = topLevelTargetID;
      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
      if (to) {
        toID = ReactMount.getID(to);
      } else {
        to = win;
      }
      to = to || win;
    } else {
      from = win;
      to = topLevelTarget;
      toID = topLevelTargetID;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;

},{"./EventConstants":49,"./EventPropagators":53,"./ReactMount":100,"./SyntheticMouseEvent":131,"fbjs/lib/keyOf":25}],49:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topAbort: null,
  topBlur: null,
  topCanPlay: null,
  topCanPlayThrough: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topDurationChange: null,
  topEmptied: null,
  topEncrypted: null,
  topEnded: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topLoadedData: null,
  topLoadedMetadata: null,
  topLoadStart: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topPause: null,
  topPlay: null,
  topPlaying: null,
  topProgress: null,
  topRateChange: null,
  topReset: null,
  topScroll: null,
  topSeeked: null,
  topSeeking: null,
  topSelectionChange: null,
  topStalled: null,
  topSubmit: null,
  topSuspend: null,
  topTextInput: null,
  topTimeUpdate: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topVolumeChange: null,
  topWaiting: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;

},{"fbjs/lib/keyMirror":24}],50:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
  return executeDispatchesAndRelease(e, false);
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function injectInstanceHandle(InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if (process.env.NODE_ENV !== 'production') {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function getInstanceHandle() {
      if (process.env.NODE_ENV !== 'production') {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function putListener(id, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : invariant(false) : undefined;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(id, registrationName, listener);
    }
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function getListener(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function deleteListener(id, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(id, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function deleteAllListeners(id) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][id]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(id, registrationName);
      }

      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function enqueueEvents(events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function processEventQueue(simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function __purge() {
    listenerBank = {};
  },

  __getListenerBank: function __getListenerBank() {
    return listenerBank;
  }

};

module.exports = EventPluginHub;

}).call(this,require("XJF/FV"))
},{"./EventPluginRegistry":51,"./EventPluginUtils":52,"./ReactErrorUtils":91,"./accumulateInto":137,"./forEachAccumulated":145,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],51:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function _resetEventPlugins() {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],52:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = require('./EventConstants');
var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function injectMount(InjectedMount) {
    injection.Mount = InjectedMount;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function validateEventDispatches(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, simulated, listener, domID) {
  var type = event.type || 'unknown-event';
  event.currentTarget = injection.Mount.getNode(domID);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
  }
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getNode: function getNode(id) {
    return injection.Mount.getNode(id);
  },
  getID: function getID(node) {
    return injection.Mount.getID(node);
  },

  injection: injection
};

module.exports = EventPluginUtils;

}).call(this,require("XJF/FV"))
},{"./EventConstants":49,"./ReactErrorUtils":91,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],53:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');

var warning = require('fbjs/lib/warning');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;

}).call(this,require("XJF/FV"))
},{"./EventConstants":49,"./EventPluginHub":50,"./accumulateInto":137,"./forEachAccumulated":145,"XJF/FV":33,"fbjs/lib/warning":32}],54:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 * @typechecks static-only
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

assign(FallbackCompositionState.prototype, {
  destructor: function destructor() {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function getText() {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function getData() {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;

},{"./Object.assign":57,"./PooledClass":58,"./getTextContentAccessor":152}],55:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
}

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    challenge: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formAction: MUST_USE_ATTRIBUTE,
    formEncType: MUST_USE_ATTRIBUTE,
    formMethod: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: MUST_USE_ATTRIBUTE,
    frameBorder: MUST_USE_ATTRIBUTE,
    headers: null,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    high: null,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    inputMode: MUST_USE_ATTRIBUTE,
    integrity: null,
    is: MUST_USE_ATTRIBUTE,
    keyParams: MUST_USE_ATTRIBUTE,
    keyType: MUST_USE_ATTRIBUTE,
    kind: null,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    low: null,
    manifest: MUST_USE_ATTRIBUTE,
    marginHeight: null,
    marginWidth: null,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    minLength: MUST_USE_ATTRIBUTE,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    nonce: MUST_USE_ATTRIBUTE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcLang: null,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    summary: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,
    wrap: null,

    /**
     * RDFa Properties
     */
    about: MUST_USE_ATTRIBUTE,
    datatype: MUST_USE_ATTRIBUTE,
    inlist: MUST_USE_ATTRIBUTE,
    prefix: MUST_USE_ATTRIBUTE,
    // property is also supported for OpenGraph in meta tags.
    property: MUST_USE_ATTRIBUTE,
    resource: MUST_USE_ATTRIBUTE,
    'typeof': MUST_USE_ATTRIBUTE,
    vocab: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: MUST_USE_ATTRIBUTE,
    autoCorrect: MUST_USE_ATTRIBUTE,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: null,
    // color is for Safari mask-icon link
    color: null,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: MUST_USE_ATTRIBUTE,
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    itemType: MUST_USE_ATTRIBUTE,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: MUST_USE_ATTRIBUTE,
    itemRef: MUST_USE_ATTRIBUTE,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: null,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: MUST_USE_ATTRIBUTE,
    // IE-only attribute that controls focus behavior
    unselectable: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoComplete: 'autocomplete',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    autoSave: 'autosave',
    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
    encType: 'encoding',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;

},{"./DOMProperty":44,"fbjs/lib/ExecutionEnvironment":7}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

'use strict';

var ReactPropTypes = require('./ReactPropTypes');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
}

var propTypes = {
  value: function value(props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function checked(props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: ReactPropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function checkPropTypes(tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function getValue(inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function getChecked(inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function executeOnChange(inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;

}).call(this,require("XJF/FV"))
},{"./ReactPropTypeLocations":108,"./ReactPropTypes":109,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],57:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;

},{}],58:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],59:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var ReactDOM = require('./ReactDOM');
var ReactDOMServer = require('./ReactDOMServer');
var ReactIsomorphic = require('./ReactIsomorphic');

var assign = require('./Object.assign');
var deprecated = require('./deprecated');

// `version` will be added here by ReactIsomorphic.
var React = {};

assign(React, ReactIsomorphic);

assign(React, {
  // ReactDOM
  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

  // ReactDOMServer
  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
});

React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

module.exports = React;

},{"./Object.assign":57,"./ReactDOM":70,"./ReactDOMServer":80,"./ReactIsomorphic":98,"./deprecated":141}],60:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

'use strict';

var ReactInstanceMap = require('./ReactInstanceMap');

var findDOMNode = require('./findDOMNode');
var warning = require('fbjs/lib/warning');

var didWarnKey = '_getDOMNodeDidWarn';

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function getDOMNode() {
    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
    this.constructor[didWarnKey] = true;
    return findDOMNode(this);
  }
};

module.exports = ReactBrowserComponentMixin;

}).call(this,require("XJF/FV"))
},{"./ReactInstanceMap":97,"./findDOMNode":143,"XJF/FV":33,"fbjs/lib/warning":32}],61:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ReactPerf = require('./ReactPerf');
var ViewportMetrics = require('./ViewportMetrics');

var assign = require('./Object.assign');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function setEnabled(enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function isEnabled() {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function listenTo(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
  putListener: 'putListener',
  deleteListener: 'deleteListener'
});

module.exports = ReactBrowserEventEmitter;

},{"./EventConstants":49,"./EventPluginHub":50,"./EventPluginRegistry":51,"./Object.assign":57,"./ReactEventEmitterMixin":92,"./ReactPerf":106,"./ViewportMetrics":136,"./isEventSupported":154}],62:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 * @typechecks static-only
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

function instantiateChild(childInstances, child, name) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, null);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function updateChildren(prevChildren, nextChildren, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return null;
    }
    var name;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      var prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          ReactReconciler.unmountComponent(prevChild, name);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, null);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        ReactReconciler.unmountComponent(prevChildren[name]);
      }
    }
    return nextChildren;
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function unmountChildren(renderedChildren) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  }

};

module.exports = ReactChildReconciler;

}).call(this,require("XJF/FV"))
},{"./ReactReconciler":111,"./instantiateReactComponent":153,"./shouldUpdateReactComponent":161,"./traverseAllChildren":162,"XJF/FV":33,"fbjs/lib/warning":32}],63:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

},{"./PooledClass":58,"./ReactElement":87,"./traverseAllChildren":162,"fbjs/lib/emptyFunction":13}],64:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var keyMirror = require('fbjs/lib/keyMirror');
var keyOf = require('fbjs/lib/keyOf');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

var warnedSetProps = false;
function warnSetProps() {
  if (!warnedSetProps) {
    warnedSetProps = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
  }
}

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function displayName(Constructor, _displayName) {
    Constructor.displayName = _displayName;
  },
  mixins: function mixins(Constructor, _mixins) {
    if (_mixins) {
      for (var i = 0; i < _mixins.length; i++) {
        mixSpecIntoComponent(Constructor, _mixins[i]);
      }
    }
  },
  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, _childContextTypes);
  },
  contextTypes: function contextTypes(Constructor, _contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, _contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
    } else {
      Constructor.getDefaultProps = _getDefaultProps;
    }
  },
  propTypes: function propTypes(Constructor, _propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, _propTypes);
  },
  statics: function statics(Constructor, _statics) {
    mixStaticSpecIntoComponent(Constructor, _statics);
  },
  autobind: function autobind() {} };

// noop
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but not in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    /* eslint-disable block-scoped-var, no-undef */
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
      /* eslint-enable */
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  for (var autoBindKey in component.__reactAutoBindMap) {
    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function replaceState(newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted() {
    return this.updater.isMounted(this);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  setProps: function setProps(partialProps, callback) {
    if (process.env.NODE_ENV !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueSetProps(this, partialProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  replaceProps: function replaceProps(newProps, callback) {
    if (process.env.NODE_ENV !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueReplaceProps(this, newProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  }
};

var ReactClassComponent = function ReactClassComponent() {};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function createClass(spec) {
    var Constructor = function Constructor(props, context, updater) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindMap) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function injectMixin(mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactComponent":65,"./ReactElement":87,"./ReactNoopUpdateQueue":104,"./ReactPropTypeLocationNames":107,"./ReactPropTypeLocations":108,"XJF/FV":33,"fbjs/lib/emptyObject":14,"fbjs/lib/invariant":21,"fbjs/lib/keyMirror":24,"fbjs/lib/keyOf":25,"fbjs/lib/warning":32}],65:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
  }
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
    setProps: ['setProps', 'Instead, call render again at the top level.']
  };
  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function get() {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;

}).call(this,require("XJF/FV"))
},{"./ReactNoopUpdateQueue":104,"./canDefineProperty":139,"XJF/FV":33,"fbjs/lib/emptyObject":14,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],66:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var ReactMount = require('./ReactMount');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function unmountIDFromEnvironment(rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  }

};

module.exports = ReactComponentBrowserEnvironment;

},{"./ReactDOMIDOperations":75,"./ReactMount":100}],67:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkupByID: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function injectEnvironment(environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],68:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactPerf = require('./ReactPerf');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  return Component(this.props, this.context, this.updater);
};

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function construct(element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedComponent = null;

    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function mountComponent(rootID, transaction, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._rootNodeID = rootID;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    // Initialize the public class
    var inst;
    var renderedElement;

    // This is a way to detect if Component is a stateless arrow function
    // component, which is not newable. It might not be 100% reliable but is
    // something we can do until we start detecting that Component extends
    // React.Component. We already assume that typeof Component === 'function'.
    var canInstantiate = 'prototype' in Component;

    if (canInstantiate) {
      if (process.env.NODE_ENV !== 'production') {
        ReactCurrentOwner.current = this;
        try {
          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
      }
    }

    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
      renderedElement = inst;
      inst = new StatelessComponent(Component);
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
      } else {
        // We support ES6 inheriting from React.Component, the module pattern,
        // and stateless components, but not ES6 classes that don't extend
        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
      }
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = ReactUpdateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    if (inst.componentWillMount) {
      inst.componentWillMount();
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    this._renderedComponent = this._instantiateReactComponent(renderedElement);

    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function unmountComponent() {
    var inst = this._instance;

    if (inst.componentWillUnmount) {
      inst.componentWillUnmount();
    }

    ReactReconciler.unmountComponent(this._renderedComponent);
    this._renderedComponent = null;
    this._instance = null;

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function _maskContext(context) {
    var maskedContext = null;
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function _processContext(context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function _processChildContext(currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext = inst.getChildContext && inst.getChildContext();
    if (childContext) {
      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
      if (process.env.NODE_ENV !== 'production') {
        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function _processProps(newProps) {
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function _checkPropTypes(propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // top-level render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
  },

  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
    }

    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;

    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
    var nextProps;

    // Distinguish between a props update versus a simple state update
    if (prevParentElement === nextParentElement) {
      // Skip checking prop types again -- we don't read inst.props to avoid
      // warning for DOM component props in this upgrade
      nextProps = nextParentElement.props;
    } else {
      nextProps = this._processProps(nextParentElement.props);
      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.

      if (inst.componentWillReceiveProps) {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);

    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function _processPendingState(props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      // These two IDs are actually the same! But nothing should rely on that.
      var thisID = this._rootNodeID;
      var prevComponentID = prevComponentInstance._rootNodeID;
      ReactReconciler.unmountComponent(prevComponentInstance);

      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
    }
  },

  /**
   * @protected
   */
  _replaceNodeWithMarkupByID: function _replaceNodeWithMarkupByID(prevComponentID, nextMarkup) {
    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
    var inst = this._instance;
    var renderedComponent = inst.render();
    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function _renderValidatedComponent() {
    var renderedComponent;
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function attachRef(ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function detachRef(ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function getName() {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function getPublicInstance() {
    var inst = this._instance;
    if (inst instanceof StatelessComponent) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent',
  _renderValidatedComponent: '_renderValidatedComponent'
});

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactComponentEnvironment":67,"./ReactCurrentOwner":69,"./ReactElement":87,"./ReactInstanceMap":97,"./ReactPerf":106,"./ReactPropTypeLocationNames":107,"./ReactPropTypeLocations":108,"./ReactReconciler":111,"./ReactUpdateQueue":117,"./shouldUpdateReactComponent":161,"XJF/FV":33,"fbjs/lib/emptyObject":14,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],69:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */

var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

},{}],70:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
/* eslint-enable camelcase */
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    CurrentOwner: ReactCurrentOwner,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    Reconciler: ReactReconciler,
    TextComponent: ReactDOMTextComponent
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

    // shams
    Object.create, Object.freeze];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

module.exports = React;

}).call(this,require("XJF/FV"))
},{"./ReactCurrentOwner":69,"./ReactDOMTextComponent":81,"./ReactDefaultInjection":84,"./ReactInstanceHandles":96,"./ReactMount":100,"./ReactPerf":106,"./ReactReconciler":111,"./ReactUpdates":118,"./ReactVersion":119,"./findDOMNode":143,"./renderSubtreeIntoContainer":158,"XJF/FV":33,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/warning":32}],71:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var mouseListenerNames = {
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,

  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
};

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = {
  getNativeProps: function getNativeProps(inst, props, context) {
    if (!props.disabled) {
      return props;
    }

    // Copy the props, except the mouse listeners
    var nativeProps = {};
    for (var key in props) {
      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
        nativeProps[key] = props[key];
      }
    }

    return nativeProps;
  }
};

module.exports = ReactDOMButton;

},{}],72:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventConstants = require('./EventConstants');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMButton = require('./ReactDOMButton');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactMount = require('./ReactMount');
var ReactMultiChild = require('./ReactMultiChild');
var ReactPerf = require('./ReactPerf');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var assign = require('./Object.assign');
var canDefineProperty = require('./canDefineProperty');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var keyOf = require('fbjs/lib/keyOf');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var CHILDREN = keyOf({ children: null });
var STYLE = keyOf({ style: null });
var HTML = keyOf({ __html: null });

var ELEMENT_NODE_TYPE = 1;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

var legacyPropsDescriptor;
if (process.env.NODE_ENV !== 'production') {
  legacyPropsDescriptor = {
    props: {
      enumerable: false,
      get: function get() {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
        return component._currentElement.props;
      }
    }
  };
}

function legacyGetDOMNode() {
  if (process.env.NODE_ENV !== 'production') {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return this;
}

function legacyIsMounted() {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return !!component;
}

function legacySetStateEtc() {
  if (process.env.NODE_ENV !== 'production') {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
}

function legacySetProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function legacyReplaceProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function friendlyStringify(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined becauses undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (process.env.NODE_ENV !== 'production') {
    if (voidElementTags[component._tag]) {
      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
  }
  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
  var node = ReactMount.getNode(inst._rootNodeID);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

  switch (inst._tag) {
    case 'iframe':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
        }
      }

      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
      break;
  }
}

function mountReadyInputWrapper() {
  ReactDOMInput.mountReadyWrapper(this);
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

// NOTE: menuitem's close tag should be omitted, but that causes problems.
var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContextDev(context, inst) {
  // Pass down our tag name to child components for validation purposes
  context = assign({}, context);
  var info = context[validateDOMNesting.ancestorInfoContextKey];
  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  return context;
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag.toLowerCase();
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._nodeWithLegacyProperties = null;
  if (process.env.NODE_ENV !== 'production') {
    this._unprocessedContextDev = null;
    this._processedContextDev = null;
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  construct: function construct(element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function mountComponent(rootID, transaction, context) {
    this._rootNodeID = rootID;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'button':
        props = ReactDOMButton.getNativeProps(this, props, context);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, context);
        props = ReactDOMInput.getNativeProps(this, props, context);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, context);
        props = ReactDOMOption.getNativeProps(this, props, context);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, context);
        props = ReactDOMSelect.getNativeProps(this, props, context);
        context = ReactDOMSelect.processChildContext(this, props, context);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, context);
        props = ReactDOMTextarea.getNativeProps(this, props, context);
        break;
    }

    assertValidProps(this, props);
    if (process.env.NODE_ENV !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      this._unprocessedContextDev = context;
      this._processedContextDev = processChildContextDev(context, this);
      context = this._processedContextDev;
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement(this._currentElement.type);
      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
      // Populate node cache
      ReactMount.getID(el);
      this._updateDOMProperties({}, props, transaction, el);
      this._createInitialChildren(transaction, props, context, el);
      mountImage = el;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
      // falls through
      case 'button':
      case 'select':
      case 'textarea':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (propKey !== CHILDREN) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function _createInitialChildren(transaction, props, context, el) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        setInnerHTML(el, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        setTextContent(el, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          el.appendChild(mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function receiveComponent(nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'button':
        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
        break;
      case 'input':
        ReactDOMInput.updateWrapper(this);
        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
        break;
    }

    if (process.env.NODE_ENV !== 'production') {
      // If the context is reference-equal to the old one, pass down the same
      // processed object so the update bailout in ReactReconciler behaves
      // correctly (and identically in dev and prod). See #5005.
      if (this._unprocessedContextDev !== context) {
        this._unprocessedContextDev = context;
        this._processedContextDev = processChildContextDev(context, this);
      }
      context = this._processedContextDev;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction, null);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    if (!canDefineProperty && this._nodeWithLegacyProperties) {
      this._nodeWithLegacyProperties.props = nextProps;
    }

    if (this._tag === 'select') {
      // <select> value update needs to occur after <option> children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction, node) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        if (propKey === CHILDREN) {
          nextProp = null;
        }
        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertantly setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      if (!node) {
        node = ReactMount.getNode(this._rootNodeID);
      }
      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function unmountComponent() {
    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
        ReactDOMInput.unmountWrapper(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
        break;
    }

    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
    this._wrapperState = null;
    if (this._nodeWithLegacyProperties) {
      var node = this._nodeWithLegacyProperties;
      node._reactInternalComponent = null;
      this._nodeWithLegacyProperties = null;
    }
  },

  getPublicInstance: function getPublicInstance() {
    if (!this._nodeWithLegacyProperties) {
      var node = ReactMount.getNode(this._rootNodeID);

      node._reactInternalComponent = this;
      node.getDOMNode = legacyGetDOMNode;
      node.isMounted = legacyIsMounted;
      node.setState = legacySetStateEtc;
      node.replaceState = legacySetStateEtc;
      node.forceUpdate = legacySetStateEtc;
      node.setProps = legacySetProps;
      node.replaceProps = legacyReplaceProps;

      if (process.env.NODE_ENV !== 'production') {
        if (canDefineProperty) {
          Object.defineProperties(node, legacyPropsDescriptor);
        } else {
          // updateComponent will update this property on subsequent renders
          node.props = this._currentElement.props;
        }
      } else {
        // updateComponent will update this property on subsequent renders
        node.props = this._currentElement.props;
      }

      this._nodeWithLegacyProperties = node;
    }
    return this._nodeWithLegacyProperties;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent'
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;

}).call(this,require("XJF/FV"))
},{"./AutoFocusUtils":36,"./CSSPropertyOperations":39,"./DOMProperty":44,"./DOMPropertyOperations":45,"./EventConstants":49,"./Object.assign":57,"./ReactBrowserEventEmitter":61,"./ReactComponentBrowserEnvironment":66,"./ReactDOMButton":71,"./ReactDOMInput":76,"./ReactDOMOption":77,"./ReactDOMSelect":78,"./ReactDOMTextarea":82,"./ReactMount":100,"./ReactMultiChild":101,"./ReactPerf":106,"./ReactUpdateQueue":117,"./canDefineProperty":139,"./escapeTextContentForBrowser":142,"./isEventSupported":154,"./setInnerHTML":159,"./setTextContent":160,"./validateDOMNesting":163,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/keyOf":25,"fbjs/lib/shallowEqual":30,"fbjs/lib/warning":32}],73:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFactories
 * @typechecks static-only
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');

var mapObject = require('fbjs/lib/mapObject');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if (process.env.NODE_ENV !== 'production') {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  image: 'image',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOMFactories;

}).call(this,require("XJF/FV"))
},{"./ReactElement":87,"./ReactElementValidator":88,"XJF/FV":33,"fbjs/lib/mapObject":26}],74:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFeatureFlags
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: false
};

module.exports = ReactDOMFeatureFlags;

},{}],75:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');

var invariant = require('fbjs/lib/invariant');

/**
 * Errors for properties that should not be updated with `updatePropertyByID()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: function updatePropertyByID(id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertantly setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (value != null) {
      DOMPropertyOperations.setValueForProperty(node, name, value);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, name);
    }
  },

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, markup) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
  },

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(updates, markup) {
    for (var i = 0; i < updates.length; i++) {
      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
    }
    DOMChildrenOperations.processUpdates(updates, markup);
  }
};

ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
});

module.exports = ReactDOMIDOperations;

}).call(this,require("XJF/FV"))
},{"./DOMChildrenOperations":43,"./DOMPropertyOperations":45,"./ReactMount":100,"./ReactPerf":106,"XJF/FV":33,"fbjs/lib/invariant":21}],76:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var instancesByReactID = {};

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getNativeProps: function getNativeProps(inst, props, context) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var nativeProps = assign({}, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function mountWrapper(inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null,
      onChange: _handleChange.bind(inst)
    };
  },

  mountReadyWrapper: function mountReadyWrapper(inst) {
    // Can't be in mountWrapper or else server rendering leaks.
    instancesByReactID[inst._rootNodeID] = inst;
  },

  unmountWrapper: function unmountWrapper(inst) {
    delete instancesByReactID[inst._rootNodeID];
  },

  updateWrapper: function updateWrapper(inst) {
    var props = inst._currentElement.props;

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
    }

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactMount.getNode(this._rootNodeID);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React with non-React.
      var otherID = ReactMount.getID(otherNode);
      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
      var otherInstance = instancesByReactID[otherID];
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;

}).call(this,require("XJF/FV"))
},{"./LinkedValueUtils":56,"./Object.assign":57,"./ReactDOMIDOperations":75,"./ReactMount":100,"./ReactUpdates":118,"XJF/FV":33,"fbjs/lib/invariant":21}],77:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactDOMSelect = require('./ReactDOMSelect');

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

var valueContextKey = ReactDOMSelect.valueContextKey;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function mountWrapper(inst, props, context) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
    }

    // Look up whether this option is 'selected' via context
    var selectValue = context[valueContextKey];

    // If context key is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + props.value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  getNativeProps: function getNativeProps(inst, props, context) {
    var nativeProps = assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      nativeProps.selected = inst._wrapperState.selected;
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
      }
    });

    if (content) {
      nativeProps.children = content;
    }

    return nativeProps;
  }

};

module.exports = ReactDOMOption;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactChildren":63,"./ReactDOMSelect":78,"XJF/FV":33,"fbjs/lib/warning":32}],78:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    if (props.multiple) {
      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    } else {
      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactMount.getNode(inst._rootNodeID).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  valueContextKey: valueContextKey,

  getNativeProps: function getNativeProps(inst, props, context) {
    return assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function mountWrapper(inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };
  },

  processChildContext: function processChildContext(inst, props, context) {
    // Pass down initial value so initial generated markup has correct
    // `selected` attributes
    var childContext = assign({}, context);
    childContext[valueContextKey] = inst._wrapperState.initialValue;
    return childContext;
  },

  postUpdateWrapper: function postUpdateWrapper(inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // the context value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  this._wrapperState.pendingUpdate = true;
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;

}).call(this,require("XJF/FV"))
},{"./LinkedValueUtils":56,"./Object.assign":57,"./ReactMount":100,"./ReactUpdates":118,"XJF/FV":33,"fbjs/lib/warning":32}],79:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

},{"./getNodeForCharacterOffset":151,"./getTextContentAccessor":152,"fbjs/lib/ExecutionEnvironment":7}],80:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMServer
 */

'use strict';

var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactServerRendering = require('./ReactServerRendering');
var ReactVersion = require('./ReactVersion');

ReactDefaultInjection.inject();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
  version: ReactVersion
};

module.exports = ReactDOMServer;

},{"./ReactDefaultInjection":84,"./ReactServerRendering":115,"./ReactVersion":119}],81:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactMount = require('./ReactMount');

var assign = require('./Object.assign');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setTextContent = require('./setTextContent');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function ReactDOMTextComponent(props) {
  // This constructor and its argument is currently used by mocks.
};

assign(ReactDOMTextComponent.prototype, {

  /**
   * @param {ReactText} text
   * @internal
   */
  construct: function construct(text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;

    // Properties
    this._rootNodeID = null;
    this._mountIndex = 0;
  },

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function mountComponent(rootID, transaction, context) {
    if (process.env.NODE_ENV !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    this._rootNodeID = rootID;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement('span');
      DOMPropertyOperations.setAttributeForID(el, rootID);
      // Populate node cache
      ReactMount.getID(el);
      setTextContent(el, this._stringText);
      return el;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this in a `span` for the reasons stated above, but
        // since this is a situation where React won't take over (static pages),
        // we can simply return the text as it is.
        return escapedText;
      }

      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function receiveComponent(nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var node = ReactMount.getNode(this._rootNodeID);
        DOMChildrenOperations.updateTextContent(node, nextStringText);
      }
    }
  },

  unmountComponent: function unmountComponent() {
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  }

});

module.exports = ReactDOMTextComponent;

}).call(this,require("XJF/FV"))
},{"./DOMChildrenOperations":43,"./DOMPropertyOperations":45,"./Object.assign":57,"./ReactComponentBrowserEnvironment":66,"./ReactMount":100,"./escapeTextContentForBrowser":142,"./setTextContent":160,"./validateDOMNesting":163,"XJF/FV":33}],82:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getNativeProps: function getNativeProps(inst, props, context) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    var nativeProps = assign({}, props, {
      defaultValue: undefined,
      value: undefined,
      children: inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function mountWrapper(inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
      }
      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(props);

    inst._wrapperState = {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue),
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function updateWrapper(inst) {
    var props = inst._currentElement.props;
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;

}).call(this,require("XJF/FV"))
},{"./LinkedValueUtils":56,"./Object.assign":57,"./ReactDOMIDOperations":75,"./ReactUpdates":118,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],83:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function close() {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

},{"./Object.assign":57,"./ReactUpdates":118,"./Transaction":135,"fbjs/lib/emptyFunction":13}],84:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var ClientReactRootIndex = require('./ClientReactRootIndex');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactBrowserComponentMixin = require('./ReactBrowserComponentMixin');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SelectEventPlugin = require('./SelectEventPlugin');
var ServerReactRootIndex = require('./ServerReactRootIndex');
var SimpleEventPlugin = require('./SimpleEventPlugin');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if (process.env.NODE_ENV !== 'production') {
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      var ReactDefaultPerf = require('./ReactDefaultPerf');
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};

}).call(this,require("XJF/FV"))
},{"./BeforeInputEventPlugin":37,"./ChangeEventPlugin":41,"./ClientReactRootIndex":42,"./DefaultEventPluginOrder":47,"./EnterLeaveEventPlugin":48,"./HTMLDOMPropertyConfig":55,"./ReactBrowserComponentMixin":60,"./ReactComponentBrowserEnvironment":66,"./ReactDOMComponent":72,"./ReactDOMTextComponent":81,"./ReactDefaultBatchingStrategy":83,"./ReactDefaultPerf":85,"./ReactEventListener":93,"./ReactInjection":94,"./ReactInstanceHandles":96,"./ReactMount":100,"./ReactReconcileTransaction":110,"./SVGDOMPropertyConfig":120,"./SelectEventPlugin":121,"./ServerReactRootIndex":122,"./SimpleEventPlugin":123,"XJF/FV":33,"fbjs/lib/ExecutionEnvironment":7}],85:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var DOMProperty = require('./DOMProperty');
var ReactDefaultPerfAnalysis = require('./ReactDefaultPerfAnalysis');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');

var performanceNow = require('fbjs/lib/performanceNow');

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function start() {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function stop() {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function getLastMeasurements() {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function printExclusive(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function printInclusive(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  getMeasurementsSummaryMap: function getMeasurementsSummaryMap(measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
    return summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function printWasted(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  printDOM: function printDOM(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function (item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result.type = item.type;
      result.args = JSON.stringify(item.args);
      return result;
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  _recordWrite: function _recordWrite(id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function measure(moduleName, fnName, func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0,
          created: {}
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
        return rv;
      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === '_mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function (update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
          });
        } else {
          // basic format
          var id = args[0];
          if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
            id = ReactMount.getID(args[0]);
          }
          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
      fnName === '_renderValidatedComponent')) {

        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
          return func.apply(this, args);
        }

        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          entry.created[rootNodeID] = true;
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.getName(),
          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;

},{"./DOMProperty":44,"./ReactDefaultPerfAnalysis":86,"./ReactMount":100,"./ReactPerf":106,"fbjs/lib/performanceNow":29}],86:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

'use strict';

var assign = require('./Object.assign');

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  '_mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  SET_MARKUP: 'set innerHTML',
  TEXT_CONTENT: 'set textContent',
  'setValueForProperty': 'update attribute',
  'setValueForAttribute': 'update attribute',
  'deleteValueForProperty': 'remove attribute',
  'setValueForStyles': 'update styles',
  'replaceNodeWithMarkup': 'replace',
  'updateTextContent': 'set textContent'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  measurements.forEach(function (measurement) {
    Object.keys(measurement.writes).forEach(function (id) {
      measurement.writes[id].forEach(function (write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    });
  });
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function (a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function (a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    // check if component newly created
    if (measurement.created[id]) {
      isDirty = true;
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;

},{"./Object.assign":57}],87:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactCurrentOwner = require('./ReactCurrentOwner');

var assign = require('./Object.assign');
var canDefineProperty = require('./canDefineProperty');

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    Object.freeze(element.props);
    Object.freeze(element);
  }

  return element;
};

ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

  if (process.env.NODE_ENV !== 'production') {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }

  return newElement;
};

ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactCurrentOwner":69,"./canDefineProperty":139,"XJF/FV":33}],88:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactCurrentOwner = require('./ReactCurrentOwner');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
  if (addenda === null) {
    // we already showed the warning
    return;
  }
  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} messageType A key used for de-duping warnings.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 * @returns {?object} A set of addenda to use in the warning message, or null
 * if the warning has already been shown before (and shouldn't be shown again).
 */
function getAddendaForKeyUse(messageType, element, parentType) {
  var addendum = getDeclarationErrorAddendum();
  if (!addendum) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      addendum = ' Check the top-level render call using <' + parentName + '>.';
    }
  }

  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
  if (memoizer[addendum]) {
    return null;
  }
  memoizer[addendum] = true;

  var addenda = {
    parentOrOwner: addendum,
    url: ' See https://fb.me/react-warning-keys for more information.',
    childOwner: null
  };

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  return addenda;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : undefined;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
  }
}

var ReactElementValidator = {

  createElement: function createElement(type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function createFactory(type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function cloneElement(element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;

}).call(this,require("XJF/FV"))
},{"./ReactCurrentOwner":69,"./ReactElement":87,"./ReactPropTypeLocationNames":107,"./ReactPropTypeLocations":108,"./canDefineProperty":139,"./getIteratorFn":150,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],89:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');
var ReactReconciler = require('./ReactReconciler');

var assign = require('./Object.assign');

var placeholderElement;

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function injectEmptyComponent(component) {
    placeholderElement = ReactElement.createElement(component);
  }
};

var ReactEmptyComponent = function ReactEmptyComponent(instantiate) {
  this._currentElement = null;
  this._rootNodeID = null;
  this._renderedComponent = instantiate(placeholderElement);
};
assign(ReactEmptyComponent.prototype, {
  construct: function construct(element) {},
  mountComponent: function mountComponent(rootID, transaction, context) {
    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
    this._rootNodeID = rootID;
    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
  },
  receiveComponent: function receiveComponent() {},
  unmountComponent: function unmountComponent(rootID, transaction, context) {
    ReactReconciler.unmountComponent(this._renderedComponent);
    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
    this._rootNodeID = null;
    this._renderedComponent = null;
  }
});

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;

},{"./Object.assign":57,"./ReactElement":87,"./ReactEmptyComponentRegistry":90,"./ReactReconciler":111}],90:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponentRegistry
 */

'use strict';

// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)

var nullComponentIDsRegistry = {};

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return !!nullComponentIDsRegistry[id];
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIDsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIDsRegistry[id];
}

var ReactEmptyComponentRegistry = {
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID,
  deregisterNullComponentID: deregisterNullComponentID
};

module.exports = ReactEmptyComponentRegistry;

},{}],91:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {?String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a, b) {
  try {
    return func(a, b);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
    return undefined;
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function rethrowCaughtError() {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
      var boundFunc = func.bind(null, a, b);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33}],92:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function handleTopLevel(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

},{"./EventPluginHub":50}],93:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function destructor() {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  // TODO: Re-enable event.path handling
  //
  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
  //   // New browsers have a path attribute on native events
  //   handleTopLevelWithPath(bookKeeping);
  // } else {
  //   // Legacy browsers don't have a path attribute on native events
  //   handleTopLevelWithoutPath(bookKeeping);
  // }

  void handleTopLevelWithPath; // temporarily unused
  handleTopLevelWithoutPath(bookKeeping);
}

// Legacy browsers don't have a path attribute on native events
function handleTopLevelWithoutPath(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// New browsers have a path attribute on native events
function handleTopLevelWithPath(bookKeeping) {
  var path = bookKeeping.nativeEvent.path;
  var currentNativeTarget = path[0];
  var eventsFired = 0;
  for (var i = 0; i < path.length; i++) {
    var currentPathElement = path[i];
    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
      currentNativeTarget = path[i + 1];
    }
    // TODO: slow
    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
    if (reactParent === currentPathElement) {
      var currentPathElementID = ReactMount.getID(currentPathElement);
      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
      bookKeeping.ancestors.push(currentPathElement);

      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
      eventsFired++;
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

      // Jump to the root of this React render tree
      while (currentPathElementID !== newRootID) {
        i++;
        currentPathElement = path[i];
        currentPathElementID = ReactMount.getID(currentPathElement);
      }
    }
  }
  if (eventsFired === 0) {
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function setEnabled(enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function isEnabled() {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function monitorScrollValue(refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

},{"./Object.assign":57,"./PooledClass":58,"./ReactInstanceHandles":96,"./ReactMount":100,"./ReactUpdates":118,"./getEventTarget":149,"fbjs/lib/EventListener":6,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/getUnboundedScrollPosition":18}],94:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactClass = require('./ReactClass');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactNativeComponent = require('./ReactNativeComponent');
var ReactPerf = require('./ReactPerf');
var ReactRootIndex = require('./ReactRootIndex');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

},{"./DOMProperty":44,"./EventPluginHub":50,"./ReactBrowserEventEmitter":61,"./ReactClass":64,"./ReactComponentEnvironment":67,"./ReactEmptyComponent":89,"./ReactNativeComponent":103,"./ReactPerf":106,"./ReactRootIndex":113,"./ReactUpdates":118}],95:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function getSelectionInformation() {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function restoreSelection(priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function getSelection(input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function setSelection(input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

},{"./ReactDOMSelection":79,"fbjs/lib/containsNode":10,"fbjs/lib/focusNode":15,"fbjs/lib/getActiveElement":16}],96:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

'use strict';

var ReactRootIndex = require('./ReactRootIndex');

var invariant = require('fbjs/lib/invariant');

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 10000;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  var i;
  for (i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {*} arg Argument to invoke the callback with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
  var traverseUp = isAncestorIDOf(stop, start);
  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start;; /* until break */id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function createReactRootID() {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function createReactID(rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function getReactRootIDFromNodeID(id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function traverseEnterLeave(leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function traverseTwoPhase(targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Same as `traverseTwoPhase` but skips the `targetID`.
   */
  traverseTwoPhaseSkipTarget: function traverseTwoPhaseSkipTarget(targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, true);
      traverseParentPath(targetID, '', cb, arg, true, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function traverseAncestors(targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;

}).call(this,require("XJF/FV"))
},{"./ReactRootIndex":113,"XJF/FV":33,"fbjs/lib/invariant":21}],97:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function remove(key) {
    key._reactInternalInstance = undefined;
  },

  get: function get(key) {
    return key._reactInternalInstance;
  },

  has: function has(key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function set(key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;

},{}],98:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactIsomorphic
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var assign = require('./Object.assign');
var onlyChild = require('./onlyChild');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function createMixin(mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign
};

module.exports = React;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactChildren":63,"./ReactClass":64,"./ReactComponent":65,"./ReactDOMFactories":73,"./ReactElement":87,"./ReactElementValidator":88,"./ReactPropTypes":109,"./ReactVersion":119,"./onlyChild":156,"XJF/FV":33}],99:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function addChecksumToMarkup(markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags and self-closing tags)
    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function canReuseMarkup(markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

},{"./adler32":138}],100:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactElement = require('./ReactElement');
var ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var containsNode = require('fbjs/lib/containsNode');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if (process.env.NODE_ENV !== 'production') {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * Finds the node with the supplied public React instance.
 *
 * @param {*} instance A public React instance.
 * @return {?DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNodeFromInstance(instance) {
  var id = ReactInstanceMap.get(instance)._rootNodeID;
  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
    return null;
  }
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
  if (ReactDOMFeatureFlags.useCreateElement) {
    context = assign({}, context);
    if (container.nodeType === DOC_NODE_TYPE) {
      context[ownerDocumentContextKey] = container;
    } else {
      context[ownerDocumentContextKey] = container.ownerDocument;
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (context === emptyObject) {
      context = {};
    }
    var tag = container.nodeName.toLowerCase();
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
  }
  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* forceHTML */shouldReuseMarkup);
  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container) {
  ReactReconciler.unmountComponent(instance);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(node) {
  var reactRootID = getReactRootID(node);
  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
}

/**
 * Returns the first (deepest) ancestor of a node which is rendered by this copy
 * of React.
 */
function findFirstReactDOMImpl(node) {
  // This node might be from another React instance, so we make sure not to
  // examine the node cache here
  for (; node && node.parentNode !== node; node = node.parentNode) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      continue;
    }
    var nodeID = internalGetID(node);
    if (!nodeID) {
      continue;
    }
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

    // If containersByReactRootID contains the container we find by crawling up
    // the tree, we know that this instance of React rendered the node.
    // nb. isValid's strategy (with containsNode) does not work because render
    // trees may be nested and we don't want a false positive in that case.
    var current = node;
    var lastID;
    do {
      lastID = internalGetID(current);
      current = current.parentNode;
      if (current == null) {
        // The passed-in node has been detached from the container it was
        // originally rendered into.
        return null;
      }
    } while (lastID !== reactRootID);

    if (current === containersByReactRootID[reactRootID]) {
      return node;
    }
  }
  return null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var TopLevelWrapper = function TopLevelWrapper() {};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  // this.props is actually a ReactElement
  return this.props;
};

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function scrollMonitor(container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    if (process.env.NODE_ENV !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function _registerComponent(nextComponent, container) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(componentInstance, container);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

    if (process.env.NODE_ENV !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function render(nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function registerContainer(container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function unmountComponentAtNode(container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var containerID = internalGetID(container);
      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
      }

      return false;
    }
    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if (process.env.NODE_ENV !== 'production') {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function findReactContainerForID(id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if (process.env.NODE_ENV !== 'production') {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        process.env.NODE_ENV !== 'production' ? warning(
        // Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
        var containerChild = container.firstChild;
        if (containerChild && reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function findReactNodeByID(id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component rendered by this copy of React.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function getFirstReactDOM(node) {
    return findFirstReactDOMImpl(node);
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function findComponentRoot(ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    if (process.env.NODE_ENV !== 'production') {
      // This will throw on the next line; give an early warning
      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
    }

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }
        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
  },

  _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      container.appendChild(markup);
    } else {
      setInnerHTML(container, markup);
    }
  },

  ownerDocumentContextKey: ownerDocumentContextKey,

  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  getNodeFromInstance: getNodeFromInstance,

  isValid: isValid,

  purgeID: purgeID
};

ReactPerf.measureMethods(ReactMount, 'ReactMount', {
  _renderNewRootComponent: '_renderNewRootComponent',
  _mountImageIntoNode: '_mountImageIntoNode'
});

module.exports = ReactMount;

}).call(this,require("XJF/FV"))
},{"./DOMProperty":44,"./Object.assign":57,"./ReactBrowserEventEmitter":61,"./ReactCurrentOwner":69,"./ReactDOMFeatureFlags":74,"./ReactElement":87,"./ReactEmptyComponentRegistry":90,"./ReactInstanceHandles":96,"./ReactInstanceMap":97,"./ReactMarkupChecksum":99,"./ReactPerf":106,"./ReactReconciler":111,"./ReactUpdateQueue":117,"./ReactUpdates":118,"./instantiateReactComponent":153,"./setInnerHTML":159,"./shouldUpdateReactComponent":161,"./validateDOMNesting":163,"XJF/FV":33,"fbjs/lib/containsNode":10,"fbjs/lib/emptyObject":14,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],101:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var flattenChildren = require('./flattenChildren');

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueInsertMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    content: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the markup of a node.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function enqueueSetMarkup(parentID, markup) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.SET_MARKUP,
    markupIndex: null,
    content: markup,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    content: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
      var nextChildren;
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements);
          } finally {
            ReactCurrentOwner.current = null;
          }
          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements);
      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function mountChildren(nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function updateTextContent(nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        // TODO: The setTextContent operation should be enough
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChild(prevChildren[name]);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function updateMarkup(nextMarkup) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        this.setMarkup(nextMarkup);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildrenElements, transaction, context);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
      this._renderedChildren = nextChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChild(prevChild);
          }
          // The child must be instantiated before it's mounted.
          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          this._unmountChild(prevChildren[name]);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function unmountChildren() {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function moveChild(child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function createChild(child, mountImage) {
      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function removeChild(child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function setTextContent(textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Sets this markup string.
     *
     * @param {string} markup Markup to set.
     * @protected
     */
    setMarkup: function setMarkup(markup) {
      enqueueSetMarkup(this._rootNodeID, markup);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function _mountChildByNameAtIndex(child, name, index, transaction, context) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
      child._mountIndex = index;
      this.createChild(child, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function _unmountChild(child) {
      this.removeChild(child);
      child._mountIndex = null;
    }

  }

};

module.exports = ReactMultiChild;

}).call(this,require("XJF/FV"))
},{"./ReactChildReconciler":62,"./ReactComponentEnvironment":67,"./ReactCurrentOwner":69,"./ReactMultiChildUpdateTypes":102,"./ReactReconciler":111,"./flattenChildren":144,"XJF/FV":33}],102:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  SET_MARKUP: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;

},{"fbjs/lib/keyMirror":24}],103:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function injectTextComponentClass(componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function injectComponentClasses(componentClasses) {
    assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
  return new genericComponentClass(element.type, element.props);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"XJF/FV":33,"fbjs/lib/invariant":21}],104:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNoopUpdateQueue
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnTDZ(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted(publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function enqueueCallback(publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
    warnTDZ(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
    warnTDZ(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
    warnTDZ(publicInstance, 'setState');
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
    warnTDZ(publicInstance, 'setProps');
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
    warnTDZ(publicInstance, 'replaceProps');
  }

};

module.exports = ReactNoopUpdateQueue;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/warning":32}],105:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function isValidOwner(object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],106:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

'use strict';

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */

var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * @param {object} object
   * @param {string} objectName
   * @param {object<string>} methodNames
   */
  measureMethods: function measureMethods(object, objectName, methodNames) {
    if (process.env.NODE_ENV !== 'production') {
      for (var key in methodNames) {
        if (!methodNames.hasOwnProperty(key)) {
          continue;
        }
        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
      }
    }
  },

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function measure(objName, fnName, func) {
    if (process.env.NODE_ENV !== 'production') {
      var measuredFunc = null;
      var wrapper = function wrapper() {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function injectMeasure(measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33}],107:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33}],108:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;

},{"fbjs/lib/keyMirror":24}],109:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return '<<anonymous>>';
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;

},{"./ReactElement":87,"./ReactPropTypeLocationNames":107,"./getIteratorFn":150,"fbjs/lib/emptyFunction":13}],110:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

'use strict';

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactInputSelection = require('./ReactInputSelection');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function initialize() {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function close(previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function initialize() {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function close() {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(forceHTML) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function getReactMountReady() {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function destructor() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;

},{"./CallbackQueue":40,"./Object.assign":57,"./PooledClass":58,"./ReactBrowserEventEmitter":61,"./ReactDOMFeatureFlags":74,"./ReactInputSelection":95,"./Transaction":135}],111:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require('./ReactRef');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
    var markup = internalInstance.mountComponent(rootID, transaction, context);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function unmountComponent(internalInstance) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent();
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction) {
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;

},{"./ReactRef":112}],112:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;

  return(
    // This has a few false positives w/r/t empty components.
    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
  );
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;

},{"./ReactOwner":105}],113:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

'use strict';

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function injectCreateReactRootIndex(_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;

},{}],114:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerBatchingStrategy
 * @typechecks
 */

'use strict';

var ReactServerBatchingStrategy = {
  isBatchingUpdates: false,
  batchedUpdates: function batchedUpdates(callback) {
    // Don't do anything here. During the server rendering we don't want to
    // schedule any updates. We will simply ignore them.
  }
};

module.exports = ReactServerBatchingStrategy;

},{}],115:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
'use strict';

var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactServerBatchingStrategy = require('./ReactServerBatchingStrategy');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, emptyObject);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};

}).call(this,require("XJF/FV"))
},{"./ReactDefaultBatchingStrategy":83,"./ReactElement":87,"./ReactInstanceHandles":96,"./ReactMarkupChecksum":99,"./ReactServerBatchingStrategy":114,"./ReactServerRenderingTransaction":116,"./ReactUpdates":118,"./instantiateReactComponent":153,"XJF/FV":33,"fbjs/lib/emptyObject":14,"fbjs/lib/invariant":21}],116:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

'use strict';

var PooledClass = require('./PooledClass');
var CallbackQueue = require('./CallbackQueue');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function initialize() {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = false;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function getReactMountReady() {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function destructor() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;

},{"./CallbackQueue":40,"./Object.assign":57,"./PooledClass":58,"./Transaction":135,"fbjs/lib/emptyFunction":13}],117:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted(publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function enqueueCallback(publicInstance, callback) {
    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
  },

  enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    var props = assign({}, element.props, partialProps);
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
  },

  enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  }

};

module.exports = ReactUpdateQueue;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactCurrentOwner":69,"./ReactElement":87,"./ReactInstanceMap":97,"./ReactUpdates":118,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],118:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
}

var NESTED_UPDATES = {
  initialize: function initialize() {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function close() {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function initialize() {
    this.callbackQueue.reset();
  },
  close: function close() {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
}

assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function destructor() {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function perform(method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function flushBatchedUpdates() {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;

}).call(this,require("XJF/FV"))
},{"./CallbackQueue":40,"./Object.assign":57,"./PooledClass":58,"./ReactPerf":106,"./ReactReconciler":111,"./Transaction":135,"XJF/FV":33,"fbjs/lib/invariant":21}],119:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactVersion
 */

'use strict';

module.exports = '0.14.7';

},{}],120:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

var SVGDOMPropertyConfig = {
  Properties: {
    clipPath: MUST_USE_ATTRIBUTE,
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    xlinkActuate: MUST_USE_ATTRIBUTE,
    xlinkArcrole: MUST_USE_ATTRIBUTE,
    xlinkHref: MUST_USE_ATTRIBUTE,
    xlinkRole: MUST_USE_ATTRIBUTE,
    xlinkShow: MUST_USE_ATTRIBUTE,
    xlinkTitle: MUST_USE_ATTRIBUTE,
    xlinkType: MUST_USE_ATTRIBUTE,
    xmlBase: MUST_USE_ATTRIBUTE,
    xmlLang: MUST_USE_ATTRIBUTE,
    xmlSpace: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {
    clipPath: 'clip-path',
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space'
  }
};

module.exports = SVGDOMPropertyConfig;

},{"./DOMProperty":44}],121:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');
var shallowEqual = require('fbjs/lib/shallowEqual');

var topLevelTypes = EventConstants.topLevelTypes;

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case topLevelTypes.topSelectionChange:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function didPutListener(id, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;

},{"./EventConstants":49,"./EventPropagators":53,"./ReactInputSelection":95,"./SyntheticEvent":127,"./isTextInputElement":155,"fbjs/lib/ExecutionEnvironment":7,"fbjs/lib/getActiveElement":16,"fbjs/lib/keyOf":25,"fbjs/lib/shallowEqual":30}],122:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

'use strict';

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */

var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function createReactRootIndex() {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;

},{}],123:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactMount = require('./ReactMount');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  abort: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAbort: true }),
      captured: keyOf({ onAbortCapture: true })
    }
  },
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  canPlay: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlay: true }),
      captured: keyOf({ onCanPlayCapture: true })
    }
  },
  canPlayThrough: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlayThrough: true }),
      captured: keyOf({ onCanPlayThroughCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  durationChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDurationChange: true }),
      captured: keyOf({ onDurationChangeCapture: true })
    }
  },
  emptied: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEmptied: true }),
      captured: keyOf({ onEmptiedCapture: true })
    }
  },
  encrypted: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEncrypted: true }),
      captured: keyOf({ onEncryptedCapture: true })
    }
  },
  ended: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEnded: true }),
      captured: keyOf({ onEndedCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  loadedData: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedData: true }),
      captured: keyOf({ onLoadedDataCapture: true })
    }
  },
  loadedMetadata: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedMetadata: true }),
      captured: keyOf({ onLoadedMetadataCapture: true })
    }
  },
  loadStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadStart: true }),
      captured: keyOf({ onLoadStartCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  pause: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPause: true }),
      captured: keyOf({ onPauseCapture: true })
    }
  },
  play: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlay: true }),
      captured: keyOf({ onPlayCapture: true })
    }
  },
  playing: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlaying: true }),
      captured: keyOf({ onPlayingCapture: true })
    }
  },
  progress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onProgress: true }),
      captured: keyOf({ onProgressCapture: true })
    }
  },
  rateChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onRateChange: true }),
      captured: keyOf({ onRateChangeCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  seeked: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeked: true }),
      captured: keyOf({ onSeekedCapture: true })
    }
  },
  seeking: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeking: true }),
      captured: keyOf({ onSeekingCapture: true })
    }
  },
  stalled: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onStalled: true }),
      captured: keyOf({ onStalledCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  suspend: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSuspend: true }),
      captured: keyOf({ onSuspendCapture: true })
    }
  },
  timeUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTimeUpdate: true }),
      captured: keyOf({ onTimeUpdateCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  volumeChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onVolumeChange: true }),
      captured: keyOf({ onVolumeChangeCapture: true })
    }
  },
  waiting: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWaiting: true }),
      captured: keyOf({ onWaitingCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topAbort: eventTypes.abort,
  topBlur: eventTypes.blur,
  topCanPlay: eventTypes.canPlay,
  topCanPlayThrough: eventTypes.canPlayThrough,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topDurationChange: eventTypes.durationChange,
  topEmptied: eventTypes.emptied,
  topEncrypted: eventTypes.encrypted,
  topEnded: eventTypes.ended,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topLoadedData: eventTypes.loadedData,
  topLoadedMetadata: eventTypes.loadedMetadata,
  topLoadStart: eventTypes.loadStart,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topPause: eventTypes.pause,
  topPlay: eventTypes.play,
  topPlaying: eventTypes.playing,
  topProgress: eventTypes.progress,
  topRateChange: eventTypes.rateChange,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSeeked: eventTypes.seeked,
  topSeeking: eventTypes.seeking,
  topStalled: eventTypes.stalled,
  topSubmit: eventTypes.submit,
  topSuspend: eventTypes.suspend,
  topTimeUpdate: eventTypes.timeUpdate,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topVolumeChange: eventTypes.volumeChange,
  topWaiting: eventTypes.waiting,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topAbort:
      case topLevelTypes.topCanPlay:
      case topLevelTypes.topCanPlayThrough:
      case topLevelTypes.topDurationChange:
      case topLevelTypes.topEmptied:
      case topLevelTypes.topEncrypted:
      case topLevelTypes.topEnded:
      case topLevelTypes.topError:
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topLoadedData:
      case topLevelTypes.topLoadedMetadata:
      case topLevelTypes.topLoadStart:
      case topLevelTypes.topPause:
      case topLevelTypes.topPlay:
      case topLevelTypes.topPlaying:
      case topLevelTypes.topProgress:
      case topLevelTypes.topRateChange:
      case topLevelTypes.topReset:
      case topLevelTypes.topSeeked:
      case topLevelTypes.topSeeking:
      case topLevelTypes.topStalled:
      case topLevelTypes.topSubmit:
      case topLevelTypes.topSuspend:
      case topLevelTypes.topTimeUpdate:
      case topLevelTypes.topVolumeChange:
      case topLevelTypes.topWaiting:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function didPutListener(id, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var node = ReactMount.getNode(id);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function willDeleteListener(id, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;

}).call(this,require("XJF/FV"))
},{"./EventConstants":49,"./EventPropagators":53,"./ReactMount":100,"./SyntheticClipboardEvent":124,"./SyntheticDragEvent":126,"./SyntheticEvent":127,"./SyntheticFocusEvent":128,"./SyntheticKeyboardEvent":130,"./SyntheticMouseEvent":131,"./SyntheticTouchEvent":132,"./SyntheticUIEvent":133,"./SyntheticWheelEvent":134,"./getEventCharCode":146,"XJF/FV":33,"fbjs/lib/EventListener":6,"fbjs/lib/emptyFunction":13,"fbjs/lib/invariant":21,"fbjs/lib/keyOf":25}],124:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function clipboardData(event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;

},{"./SyntheticEvent":127}],125:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;

},{"./SyntheticEvent":127}],126:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

},{"./SyntheticMouseEvent":131}],127:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function timeStamp(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function preventDefault() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function stopPropagation() {
    var event = this.nativeEvent;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function persist() {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function destructor() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./PooledClass":58,"XJF/FV":33,"fbjs/lib/emptyFunction":13,"fbjs/lib/warning":32}],128:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

},{"./SyntheticUIEvent":133}],129:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;

},{"./SyntheticEvent":127}],130:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function charCode(event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function keyCode(event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function which(event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

},{"./SyntheticUIEvent":133,"./getEventCharCode":146,"./getEventKey":147,"./getEventModifierState":148}],131:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function button(event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function relatedTarget(event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function pageX(event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function pageY(event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

},{"./SyntheticUIEvent":133,"./ViewportMetrics":136,"./getEventModifierState":148}],132:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

},{"./SyntheticUIEvent":133,"./getEventModifierState":148}],133:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function view(event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function detail(event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

},{"./SyntheticEvent":127,"./getEventTarget":149}],134:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function deltaX(event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function deltaY(event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

},{"./SyntheticMouseEvent":131}],135:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function reinitializeTransaction() {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function isInTransaction() {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function perform(method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function initializeAll(startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function closeAll(startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occurred.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],136:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function refreshScrollValues(scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

},{}],137:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33,"fbjs/lib/invariant":21}],138:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    for (; i < Math.min(i + 4096, m); i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;

},{}],139:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule canDefineProperty
 */

'use strict';

var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function get() {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;

}).call(this,require("XJF/FV"))
},{"XJF/FV":33}],140:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require('./CSSProperty');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;

},{"./CSSProperty":38}],141:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule deprecated
 */

'use strict';

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

/**
 * This will log a single deprecation notice per function and forward the call
 * on to the new API.
 *
 * @param {string} fnName The name of the function
 * @param {string} newModule The module that fn will exist in
 * @param {string} newPackage The module that fn will exist in
 * @param {*} ctx The context this forwarded call should run in
 * @param {function} fn The function to forward on to
 * @return {function} The function that will warn once and then call fn
 */
function deprecated(fnName, newModule, newPackage, ctx, fn) {
  var warned = false;
  if (process.env.NODE_ENV !== 'production') {
    var newFn = function newFn() {
      process.env.NODE_ENV !== 'production' ? warning(warned,
      // Require examples in this string must be split to prevent React's
      // build tools from mistaking them for real requires.
      // Otherwise the build tools will attempt to build a '%s' module.
      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
      warned = true;
      return fn.apply(ctx, arguments);
    };
    // We need to make sure all properties of the original fn are copied over.
    // In particular, this is needed to support PropTypes
    return assign(newFn, fn);
  }

  return fn;
}

module.exports = deprecated;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"XJF/FV":33,"fbjs/lib/warning":32}],142:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;

},{}],143:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMount = require('./ReactMount');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }
  if (ReactInstanceMap.has(componentOrElement)) {
    return ReactMount.getNodeFromInstance(componentOrElement);
  }
  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
  !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
}

module.exports = findDOMNode;

}).call(this,require("XJF/FV"))
},{"./ReactCurrentOwner":69,"./ReactInstanceMap":97,"./ReactMount":100,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],144:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;

}).call(this,require("XJF/FV"))
},{"./traverseAllChildren":162,"XJF/FV":33,"fbjs/lib/warning":32}],145:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

var forEachAccumulated = function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;

},{}],146:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;

},{}],147:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;

},{"./getEventCharCode":146}],148:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

},{}],149:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

},{}],150:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * @typechecks static-only
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

},{}],151:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

},{}],152:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

},{"fbjs/lib/ExecutionEnvironment":7}],153:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactNativeComponent = require('./ReactNativeComponent');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper() {};
assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  if (node === null || node === false) {
    instance = new ReactEmptyComponent(instantiateReactComponent);
  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : invariant(false) : undefined;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
  }

  // Sets up the instance. This can probably just move into the constructor now.
  instance.construct(node);

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"./ReactCompositeComponent":68,"./ReactEmptyComponent":89,"./ReactNativeComponent":103,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],154:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

},{"fbjs/lib/ExecutionEnvironment":7}],155:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
}

module.exports = isTextInputElement;

},{}],156:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
  return children;
}

module.exports = onlyChild;

}).call(this,require("XJF/FV"))
},{"./ReactElement":87,"XJF/FV":33,"fbjs/lib/invariant":21}],157:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;

},{"./escapeTextContentForBrowser":142}],158:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;

},{"./ReactMount":100}],159:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

/* globals MSApp */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function setInnerHTML(node, html) {
  node.innerHTML = html;
};

// Win8 apps: Allow all html to be inserted
if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
  setInnerHTML = function setInnerHTML(node, html) {
    MSApp.execUnsafeLocalFunction(function () {
      node.innerHTML = html;
    });
  };
}

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function setInnerHTML(node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;

},{"fbjs/lib/ExecutionEnvironment":7}],160:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function setTextContent(node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function setTextContent(node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;

},{"./escapeTextContentForBrowser":142,"./setInnerHTML":159,"fbjs/lib/ExecutionEnvironment":7}],161:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;

},{}],162:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

var didWarnAboutMaps = false;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} text Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;

}).call(this,require("XJF/FV"))
},{"./ReactCurrentOwner":69,"./ReactElement":87,"./ReactInstanceHandles":96,"./getIteratorFn":150,"XJF/FV":33,"fbjs/lib/invariant":21,"fbjs/lib/warning":32}],163:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    parentTag: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.parentTag = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function findOwnerStack(instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    /*eslint-disable space-after-keywords */
    do {
      /*eslint-enable space-after-keywords */
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
      }
    }
  };

  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;

}).call(this,require("XJF/FV"))
},{"./Object.assign":57,"XJF/FV":33,"fbjs/lib/emptyFunction":13,"fbjs/lib/warning":32}],164:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":59}]},{},[4])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYS10eXBcXERvY3VtZW50c1xcR2l0XFxyZWFjdC1tYWdpYy1taXJyb3JcXG5vZGVfbW9kdWxlc1xcZ3VscC1icm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJHcmVldGluZy5qc3giLCJIb21lLmpzeCIsIldlYXRoZXIuanN4IiwiZmFrZV9lZjhmMmNmNi5qcyIsImluZGV4LmpzIiwiRXZlbnRMaXN0ZW5lci5qcyIsIkV4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiY2FtZWxpemUuanMiLCJjYW1lbGl6ZVN0eWxlTmFtZS5qcyIsImNvbnRhaW5zTm9kZS5qcyIsImNyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwiY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwiZW1wdHlGdW5jdGlvbi5qcyIsImVtcHR5T2JqZWN0LmpzIiwiZm9jdXNOb2RlLmpzIiwiZ2V0QWN0aXZlRWxlbWVudC5qcyIsImdldE1hcmt1cFdyYXAuanMiLCJnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsImh5cGhlbmF0ZS5qcyIsImh5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsImludmFyaWFudC5qcyIsImlzTm9kZS5qcyIsImlzVGV4dE5vZGUuanMiLCJrZXlNaXJyb3IuanMiLCJrZXlPZi5qcyIsIm1hcE9iamVjdC5qcyIsIm1lbW9pemVTdHJpbmdPbmx5LmpzIiwicGVyZm9ybWFuY2UuanMiLCJwZXJmb3JtYW5jZU5vdy5qcyIsInNoYWxsb3dFcXVhbC5qcyIsInRvQXJyYXkuanMiLCJ3YXJuaW5nLmpzIiwiYnJvd3Nlci5qcyIsIm1vbWVudC5qcyIsIkF1dG9Gb2N1c1V0aWxzLmpzIiwiQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIkNTU1Byb3BlcnR5LmpzIiwiQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiQ2FsbGJhY2tRdWV1ZS5qcyIsIkNoYW5nZUV2ZW50UGx1Z2luLmpzIiwiQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJET01Qcm9wZXJ0eS5qcyIsIkRPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIkRhbmdlci5qcyIsIkRlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwiRXZlbnRDb25zdGFudHMuanMiLCJFdmVudFBsdWdpbkh1Yi5qcyIsIkV2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJFdmVudFBsdWdpblV0aWxzLmpzIiwiRXZlbnRQcm9wYWdhdG9ycy5qcyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIkhUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIkxpbmtlZFZhbHVlVXRpbHMuanMiLCJPYmplY3QuYXNzaWduLmpzIiwiUG9vbGVkQ2xhc3MuanMiLCJSZWFjdC5qcyIsIlJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwiUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwiUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJSZWFjdENoaWxkcmVuLmpzIiwiUmVhY3RDbGFzcy5qcyIsIlJlYWN0Q29tcG9uZW50LmpzIiwiUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwiUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJSZWFjdEN1cnJlbnRPd25lci5qcyIsIlJlYWN0RE9NLmpzIiwiUmVhY3RET01CdXR0b24uanMiLCJSZWFjdERPTUNvbXBvbmVudC5qcyIsIlJlYWN0RE9NRmFjdG9yaWVzLmpzIiwiUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJSZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIlJlYWN0RE9NSW5wdXQuanMiLCJSZWFjdERPTU9wdGlvbi5qcyIsIlJlYWN0RE9NU2VsZWN0LmpzIiwiUmVhY3RET01TZWxlY3Rpb24uanMiLCJSZWFjdERPTVNlcnZlci5qcyIsIlJlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIlJlYWN0RE9NVGV4dGFyZWEuanMiLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwiUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwiUmVhY3REZWZhdWx0UGVyZi5qcyIsIlJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIlJlYWN0RWxlbWVudC5qcyIsIlJlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIlJlYWN0RW1wdHlDb21wb25lbnQuanMiLCJSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanMiLCJSZWFjdEVycm9yVXRpbHMuanMiLCJSZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiUmVhY3RFdmVudExpc3RlbmVyLmpzIiwiUmVhY3RJbmplY3Rpb24uanMiLCJSZWFjdElucHV0U2VsZWN0aW9uLmpzIiwiUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCJSZWFjdEluc3RhbmNlTWFwLmpzIiwiUmVhY3RJc29tb3JwaGljLmpzIiwiUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIlJlYWN0TW91bnQuanMiLCJSZWFjdE11bHRpQ2hpbGQuanMiLCJSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIlJlYWN0TmF0aXZlQ29tcG9uZW50LmpzIiwiUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJSZWFjdE93bmVyLmpzIiwiUmVhY3RQZXJmLmpzIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25zLmpzIiwiUmVhY3RQcm9wVHlwZXMuanMiLCJSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwiUmVhY3RSZWNvbmNpbGVyLmpzIiwiUmVhY3RSZWYuanMiLCJSZWFjdFJvb3RJbmRleC5qcyIsIlJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneS5qcyIsIlJlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwiUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIlJlYWN0VXBkYXRlUXVldWUuanMiLCJSZWFjdFVwZGF0ZXMuanMiLCJSZWFjdFZlcnNpb24uanMiLCJTVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIlNlbGVjdEV2ZW50UGx1Z2luLmpzIiwiU2VydmVyUmVhY3RSb290SW5kZXguanMiLCJTaW1wbGVFdmVudFBsdWdpbi5qcyIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIlN5bnRoZXRpY0RyYWdFdmVudC5qcyIsIlN5bnRoZXRpY0V2ZW50LmpzIiwiU3ludGhldGljRm9jdXNFdmVudC5qcyIsIlN5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwiU3ludGhldGljTW91c2VFdmVudC5qcyIsIlN5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJTeW50aGV0aWNVSUV2ZW50LmpzIiwiU3ludGhldGljV2hlZWxFdmVudC5qcyIsIlRyYW5zYWN0aW9uLmpzIiwiVmlld3BvcnRNZXRyaWNzLmpzIiwiYWNjdW11bGF0ZUludG8uanMiLCJhZGxlcjMyLmpzIiwiY2FuRGVmaW5lUHJvcGVydHkuanMiLCJkYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwiZGVwcmVjYXRlZC5qcyIsImVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsImZpbmRET01Ob2RlLmpzIiwiZmxhdHRlbkNoaWxkcmVuLmpzIiwiZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwiZ2V0RXZlbnRDaGFyQ29kZS5qcyIsImdldEV2ZW50S2V5LmpzIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwiZ2V0RXZlbnRUYXJnZXQuanMiLCJnZXRJdGVyYXRvckZuLmpzIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsImdldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiaXNFdmVudFN1cHBvcnRlZC5qcyIsImlzVGV4dElucHV0RWxlbWVudC5qcyIsIm9ubHlDaGlsZC5qcyIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJzZXRJbm5lckhUTUwuanMiLCJzZXRUZXh0Q29udGVudC5qcyIsInNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwidHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsInZhbGlkYXRlRE9NTmVzdGluZy5qcyIsInJlYWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTSxTQUFTLFFBQVEsUUFBUixDQUFUOztBQUVOLElBQU0sWUFBWSxDQUNkLEVBQUUsT0FBTyxDQUFQLEVBQVUsS0FBSyxDQUFMLEVBQVEsTUFBTSxrQkFBTixFQUROLEVBRWQsRUFBRSxPQUFPLENBQVAsRUFBVSxLQUFLLEVBQUwsRUFBUyxNQUFNLG1CQUFOLEVBRlAsRUFHZCxFQUFFLE9BQU8sRUFBUCxFQUFXLEtBQUssRUFBTCxFQUFTLE1BQU0scUJBQU4sRUFIUixFQUlkLEVBQUUsT0FBTyxFQUFQLEVBQVcsS0FBSyxFQUFMLEVBQVMsTUFBTSxtQkFBTixFQUpSLENBQVo7O0FBT04sSUFBTSxtQkFBbUIsU0FBbkIsZ0JBQW1CLENBQUMsSUFBRCxFQUFVO0FBQy9CLFFBQUksT0FBTyxTQUFTLElBQVQsRUFBUCxDQUQyQjtBQUUvQixRQUFJLE9BQU8sRUFBUCxDQUYyQjtBQUcvQixjQUFVLE9BQVYsQ0FBa0IsVUFBQyxRQUFELEVBQWM7QUFDNUIsWUFBSSxRQUFRLFNBQVMsS0FBVCxJQUFrQixPQUFPLFNBQVMsR0FBVCxFQUFjO0FBQy9DLG1CQUFPLFNBQVMsSUFBVCxDQUFjLE9BQWQsQ0FBc0IsSUFBdEIsRUFBNEIsSUFBNUIsQ0FBUCxDQUQrQztTQUFuRDtLQURjLENBQWxCLENBSCtCOztBQVMvQixXQUFPLElBQVAsQ0FUK0I7Q0FBVjs7QUFZekIsSUFBTSxnQkFBZ0IsU0FBaEIsYUFBZ0IsQ0FBQyxJQUFELEVBQVU7QUFDNUIsUUFBSSxNQUFNLFFB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RyxHQUFIO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsS0FBRyxHQUFIO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsY0FBWSxZQUFaO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsY0FBWSxZQUFaO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsS0FBRyxHQUFIO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsS0FBRyxHQUFIO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsS0FBRyxHQUFIO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsS0FBRyxHQUFIO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsVUFBUSxRQUFSO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsV0FBUyxTQUFUO0FBQ0EsT0FBSyxLQUFMO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsWUFBVSxVQUFWO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsUUFBTSxNQUFOO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsS0FBRyxHQUFIO0FBQ0EsTUFBSSxJQUFKO0FBQ0EsU0FBTyxLQUFQO0FBQ0EsU0FBTyxPQUFQO0FBQ0EsT0FBSyxLQUFMOzs7QUFHQSxVQUFRLFFBQVI7QUFDQSxZQUFVLFVBQVY7QUFDQSxRQUFNLE1BQU47QUFDQSxXQUFTLFNBQVQ7QUFDQSxLQUFHLEdBQUg7QUFDQSxTQUFPLE9BQVA7QUFDQSxRQUFNLE1BQU47QUFDQSxr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QUFjLFdBQVcsR0FBWCxDQUhzQztBQUlwRSxXQUFPLHFCQUFxQixHQUFyQixFQUEwQixTQUExQixLQUF3QyxDQUFDLDBCQUEwQixHQUExQixFQUErQixZQUEvQixDQUFELENBSnFCO0dBQTdCLENBL1VBO0NBQTNDOztBQXVWQSxPQUFPLE9BQVAsR0FBaUIsa0JBQWpCOzs7OztBQzFXQTs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsUUFBUSxhQUFSLENBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcclxuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XHJcblxyXG5jb25zdCBncmVldGluZ3MgPSBbXHJcbiAgICB7IHN0YXJ0OiAwLCBlbmQ6IDYsIHRleHQ6ICdZb3VcXCdyZSB1cCBsYXRlLicgfSxcclxuICAgIHsgc3RhcnQ6IDYsIGVuZDogMTIsIHRleHQ6ICdHb29kIG1vcm5pbmcsICVOLicgfSxcclxuICAgIHsgc3RhcnQ6IDEyLCBlbmQ6IDE5LCB0ZXh0OiAnR29vZCBhZnRlcm5vb24sICVOLicgfSxcclxuICAgIHsgc3RhcnQ6IDE5LCBlbmQ6IDI0LCB0ZXh0OiAnR29vZCBldmVuaW5nLCAlTi4nIH1cclxuXTtcclxuXHJcbmNvbnN0IGdlbmVyYXRlR3JlZXRpbmcgPSAobmFtZSkgPT4ge1xyXG4gICAgbGV0IGhvdXIgPSBtb21lbnQoKS5ob3VyKCk7XHJcbiAgICBsZXQgdGV4dCA9IFwiXCI7XHJcbiAgICBncmVldGluZ3MuZm9yRWFjaCgoZ3JlZXRpbmcpID0+IHtcclxuICAgICAgICBpZiAoaG91ciA+PSBncmVldGluZy5zdGFydCAmJiBob3VyIDwgZ3JlZXRpbmcuZW5kKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBncmVldGluZy50ZXh0LnJlcGxhY2UoJyVOJywgbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0ZXh0O1xyXG59O1xyXG5cclxuY29uc3QgZ2VuZXJhdGVTdGF0ZSA9IChuYW1lKSA9PiB7XHJcbiAgICBsZXQgbm93ID0gbW9tZW50KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRpbWU6IG5vdy5mb3JtYXQoJ2g6bW1hJyksXHJcbiAgICAgICAgZGF0ZTogbm93LmZvcm1hdCgnZGRkLCBNTU0gRG8gWVlZWScpLFxyXG4gICAgICAgIGdyZWV0aW5nOiBnZW5lcmF0ZUdyZWV0aW5nKG5hbWUpXHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmVldGluZyBleHRlbmRzIENvbXBvbmVudCB7ICAgICAgXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgKGZ1bmN0aW9uIHJlZnJlc2goKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChyZWZyZXNoLCA2MCAqIDEwMDApO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbmRlciAoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZW5lcmF0ZVN0YXRlKHRoaXMucHJvcHMudXNlci5uYW1lKTtcclxuICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPSdncmVldGluZyc+XHJcbiAgICAgICAgICAgIDxoMT57c3RhdGUudGltZX08L2gxPlxyXG4gICAgICAgICAgICA8aDI+e3N0YXRlLmRhdGV9PC9oMj5cclxuICAgICAgICAgICAgPGgzPntzdGF0ZS5ncmVldGluZ308L2gzPlxyXG4gICAgICAgIDwvZGl2Pik7XHJcbiAgICB9XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBHcmVldGluZyBmcm9tICcuL0dyZWV0aW5nJztcclxuaW1wb3J0IFdlYXRoZXIgZnJvbSAnLi9XZWF0aGVyJztcclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJ2Jyb3dzZXItcmVxdWVzdCcpO1xyXG5jb25zdCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxuXHJcbmNvbnN0IG51bUJhY2tncm91bmRzID0gMjA7XHJcblxyXG5jb25zdCBnZXRUaW1lID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIG1vbWVudCgpLmZvcm1hdCgnaDptbSBhJyk7XHJcbn1cclxuXHJcbmNvbnN0IGdldFJhbmRvbUJhY2tncm91bmQgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBpZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKG51bUJhY2tncm91bmRzKSk7XHJcbiAgICByZXR1cm4gYHVybCgvaW1nL2lkbGUvJHtpZHh9LmpwZylgO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb21lIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yIChwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICB1c2VyOiB7IG5hbWU6ICcnIH0sXHJcbiAgICAgICAgICAgIGZvcmVjYXN0OiBudWxsLFxyXG4gICAgICAgICAgICBpZGxlOiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiBnZXRUaW1lKCksXHJcbiAgICAgICAgICAgIGlkbGVCYWNrZ3JvdW5kOiBnZXRSYW5kb21CYWNrZ3JvdW5kKClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB1cGRhdGUgKCkge1xyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInLCAoZXIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgdXNlcjogSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXF1ZXN0LmdldCgnL3dlYXRoZXInLCAoZXIsIHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgZm9yZWNhc3Q6IEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdvSWRsZSAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXRTdGF0ZSh7IGlkbGU6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbXBvbmVudERpZE1vdW50ICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09ICdLZXlBJykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh7IGlkbGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNlbGYuZ29JZGxlLCA1ICogNjAgKiAxMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIChmdW5jdGlvbiB1cGRhdGVUaW1lKCkge1xyXG4gICAgICAgICAgICBzZWxmLnNldFN0YXRlKHsgdGltZTogZ2V0VGltZSgpIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2V0VGltZW91dCh1cGRhdGVUaW1lLCA2MCAqIDEwMDApO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgKGZ1bmN0aW9uIG5leHRCYWNrZ3JvdW5kKCkge1xyXG4gICAgICAgICAgICBzZWxmLnNldFN0YXRlKHsgaWRsZUJhY2tncm91bmQ6IGdldFJhbmRvbUJhY2tncm91bmQoKSB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQobmV4dEJhY2tncm91bmQsIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZW5kZXIgKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdob21lJz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdpbmZvJz5cclxuICAgICAgICAgICAgICAgICAgICA8R3JlZXRpbmcgdXNlcj17dGhpcy5zdGF0ZS51c2VyfS8+XHJcbiAgICAgICAgICAgICAgICAgICAgPFdlYXRoZXIgZm9yZWNhc3Q9e3RoaXMuc3RhdGUuZm9yZWNhc3R9Lz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2lkbGUnIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGF0ZS5pZGxlID8gMSA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiB0aGlzLnN0YXRlLmlkbGVCYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2lkbGUtdGltZSc+e3RoaXMuc3RhdGUudGltZX08L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VhdGhlciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICByZW5kZXIgKCkge1xyXG4gICAgICAgIGNvbnN0IGZvcmVjYXN0ID0gdGhpcy5wcm9wcy5mb3JlY2FzdDtcclxuICAgICAgICBpZiAoIWZvcmVjYXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9J3dlYXRoZXInPkxvYWRpbmcgd2VhdGhlci4uLjwvZGl2Pik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBoaWdoID0gZm9yZWNhc3QuZGFpbHkuZGF0YVswXS50ZW1wZXJhdHVyZU1heCArICfCsCc7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IGZvcmVjYXN0LmRhaWx5LmRhdGFbMF0udGVtcGVyYXR1cmVNaW4gKyAnwrAnO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J3dlYXRoZXInPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3ZWF0aGVyLWN1cnJlbnRseSc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzc05hbWU9J3dlYXRoZXItaGVhZGVyJz5jdXJyZW50bHk8L2g0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2VhdGhlci1pY29uLWNvbXBvc2l0ZSc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J3dlYXRoZXItaWNvbiAnICsgZm9yZWNhc3QuY3VycmVudGx5Lmljb259Lz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3ZWF0aGVyLWRldGFpbHMnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMT57Zm9yZWNhc3QuY3VycmVudGx5LnRlbXBlcmF0dXJlfTwvaDE+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMj57Zm9yZWNhc3QuY3VycmVudGx5LnN1bW1hcnl9PC9oMj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2VhdGhlci10b2RheSc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzc05hbWU9J3dlYXRoZXItaGVhZGVyJz5mb3JlY2FzdDwvaDQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSd3ZWF0aGVyLWljb24tY29tcG9zaXRlJz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXsnd2VhdGhlci1pY29uICcgKyBmb3JlY2FzdC5kYWlseS5pY29ufS8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nd2VhdGhlci1kZXRhaWxzJz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPSd3ZWF0aGVyLWRhaWx5LWhpZ2gnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aGlnaH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2gxPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9J3dlYXRoZXItZGFpbHktbG93Jz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2xvd31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2gxPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDI+e2ZvcmVjYXN0LmRhaWx5LnN1bW1hcnl9PC9oMj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIid1c2Ugc3RyaWN0JztcclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcblxyXG5pbXBvcnQgSG9tZSBmcm9tICcuL2NvbXBvbmVudHMvSG9tZSc7XHJcblxyXG5SZWFjdERPTS5yZW5kZXIoKFxyXG4gICAgPEhvbWUgLz5cclxuKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdERPTScpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiAoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNvbnRhaW5zTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKlxuICogQHBhcmFtIHs/RE9NTm9kZX0gb3V0ZXJOb2RlIE91dGVyIERPTSBub2RlLlxuICogQHBhcmFtIHs/RE9NTm9kZX0gaW5uZXJOb2RlIElubmVyIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb3V0ZXJOb2RlYCBjb250YWlucyBvciBpcyBgaW5uZXJOb2RlYC5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKF94LCBfeDIpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgdmFyIG91dGVyTm9kZSA9IF94LFxuICAgICAgICBpbm5lck5vZGUgPSBfeDI7XG4gICAgX2FnYWluID0gZmFsc2U7XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgICAgX3ggPSBvdXRlck5vZGU7XG4gICAgICBfeDIgPSBpbm5lck5vZGUucGFyZW50Tm9kZTtcbiAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICBjb250aW51ZSBfZnVuY3Rpb247XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29udGFpbnMpIHtcbiAgICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVBcnJheUZyb21NaXhlZFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b0FycmF5ID0gcmVxdWlyZSgnLi90b0FycmF5Jyk7XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4oXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBjcmVhdGVBcnJheUZyb21NaXhlZChub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eU9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb2N1c05vZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki97XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRNYXJrdXBXcmFwXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHROb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5TWlycm9yXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gICEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU9mXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU9mID0gZnVuY3Rpb24gKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1hcE9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBvbmNlIGZvciBlYWNoIGVudW1lcmFibGUgb3duIHByb3BlcnR5IGluIHRoZVxuICogb2JqZWN0IGFuZCBjb25zdHJ1Y3RzIGEgbmV3IG9iamVjdCBmcm9tIHRoZSByZXN1bHRzLiBUaGUgYGNhbGxiYWNrYCBpc1xuICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqXG4gKiAgLSB0aGUgcHJvcGVydHkgdmFsdWVcbiAqICAtIHRoZSBwcm9wZXJ0eSBuYW1lXG4gKiAgLSB0aGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICpcbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgYWRkZWQgYWZ0ZXIgdGhlIGNhbGwgdG8gYG1hcE9iamVjdGAgd2lsbCBub3QgYmUgdmlzaXRlZFxuICogYnkgYGNhbGxiYWNrYC4gSWYgdGhlIHZhbHVlcyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzIGFyZSBjaGFuZ2VkLCB0aGUgdmFsdWVcbiAqIHBhc3NlZCB0byBgY2FsbGJhY2tgIHdpbGwgYmUgdGhlIHZhbHVlIGF0IHRoZSB0aW1lIGBtYXBPYmplY3RgIHZpc2l0cyB0aGVtLlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBkZWxldGVkIGJlZm9yZSBiZWluZyB2aXNpdGVkIGFyZSBub3QgdmlzaXRlZC5cbiAqXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmplY3RNYXAoKVxuICogQGdyZXAgZnVuY3Rpb24gb2JqTWFwKClcbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBuYW1lKSkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2FsbGJhY2suY2FsbChjb250ZXh0LCBvYmplY3RbbmFtZV0sIG5hbWUsIG9iamVjdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwT2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaGFsbG93RXF1YWxcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICB2YXIgYkhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHkuYmluZChvYmpCKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleXNBW2ldKSB8fCBvYmpBW2tleXNBW2ldXSAhPT0gb2JqQltrZXlzQVtpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRvQXJyYXlcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0IGluXG4gIC8vIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHdhcm5pbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTEuMlxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZSgpIHtcbiAgICB9XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdIHx8IG5ldyBMb2NhbGUoKTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnZXRfc2V0X19zZXQodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX2dldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIHZhciB1bml0O1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh1bml0IGluIHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQodW5pdCwgdW5pdHNbdW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxuICAgIHZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgIHZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG4gICAgdmFyIFdFRUsgPSA3O1xuICAgIHZhciBXRUVLREFZID0gODtcblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKykrTU1NTT8vO1xuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1tNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgaGVyZSFcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3NldF9fZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJCcsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKSQnLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcsICcpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcblxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDA3IGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy90aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICgoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pP1xcZCopPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgdmFyIGlzb1JlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGR1cmF0aW9uLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gZHVyYXRpb24uX21vbnRocztcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XSgpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiArbG9jYWxJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiArbG9jYWxJbnB1dCA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA8ICtsb2NhbElucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgK2xvY2FsSW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSAmJiB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2xvY2FsSW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gK2xvY2FsSW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gKyh0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSArKHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiArdGhpcy5fZCAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkobmV3IERhdGUoTmFOKSkgPT09ICdudWxsJ1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiAnbnVsbCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkX19pc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZ290XCIsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBcInNldFwiLCBkYXRlLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIG1hdGNoV29yZCk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gbG9jYWxfX2NyZWF0ZUxvY2FsKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuICAgIC8vIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAvLyBXZWVrIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgLy8gUXVhcnRlclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgLy8gTW9udGhcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgLy8gV2Vla1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgLy8gRGF5XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAvLyBIb3VyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAvLyBNaW51dGVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgIC8vIFNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgLy8gTWlsbGlzZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgIC8vIE9mZnNldFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTc3OScsIGdldFNldFpvbmUpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfc2V0X19zZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZV9fcHJvdG8gPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG90eXBlX19wcm90by5fY2FsZW5kYXIgICAgICAgPSBkZWZhdWx0Q2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgPSBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2xvbmdEYXRlRm9ybWF0ID0gZGVmYXVsdExvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5faW52YWxpZERhdGUgICAgPSBkZWZhdWx0SW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsICAgICAgICA9IGRlZmF1bHRPcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsUGFyc2UgICA9IGRlZmF1bHRPcmRpbmFsUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fcmVsYXRpdmVUaW1lICAgPSBkZWZhdWx0UmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRocyAgICAgICAgICAgPSBkZWZhdWx0TG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnQgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1JlZ2V4ICAgICAgPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuICAgIC8vIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWsgPSBkZWZhdWx0TG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzICAgICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pbiAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0ID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21lcmlkaWVtUGFyc2UgPSBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fZ2V0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgY291bnQsIHNldHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzJywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0JywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3QgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTEuMic7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRocztcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSB2YWxpZF9fY3JlYXRlSW52YWxpZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcblxuICAgIHZhciBfbW9tZW50ID0gdXRpbHNfaG9va3NfX2hvb2tzO1xuXG4gICAgcmV0dXJuIF9tb21lbnQ7XG5cbn0pKTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG5cbnZhciBNaXhpbiA9IHtcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgIGZvY3VzTm9kZShmaW5kRE9NTm9kZSh0aGlzKSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIE1peGluOiBNaXhpbixcblxuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKCcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZScpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGU6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0OlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIGZhbGxiYWNrIG9iamVjdCwgaWYgYW55LlxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQodG9wTGV2ZWxUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQgfHwgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoQ1NTUHJvcGVydHlPcGVyYXRpb25zLCAnQ1NTUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclN0eWxlczogJ3NldFZhbHVlRm9yU3R5bGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDYWxsYmFja1F1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xufVxuXG5hc3NpZ24oQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWU6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCBlbnF1ZXVlZCBjYWxsYmFja3MgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgaXMgaW52b2tlZCBhZnRlclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnlBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrUXVldWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNoYW5nZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2hhbmdlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSwgdG9wTGV2ZWxUeXBlcy50b3BDbGljaywgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SUQsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJRCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SUQgPSB0YXJnZXRJRDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxuICBkZWxldGUgYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcblxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wSW5wdXQpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SUQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuXG4gICAgdmFyIGdldFRhcmdldElERnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SURGdW5jKSB7XG4gICAgICB2YXIgdGFyZ2V0SUQgPSBnZXRUYXJnZXRJREZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCB0YXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDbGllbnRSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuZXh0UmVhY3RSb290SW5kZXggPSAwO1xuXG52YXIgQ2xpZW50UmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5leHRSZWFjdFJvb3RJbmRleCsrO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAvLyBCeSBleHBsb2l0aW5nIGFycmF5cyByZXR1cm5pbmcgYHVuZGVmaW5lZGAgZm9yIGFuIHVuZGVmaW5lZCBpbmRleCwgd2UgY2FuXG4gIC8vIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIEhvd2V2ZXIsIHVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbFxuICAvLyBicm93c2VycyBzbyB3ZSBtdXN0IHJlcGxhY2UgaXQgd2l0aCBgbnVsbGAuXG5cbiAgLy8gZml4IHJlbmRlciBvcmRlciBlcnJvciBpbiBzYWZhcmlcbiAgLy8gSUU4IHdpbGwgdGhyb3cgZXJyb3Igd2hlbiBpbmRleCBvdXQgb2YgbGlzdCBzaXplLlxuICB2YXIgYmVmb3JlQ2hpbGQgPSBpbmRleCA+PSBwYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbnVsbCA6IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5pdGVtKGluZGV4KTtcblxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIGJlZm9yZUNoaWxkKTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHVwZGF0ZVRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwTGlzdCkge1xuICAgIHZhciB1cGRhdGU7XG4gICAgLy8gTWFwcGluZyBmcm9tIHBhcmVudCBJRHMgdG8gaW5pdGlhbCBjaGlsZCBvcmRlcmluZ3MuXG4gICAgdmFyIGluaXRpYWxDaGlsZHJlbiA9IG51bGw7XG4gICAgLy8gTGlzdCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgYmUgbW92ZWQgb3IgcmVtb3ZlZC5cbiAgICB2YXIgdXBkYXRlZENoaWxkcmVuID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1tpXTtcbiAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyB8fCB1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRJbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgIHZhciB1cGRhdGVkQ2hpbGQgPSB1cGRhdGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzW3VwZGF0ZWRJbmRleF07XG4gICAgICAgIHZhciBwYXJlbnRJRCA9IHVwZGF0ZS5wYXJlbnRJRDtcblxuICAgICAgICAhdXBkYXRlZENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NVcGRhdGVzKCk6IFVuYWJsZSB0byBmaW5kIGNoaWxkICVzIG9mIGVsZW1lbnQuIFRoaXMgJyArICdwcm9iYWJseSBtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlICcgKyAnYnJvd3NlciksIHVzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCAnICsgJ25lc3RpbmcgdGFncyBsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgJyArICdpbiBhbiA8c3ZnPiBwYXJlbnQuIFRyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCAnICsgJ3dpdGggUmVhY3QgSUQgYCVzYC4nLCB1cGRhdGVkSW5kZXgsIHBhcmVudElEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaW5pdGlhbENoaWxkcmVuID0gaW5pdGlhbENoaWxkcmVuIHx8IHt9O1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdID0gaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSB8fCBbXTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXVt1cGRhdGVkSW5kZXhdID0gdXBkYXRlZENoaWxkO1xuXG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbiA9IHVwZGF0ZWRDaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgdXBkYXRlZENoaWxkcmVuLnB1c2godXBkYXRlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZWRNYXJrdXA7XG4gICAgLy8gbWFya3VwTGlzdCBpcyBlaXRoZXIgYSBsaXN0IG9mIG1hcmt1cCBvciBqdXN0IGEgbGlzdCBvZiBlbGVtZW50c1xuICAgIGlmIChtYXJrdXBMaXN0Lmxlbmd0aCAmJiB0eXBlb2YgbWFya3VwTGlzdFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVuZGVyTWFya3VwKG1hcmt1cExpc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZE1hcmt1cCA9IG1hcmt1cExpc3Q7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHVwZGF0ZWQgY2hpbGRyZW4gZmlyc3Qgc28gdGhhdCBgdG9JbmRleGAgaXMgY29uc2lzdGVudC5cbiAgICBpZiAodXBkYXRlZENoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVwZGF0ZWRDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW5bal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh1cGRhdGVkQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQOlxuICAgICAgICAgIGluc2VydENoaWxkQXQodXBkYXRlLnBhcmVudE5vZGUsIHJlbmRlcmVkTWFya3VwW3VwZGF0ZS5tYXJrdXBJbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIGluc2VydENoaWxkQXQodXBkYXRlLnBhcmVudE5vZGUsIGluaXRpYWxDaGlsZHJlblt1cGRhdGUucGFyZW50SURdW3VwZGF0ZS5mcm9tSW5kZXhdLCB1cGRhdGUudG9JbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUDpcbiAgICAgICAgICBzZXRJbm5lckhUTUwodXBkYXRlLnBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQ6XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQodXBkYXRlLnBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERTpcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQgYnkgdGhlIGZvci1sb29wIGFib3ZlLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoRE9NQ2hpbGRyZW5PcGVyYXRpb25zLCAnRE9NQ2hpbGRyZW5PcGVyYXRpb25zJywge1xuICB1cGRhdGVUZXh0Q29udGVudDogJ3VwZGF0ZVRleHRDb250ZW50J1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfQVRUUklCVVRFOiAweDEsXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDIsXG4gIEhBU19TSURFX0VGRkVDVFM6IDB4NCxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4OCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4MTAsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDIwIHwgMHgxMCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyArICdcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSAnICsgJ2luamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlICcgKyAnaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VBdHRyaWJ1dGU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFKSxcbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzU2lkZUVmZmVjdHM6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUyksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcblxuICAgICAgISghcHJvcGVydHlJbmZvLm11c3RVc2VBdHRyaWJ1dGUgfHwgIXByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBDYW5ub3QgcmVxdWlyZSB1c2luZyBib3RoIGF0dHJpYnV0ZSBhbmQgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSB8fCAhcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogUHJvcGVydGllcyB0aGF0IGhhdmUgc2lkZSBlZmZlY3RzIG11c3QgdXNlIHByb3BlcnR5OiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciAnICsgJ251bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG52YXIgZGVmYXVsdFZhbHVlQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlQXR0cmlidXRlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgdXNpbmcgYCpBdHRyaWJ1dGUoKWAuXG4gICAqICAgKFRoaXMgaW5jbHVkZXMgYW55dGhpbmcgdGhhdCBmYWlscyBgPHByb3BOYW1lPiBpbiA8ZWxlbWVudD5gLilcbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNTaWRlRWZmZWN0czpcbiAgICogICBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogICByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIG9yIHRleHQgc2VsZWN0aW9uIGNoYW5nZXMuIElmIHRydWUsIHdlIHJlYWQgZnJvbVxuICAgKiAgIHRoZSBET00gYmVmb3JlIHVwZGF0aW5nIHRvIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXNcbiAgICogICBjaGFuZ2VkLlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBET00gcHJvcGVydHkgKGkuZS4sIG5vdCBhblxuICAgKiBhdHRyaWJ1dGUpLiBNb3N0IGRlZmF1bHQgdmFsdWVzIGFyZSAnJyBvciBmYWxzZSwgYnV0IG5vdCBhbGwuIFdvcnNlIHlldCxcbiAgICogc29tZSAoaW4gcGFydGljdWxhciwgYHR5cGVgKSB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LlxuICAgKlxuICAgKiBUT0RPOiBJcyBpdCBiZXR0ZXIgdG8gZ3JhYiBhbGwgdGhlIHBvc3NpYmxlIHByb3BlcnRpZXMgd2hlbiBjcmVhdGluZyBhblxuICAgKiBlbGVtZW50IHRvIGF2b2lkIGhhdmluZyB0byBjcmVhdGUgdGhlIHNhbWUgZWxlbWVudCB0d2ljZT9cbiAgICovXG4gIGdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZU5hbWUsIHByb3ApIHtcbiAgICB2YXIgbm9kZURlZmF1bHRzID0gZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdO1xuICAgIHZhciB0ZXN0RWxlbWVudDtcbiAgICBpZiAoIW5vZGVEZWZhdWx0cykge1xuICAgICAgZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdID0gbm9kZURlZmF1bHRzID0ge307XG4gICAgfVxuICAgIGlmICghKHByb3AgaW4gbm9kZURlZmF1bHRzKSkge1xuICAgICAgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgIG5vZGVEZWZhdWx0c1twcm9wXSA9IHRlc3RFbGVtZW50W3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZURlZmF1bHRzW3Byb3BdO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IC9eW2EtekEtWl9dW1xcd1xcLlxcLV0qJC87XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB3YXJuVW5rbm93blByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIC8vIEZvciBub3csIG9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBzdWdnZXN0ZWQgY29ycmVjdGlvbi4gVGhpcyBwcmV2ZW50c1xuICAgIC8vIGxvZ2dpbmcgdG9vIG11Y2ggd2hlbiB1c2luZyB0cmFuc2ZlclByb3BzVG8uXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc3RhbmRhcmROYW1lID09IG51bGwsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIHN0YW5kYXJkTmFtZSkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gTXVzdCBleHBsaWNpdGx5IGNhc3QgdmFsdWVzIGZvciBIQVNfU0lERV9FRkZFQ1RTLXByb3BlcnRpZXMgdG8gdGhlXG4gICAgICAgIC8vIHByb3BlcnR5IHR5cGUgYmVmb3JlIGNvbXBhcmluZzsgb25seSBgdmFsdWVgIGRvZXMgYW5kIGlzIHN0cmluZy5cbiAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMgfHwgJycgKyBub2RlW3Byb3BOYW1lXSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gRE9NUHJvcGVydHkuZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHkobm9kZS5ub2RlTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKERPTVByb3BlcnR5T3BlcmF0aW9ucywgJ0RPTVByb3BlcnR5T3BlcmF0aW9ucycsIHtcbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogJ3NldFZhbHVlRm9yUHJvcGVydHknLFxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogJ3NldFZhbHVlRm9yQXR0cmlidXRlJyxcbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogJ2RlbGV0ZVZhbHVlRm9yUHJvcGVydHknXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPUEVOX1RBR19OQU1FX0VYUCA9IC9eKDxbXiBcXC8+XSspLztcbnZhciBSRVNVTFRfSU5ERVhfQVRUUiA9ICdkYXRhLWRhbmdlci1pbmRleCc7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgZnJvbSBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogTk9URTogRXh0cmFjdGluZyB0aGUgYG5vZGVOYW1lYCBkb2VzIG5vdCByZXF1aXJlIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoXG4gKiBiZWNhdXNlIHdlIG1ha2UgYXNzdW1wdGlvbnMgYWJvdXQgUmVhY3QtZ2VuZXJhdGVkIG1hcmt1cCAoaS5lLiB0aGVyZSBhcmUgbm9cbiAqIHNwYWNlcyBzdXJyb3VuZGluZyB0aGUgb3BlbmluZyB0YWcgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2V4dHJhY3Qtbm9kZW5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHJldHVybiBtYXJrdXAuc3Vic3RyaW5nKDEsIG1hcmt1cC5pbmRleE9mKCcgJykpO1xufVxuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIG1hcmt1cCBpbnRvIGFuIGFycmF5IG9mIG5vZGVzLiBUaGUgbWFya3VwIGlzIGV4cGVjdGVkIHRvIHJlbmRlclxuICAgKiBpbnRvIGEgbGlzdCBvZiByb290IG5vZGVzLiBBbHNvLCB0aGUgbGVuZ3RoIG9mIGByZXN1bHRMaXN0YCBhbmRcbiAgICogYG1hcmt1cExpc3RgIHNob3VsZCBiZSB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MgdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50Pn0gTGlzdCBvZiByZW5kZXJlZCBub2Rlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlbmRlck1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cExpc3QpIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyICcgKyAndGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSAnICsgJ2JlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBub2RlTmFtZTtcbiAgICB2YXIgbWFya3VwQnlOb2RlTmFtZSA9IHt9O1xuICAgIC8vIEdyb3VwIG1hcmt1cCBieSBgbm9kZU5hbWVgIGlmIGEgd3JhcCBpcyBuZWNlc3NhcnksIGVsc2UgYnkgJyonLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3VwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgIW1hcmt1cExpc3RbaV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXBMaXN0W2ldKTtcbiAgICAgIG5vZGVOYW1lID0gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkgPyBub2RlTmFtZSA6ICcqJztcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gfHwgW107XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXVtpXSA9IG1hcmt1cExpc3RbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRMaXN0ID0gW107XG4gICAgdmFyIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPSAwO1xuICAgIGZvciAobm9kZU5hbWUgaW4gbWFya3VwQnlOb2RlTmFtZSkge1xuICAgICAgaWYgKCFtYXJrdXBCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXJrdXBMaXN0QnlOb2RlTmFtZSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdO1xuXG4gICAgICAvLyBUaGlzIGZvci1pbiBsb29wIHNraXBzIHRoZSBob2xlcyBvZiB0aGUgc3BhcnNlIGFycmF5LiBUaGUgb3JkZXIgb2ZcbiAgICAgIC8vIGl0ZXJhdGlvbiBzaG91bGQgZm9sbG93IHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LCB3aGljaCBoYXBwZW5zIHRvIG1hdGNoXG4gICAgICAvLyBudW1lcmljYWwgaW5kZXggb3JkZXIsIGJ1dCB3ZSBkb24ndCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgcmVzdWx0SW5kZXg7XG4gICAgICBmb3IgKHJlc3VsdEluZGV4IGluIG1hcmt1cExpc3RCeU5vZGVOYW1lKSB7XG4gICAgICAgIGlmIChtYXJrdXBMaXN0QnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkpIHtcbiAgICAgICAgICB2YXIgbWFya3VwID0gbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdO1xuXG4gICAgICAgICAgLy8gUHVzaCB0aGUgcmVxdWVzdGVkIG1hcmt1cCB3aXRoIGFuIGFkZGl0aW9uYWwgUkVTVUxUX0lOREVYX0FUVFJcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUuICBJZiB0aGUgbWFya3VwIGRvZXMgbm90IHN0YXJ0IHdpdGggYSA8IGNoYXJhY3RlciwgaXRcbiAgICAgICAgICAvLyB3aWxsIGJlIGRpc2NhcmRlZCBiZWxvdyAod2l0aCBhbiBhcHByb3ByaWF0ZSBjb25zb2xlLmVycm9yKS5cbiAgICAgICAgICBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF0gPSBtYXJrdXAucmVwbGFjZShPUEVOX1RBR19OQU1FX0VYUCxcbiAgICAgICAgICAvLyBUaGlzIGluZGV4IHdpbGwgYmUgcGFyc2VkIGJhY2sgb3V0IGJlbG93LlxuICAgICAgICAgICckMSAnICsgUkVTVUxUX0lOREVYX0FUVFIgKyAnPVwiJyArIHJlc3VsdEluZGV4ICsgJ1wiICcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBlYWNoIGdyb3VwIG9mIG1hcmt1cCB3aXRoIHNpbWlsYXIgd3JhcHBpbmcgYG5vZGVOYW1lYC5cbiAgICAgIHZhciByZW5kZXJOb2RlcyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXBMaXN0QnlOb2RlTmFtZS5qb2luKCcnKSwgZW1wdHlGdW5jdGlvbiAvLyBEbyBub3RoaW5nIHNwZWNpYWwgd2l0aCA8c2NyaXB0PiB0YWdzLlxuICAgICAgKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZW5kZXJOb2Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IHJlbmRlck5vZGVzW2pdO1xuICAgICAgICBpZiAocmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUgJiYgcmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpKSB7XG5cbiAgICAgICAgICByZXN1bHRJbmRleCA9ICtyZW5kZXJOb2RlLmdldEF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG4gICAgICAgICAgcmVuZGVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuXG4gICAgICAgICAgISFyZXN1bHRMaXN0Lmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IEFzc2lnbmluZyB0byBhbiBhbHJlYWR5LW9jY3VwaWVkIHJlc3VsdCBpbmRleC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICByZXN1bHRMaXN0W3Jlc3VsdEluZGV4XSA9IHJlbmRlck5vZGU7XG5cbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBtYXRjaCByZXN1bHRMaXN0Lmxlbmd0aCBhbmQgbWFya3VwTGlzdC5sZW5ndGggd2hlblxuICAgICAgICAgIC8vIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYW5nZXI6IERpc2NhcmRpbmcgdW5leHBlY3RlZCBub2RlOicsIHJlbmRlck5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWx0aG91Z2ggcmVzdWx0TGlzdCB3YXMgcG9wdWxhdGVkIG91dCBvZiBvcmRlciwgaXQgc2hvdWxkIG5vdyBiZSBhIGRlbnNlXG4gICAgLy8gYXJyYXkuXG4gICAgIShyZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID09PSByZXN1bHRMaXN0Lmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBEaWQgbm90IGFzc2lnbiB0byBldmVyeSBpbmRleCBvZiByZXN1bHRMaXN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICEocmVzdWx0TGlzdC5sZW5ndGggPT09IG1hcmt1cExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IEV4cGVjdGVkIG1hcmt1cCB0byByZW5kZXIgJXMgbm9kZXMsIGJ1dCByZW5kZXJlZCAlcy4nLCBtYXJrdXBMaXN0Lmxlbmd0aCwgcmVzdWx0TGlzdC5sZW5ndGgpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiByZXN1bHRMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhICcgKyAnd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgJyArICdnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICsgJ1JlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEob2xkQ2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgJyArICc8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlICcgKyAnYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2UgJyArICdzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDaGlsZCA9IG1hcmt1cDtcbiAgICB9XG4gICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFtrZXlPZih7IFJlc3BvbmRlckV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNpbXBsZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFRhcEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEVudGVyTGVhdmVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBDaGFuZ2VFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTZWxlY3RFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBudWxsIH0pXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG52YXIgZ2V0Rmlyc3RSZWFjdERPTSA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VFbnRlcjogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUxlYXZlOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9XG59O1xuXG52YXIgZXh0cmFjdGVkRXZlbnRzID0gW251bGwsIG51bGxdO1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAodG9wTGV2ZWxUYXJnZXQud2luZG93ID09PSB0b3BMZXZlbFRhcmdldCkge1xuICAgICAgLy8gYHRvcExldmVsVGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSB0b3BMZXZlbFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IHRvcExldmVsVGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICB2YXIgZnJvbUlEID0gJyc7XG4gICAgdmFyIHRvSUQgPSAnJztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICBmcm9tSUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgICAgdG8gPSBnZXRGaXJzdFJlYWN0RE9NKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50KTtcbiAgICAgIGlmICh0bykge1xuICAgICAgICB0b0lEID0gUmVhY3RNb3VudC5nZXRJRCh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9IHdpbjtcbiAgICAgIH1cbiAgICAgIHRvID0gdG8gfHwgd2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tID0gd2luO1xuICAgICAgdG8gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIHRvSUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tSUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0bztcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG9JRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpO1xuXG4gICAgZXh0cmFjdGVkRXZlbnRzWzBdID0gbGVhdmU7XG4gICAgZXh0cmFjdGVkRXZlbnRzWzFdID0gZW50ZXI7XG5cbiAgICByZXR1cm4gZXh0cmFjdGVkRXZlbnRzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDYW5QbGF5OiBudWxsLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgdG9wQ2hhbmdlOiBudWxsLFxuICB0b3BDbGljazogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiBudWxsLFxuICB0b3BDb250ZXh0TWVudTogbnVsbCxcbiAgdG9wQ29weTogbnVsbCxcbiAgdG9wQ3V0OiBudWxsLFxuICB0b3BEb3VibGVDbGljazogbnVsbCxcbiAgdG9wRHJhZzogbnVsbCxcbiAgdG9wRHJhZ0VuZDogbnVsbCxcbiAgdG9wRHJhZ0VudGVyOiBudWxsLFxuICB0b3BEcmFnRXhpdDogbnVsbCxcbiAgdG9wRHJhZ0xlYXZlOiBudWxsLFxuICB0b3BEcmFnT3ZlcjogbnVsbCxcbiAgdG9wRHJhZ1N0YXJ0OiBudWxsLFxuICB0b3BEcm9wOiBudWxsLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wRW1wdGllZDogbnVsbCxcbiAgdG9wRW5jcnlwdGVkOiBudWxsLFxuICB0b3BFbmRlZDogbnVsbCxcbiAgdG9wRXJyb3I6IG51bGwsXG4gIHRvcEZvY3VzOiBudWxsLFxuICB0b3BJbnB1dDogbnVsbCxcbiAgdG9wS2V5RG93bjogbnVsbCxcbiAgdG9wS2V5UHJlc3M6IG51bGwsXG4gIHRvcEtleVVwOiBudWxsLFxuICB0b3BMb2FkOiBudWxsLFxuICB0b3BMb2FkZWREYXRhOiBudWxsLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgdG9wTG9hZFN0YXJ0OiBudWxsLFxuICB0b3BNb3VzZURvd246IG51bGwsXG4gIHRvcE1vdXNlTW92ZTogbnVsbCxcbiAgdG9wTW91c2VPdXQ6IG51bGwsXG4gIHRvcE1vdXNlT3ZlcjogbnVsbCxcbiAgdG9wTW91c2VVcDogbnVsbCxcbiAgdG9wUGFzdGU6IG51bGwsXG4gIHRvcFBhdXNlOiBudWxsLFxuICB0b3BQbGF5OiBudWxsLFxuICB0b3BQbGF5aW5nOiBudWxsLFxuICB0b3BQcm9ncmVzczogbnVsbCxcbiAgdG9wUmF0ZUNoYW5nZTogbnVsbCxcbiAgdG9wUmVzZXQ6IG51bGwsXG4gIHRvcFNjcm9sbDogbnVsbCxcbiAgdG9wU2Vla2VkOiBudWxsLFxuICB0b3BTZWVraW5nOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN0YWxsZWQ6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wU3VzcGVuZDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUaW1lVXBkYXRlOiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBudWxsLFxuICB0b3BXYWl0aW5nOiBudWxsLFxuICB0b3BXaGVlbDogbnVsbFxufSk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHtcbiAgdG9wTGV2ZWxUeXBlczogdG9wTGV2ZWxUeXBlcyxcbiAgUHJvcGFnYXRpb25QaGFzZXM6IFByb3BhZ2F0aW9uUGhhc2VzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50Q29uc3RhbnRzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiAtIGBJbnN0YW5jZUhhbmRsZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgcGVyZm9ybXMgbG9naWNhbCB0cmF2ZXJzYWxzIG9mIERPTVxuICogICBoaWVyYXJjaHkgZ2l2ZW4gaWRzIG9mIHRoZSBsb2dpY2FsIERPTSBlbGVtZW50cyBpbnZvbHZlZC5cbiAqL1xudmFyIEluc3RhbmNlSGFuZGxlID0gbnVsbDtcblxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpIHtcbiAgdmFyIHZhbGlkID0gSW5zdGFuY2VIYW5kbGUgJiYgSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VUd29QaGFzZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZUVudGVyTGVhdmU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHZhbGlkLCAnSW5zdGFuY2VIYW5kbGUgbm90IGluamVjdGVkIGJlZm9yZSB1c2UhJykgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuXG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgaW5qZWN0aW9uOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gSW5qZWN0ZWRNb3VudFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RNb3VudDogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0TW91bnQsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKEluamVjdGVkSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIEluc3RhbmNlSGFuZGxlID0gSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJbnN0YW5jZUhhbmRsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdYC4gSXMgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdID0gbGlzdGVuZXI7XG5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyAnICsgJ2FuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICAgIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluICcgKyAndGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhUGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgJyArICdtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ2V2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhRXZlbnRQbHVnaW5PcmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArICdvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBFdmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zICcgKyAndXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGZvciAodmFyIHBoYXNlIGluIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAoIWRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW5Nb2R1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgTW91bnRgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgZG9tIElEcyBhbmRcbiAqICAgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGluamVjdGlvbiA9IHtcbiAgTW91bnQ6IG51bGwsXG4gIGluamVjdE1vdW50OiBmdW5jdGlvbiAoSW5qZWN0ZWRNb3VudCkge1xuICAgIGluamVjdGlvbi5Nb3VudCA9IEluamVjdGVkTW91bnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkTW91bnQgJiYgSW5qZWN0ZWRNb3VudC5nZXROb2RlICYmIEluamVjdGVkTW91bnQuZ2V0SUQsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCguLi4pOiBJbmplY3RlZCBNb3VudCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGUgb3IgZ2V0SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24gfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ7XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBpZHNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJRHMpO1xuICAgIHZhciBJRHNMZW4gPSBpZHNJc0FyciA/IGRpc3BhdGNoSURzLmxlbmd0aCA6IGRpc3BhdGNoSURzID8gMSA6IDA7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlkc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBJRHNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tSUQgRE9NIGlkIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShkb21JRCk7XG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoKHR5cGUsIGxpc3RlbmVyLCBldmVudCwgZG9tSUQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaElEc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaElEcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJRHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaElEc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSURzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSURzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCwgZGlzcGF0Y2hJRCkgOiBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0Tm9kZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGlkKTtcbiAgfSxcbiAgZ2V0SUQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXRJRChub2RlKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFByb3BhZ2F0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaWQsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGRvbUlELCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRvbUlELCAnRGlzcGF0Y2hpbmcgaWQgbXVzdCBub3QgYmUgbnVsbCcpIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBwaGFzZSA9IHVwd2FyZHMgPyBQcm9wYWdhdGlvblBoYXNlcy5idWJibGVkIDogUHJvcGFnYXRpb25QaGFzZXMuY2FwdHVyZWQ7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShkb21JRCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBkb21JRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZShldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGlkLCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaElEcywgaWQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKSB7XG4gIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tSUQsIHRvSUQsIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmFzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydFRleHQgPSBudWxsO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRleHQgb2YgaW5wdXQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiB0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBkaWZmZXJpbmcgc3Vic3RyaW5nIGJldHdlZW4gdGhlIGluaXRpYWxseSBzdG9yZWRcbiAgICogdGV4dCBjb250ZW50IGFuZCB0aGUgY3VycmVudCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZhbGxiYWNrVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB0aGlzLl9zdGFydFRleHQ7XG4gICAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgSFRNTERPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU0lERV9FRkZFQ1RTID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFM7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgaGFzU1ZHO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgaW1wbGVtZW50YXRpb24gPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbjtcbiAgaGFzU1ZHID0gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlJywgJzEuMScpO1xufVxuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oZGF0YXxhcmlhKS1bYS16X11bYS16XFxkXy5cXC1dKiQvKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IG51bGwsXG4gICAgYWNjZXB0Q2hhcnNldDogbnVsbCxcbiAgICBhY2Nlc3NLZXk6IG51bGwsXG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGFsbG93RnVsbFNjcmVlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBhbHQ6IG51bGwsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogbnVsbCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IG51bGwsXG4gICAgY2VsbFNwYWNpbmc6IG51bGwsXG4gICAgY2hhclNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoYWxsZW5nZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2xhc3NJRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIFRvIHNldCBjbGFzc05hbWUgb24gU1ZHIGVsZW1lbnRzLCBpdCdzIG5lY2Vzc2FyeSB0byB1c2UgLnNldEF0dHJpYnV0ZTtcbiAgICAvLyB0aGlzIHdvcmtzIG9uIEhUTUwgZWxlbWVudHMgdG9vIGluIGFsbCBicm93c2VycyBleGNlcHQgSUU4LiBDb252ZW5pZW50bHksXG4gICAgLy8gSUU4IGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW5kIHNvIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSBhdHRyaWJ1dGUgaW5cbiAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgU1ZHIGFuZCB0aGUgcHJvcGVydHkgaW4gYnJvd3NlcnMgdGhhdCBkb24ndCxcbiAgICAvLyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgSFRNTCBvciBTVkcuXG4gICAgY2xhc3NOYW1lOiBoYXNTVkcgPyBNVVNUX1VTRV9BVFRSSUJVVEUgOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBjb2xzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgY29udGVudEVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnRleHRNZW51OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY29udHJvbHM6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiBudWxsLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGRhdGE6IG51bGwsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogbnVsbCxcbiAgICBkaXNhYmxlZDogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBudWxsLFxuICAgIGVuY1R5cGU6IG51bGwsXG4gICAgZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1BY3Rpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtRW5jVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1NZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZyYW1lQm9yZGVyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICBoZWlnaHQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoaWRkZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IG51bGwsXG4gICAgaHJlZjogbnVsbCxcbiAgICBocmVmTGFuZzogbnVsbCxcbiAgICBodG1sRm9yOiBudWxsLFxuICAgIGh0dHBFcXVpdjogbnVsbCxcbiAgICBpY29uOiBudWxsLFxuICAgIGlkOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBpbnB1dE1vZGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbnRlZ3JpdHk6IG51bGwsXG4gICAgaXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBrZXlQYXJhbXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBrZXlUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAga2luZDogbnVsbCxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBsb29wOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogbnVsbCxcbiAgICBtYW5pZmVzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmdpbkhlaWdodDogbnVsbCxcbiAgICBtYXJnaW5XaWR0aDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWVkaWE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYUdyb3VwOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgbWluTGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogbnVsbCxcbiAgICBub25jZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IG51bGwsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByYWRpb0dyb3VwOiBudWxsLFxuICAgIHJlYWRPbmx5OiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlbDogbnVsbCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByb3dzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBudWxsLFxuICAgIHNhbmRib3g6IG51bGwsXG4gICAgc2NvcGU6IG51bGwsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IG51bGwsXG4gICAgc2VhbWxlc3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzcmNMYW5nOiBudWxsLFxuICAgIHNyY1NldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHN1bW1hcnk6IG51bGwsXG4gICAgdGFiSW5kZXg6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHR5cGU6IG51bGwsXG4gICAgdXNlTWFwOiBudWxsLFxuICAgIHZhbHVlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19TSURFX0VGRkVDVFMsXG4gICAgd2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB3bW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdyYXA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSREZhIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhYm91dDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGRhdGF0eXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaW5saXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlZml4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByZXNvdXJjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgICd0eXBlb2YnOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdm9jYWI6IE1VU1RfVVNFX0FUVFJJQlVURSxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGF1dG9Db3JyZWN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IG51bGwsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiBudWxsLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaXRlbVNjb3BlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtUmVmOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiBudWxsLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IE1VU1RfVVNFX0FUVFJJQlVURVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHtcbiAgICBhdXRvQ29tcGxldGU6ICdhdXRvY29tcGxldGUnLFxuICAgIGF1dG9Gb2N1czogJ2F1dG9mb2N1cycsXG4gICAgYXV0b1BsYXk6ICdhdXRvcGxheScsXG4gICAgYXV0b1NhdmU6ICdhdXRvc2F2ZScsXG4gICAgLy8gYGVuY29kaW5nYCBpcyBlcXVpdmFsZW50IHRvIGBlbmN0eXBlYCwgSUU4IGxhY2tzIGFuIGBlbmN0eXBlYCBzZXR0ZXIuXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNkb20tZnMtZW5jb2RpbmdcbiAgICBlbmNUeXBlOiAnZW5jb2RpbmcnLFxuICAgIGhyZWZMYW5nOiAnaHJlZmxhbmcnLFxuICAgIHJhZGlvR3JvdXA6ICdyYWRpb2dyb3VwJyxcbiAgICBzcGVsbENoZWNrOiAnc3BlbGxjaGVjaycsXG4gICAgc3JjRG9jOiAnc3JjZG9jJyxcbiAgICBzcmNTZXQ6ICdzcmNzZXQnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMaW5rZWRWYWx1ZVV0aWxzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgJyArICdjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgJyArICd0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiAnICsgJ0lmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvICcgKyAndXNlIGNoZWNrZWRMaW5rJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0UHJvcFR5cGVzLmZ1bmNcbn07XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAqL1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIG93bmVyKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgdGFnTmFtZSwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZXMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiB0YXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBuZXh0SW5kZXggPSAxOyBuZXh0SW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBPYmplY3QobmV4dFNvdXJjZSk7XG5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NvcnMgbm9yIHByb3hpZXMuIFRoZXJlZm9yZSB0aGlzXG4gICAgLy8gY29weSBjYW5ub3QgdGhyb3cuIElmIHdlIGV2ZXIgc3VwcG9ydGVkIHRoaXMgdGhlbiB3ZSBtdXN0IGhhbmRsZVxuICAgIC8vIGV4Y2VwdGlvbnMgYW5kIHNpZGUtZWZmZWN0cy4gV2UgZG9uJ3Qgc3VwcG9ydCBzeW1ib2xzIHNvIHRoZXkgd29uJ3RcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZC5cblxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUG9vbGVkQ2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlcixcbiAgZml2ZUFyZ3VtZW50UG9vbGVyOiBmaXZlQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET00gPSByZXF1aXJlKCcuL1JlYWN0RE9NJyk7XG52YXIgUmVhY3RET01TZXJ2ZXIgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VydmVyJyk7XG52YXIgUmVhY3RJc29tb3JwaGljID0gcmVxdWlyZSgnLi9SZWFjdElzb21vcnBoaWMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcblxuLy8gYHZlcnNpb25gIHdpbGwgYmUgYWRkZWQgaGVyZSBieSBSZWFjdElzb21vcnBoaWMuXG52YXIgUmVhY3QgPSB7fTtcblxuYXNzaWduKFJlYWN0LCBSZWFjdElzb21vcnBoaWMpO1xuXG5hc3NpZ24oUmVhY3QsIHtcbiAgLy8gUmVhY3RET01cbiAgZmluZERPTU5vZGU6IGRlcHJlY2F0ZWQoJ2ZpbmRET01Ob2RlJywgJ1JlYWN0RE9NJywgJ3JlYWN0LWRvbScsIFJlYWN0RE9NLCBSZWFjdERPTS5maW5kRE9NTm9kZSksXG4gIHJlbmRlcjogZGVwcmVjYXRlZCgncmVuZGVyJywgJ1JlYWN0RE9NJywgJ3JlYWN0LWRvbScsIFJlYWN0RE9NLCBSZWFjdERPTS5yZW5kZXIpLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBkZXByZWNhdGVkKCd1bm1vdW50Q29tcG9uZW50QXROb2RlJywgJ1JlYWN0RE9NJywgJ3JlYWN0LWRvbScsIFJlYWN0RE9NLCBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKSxcblxuICAvLyBSZWFjdERPTVNlcnZlclxuICByZW5kZXJUb1N0cmluZzogZGVwcmVjYXRlZCgncmVuZGVyVG9TdHJpbmcnLCAnUmVhY3RET01TZXJ2ZXInLCAncmVhY3QtZG9tL3NlcnZlcicsIFJlYWN0RE9NU2VydmVyLCBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyksXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiBkZXByZWNhdGVkKCdyZW5kZXJUb1N0YXRpY01hcmt1cCcsICdSZWFjdERPTVNlcnZlcicsICdyZWFjdC1kb20vc2VydmVyJywgUmVhY3RET01TZXJ2ZXIsIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKVxufSk7XG5cblJlYWN0Ll9fU0VDUkVUX0RPTV9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RET007XG5SZWFjdC5fX1NFQ1JFVF9ET01fU0VSVkVSX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdERPTVNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FybktleSA9ICdfZ2V0RE9NTm9kZURpZFdhcm4nO1xuXG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICogQGZpbmFsXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldERPTU5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzLmNvbnN0cnVjdG9yW2RpZFdhcm5LZXldLCAnJXMuZ2V0RE9NTm9kZSguLi4pIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJyArICdSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSkgaW5zdGVhZC4nLCBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5nZXROYW1lKCkgfHwgdGhpcy50YWdOYW1lIHx8ICdVbmtub3duJykgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IGFzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luSHViLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5IdWIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgcHV0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyLFxuXG4gIGdldExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcixcblxuICBkZWxldGVMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXIsXG5cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnNcblxufSk7XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIsICdSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInLCB7XG4gIHB1dExpc3RlbmVyOiAncHV0TGlzdGVuZXInLFxuICBkZWxldGVMaXN0ZW5lcjogJ2RlbGV0ZUxpc3RlbmVyJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkUmVjb25jaWxlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgbmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIGlmIChuZXN0ZWRDaGlsZE5vZGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0YW5jZXMgPSB7fTtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGluc3RhbnRpYXRlQ2hpbGQsIGNoaWxkSW5zdGFuY2VzKTtcbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8oPyFcXC8pL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJy8vJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZCAhPT0gY2hpbGQgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5IHx8ICcnKSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG52YXIgd2FybmVkU2V0UHJvcHMgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5TZXRQcm9wcygpIHtcbiAgaWYgKCF3YXJuZWRTZXRQcm9wcykge1xuICAgIHdhcm5lZFNldFByb3BzID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3NldFByb3BzKC4uLikgYW5kIHJlcGxhY2VQcm9wcyguLi4pIGFyZSBkZXByZWNhdGVkLiAnICsgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgbmF0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgbm90IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICsgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgKyAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlICcgKyAndG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGNsYXNzIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBpZiAoIXByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcFtuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICsgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSAobmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVMpO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgKyAnY29uc3RydWN0b3IuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gKG5hbWUgaW4gQ29uc3RydWN0b3IpO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgKyAnZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICsgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgKyAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgKyAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICsgJ3dpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIG5vLXVuZGVmICovXG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICBpZiAoY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShhdXRvQmluZEtleSkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwW2F1dG9CaW5kS2V5XTtcbiAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRQcm9wczogZnVuY3Rpb24gKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblNldFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0UHJvcHModGhpcywgcGFydGlhbFByb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZSBhbGwgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVwbGFjZVByb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5TZXRQcm9wcygpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VQcm9wcyh0aGlzLCBuZXdQcm9wcyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGlzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH07XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBnZXRET01Ob2RlOiBbJ2dldERPTU5vZGUnLCAnVXNlIFJlYWN0RE9NLmZpbmRET01Ob2RlKGNvbXBvbmVudCkgaW5zdGVhZC4nXSxcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVByb3BzOiBbJ3JlcGxhY2VQcm9wcycsICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddLFxuICAgIHNldFByb3BzOiBbJ3NldFByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQsXG5cbiAgLyoqXG4gICAqIElmIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCByZXF1aXJlcyB0aGF0IHNvbWUgcmVzb3VyY2VzIGJlIGNsZWFuZWQgdXAsXG4gICAqIHNwZWNpZnkgdGhpcyBpbiB0aGUgaW5qZWN0ZWQgTWl4aW4uIEluIHRoZSBET00sIHdlIHdvdWxkIGxpa2VseSB3YW50IHRvXG4gICAqIHB1cmdlIGFueSBjYWNoZWQgbm9kZSBJRCBsb29rdXBzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBmdW5jdGlvbiAocm9vdE5vZGVJRCkge1xuICAgIFJlYWN0TW91bnQucHVyZ2VJRChyb290Tm9kZUlEKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGVudmlyb25tZW50IGRlcGVuZGVudCBjbGVhbnVwIGhvb2suIChzZXJ2ZXIgdnMuXG4gICAqIGJyb3dzZXIgZXRjKS4gRXhhbXBsZTogQSBicm93c2VyIHN5c3RlbSBjYWNoZXMgRE9NIG5vZGVzIGJhc2VkIG9uIGNvbXBvbmVudFxuICAgKiBJRCBhbmQgbXVzdCByZW1vdmUgdGhhdCBjYWNoZSBlbnRyeSB3aGVuIHRoaXMgaW5zdGFuY2UgaXMgdW5tb3VudGVkLlxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHJldHVybiBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHB1YmxpYyBjbGFzc1xuICAgIHZhciBpbnN0O1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBUaGlzIGlzIGEgd2F5IHRvIGRldGVjdCBpZiBDb21wb25lbnQgaXMgYSBzdGF0ZWxlc3MgYXJyb3cgZnVuY3Rpb25cbiAgICAvLyBjb21wb25lbnQsIHdoaWNoIGlzIG5vdCBuZXdhYmxlLiBJdCBtaWdodCBub3QgYmUgMTAwJSByZWxpYWJsZSBidXQgaXNcbiAgICAvLyBzb21ldGhpbmcgd2UgY2FuIGRvIHVudGlsIHdlIHN0YXJ0IGRldGVjdGluZyB0aGF0IENvbXBvbmVudCBleHRlbmRzXG4gICAgLy8gUmVhY3QuQ29tcG9uZW50LiBXZSBhbHJlYWR5IGFzc3VtZSB0aGF0IHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicuXG4gICAgdmFyIGNhbkluc3RhbnRpYXRlID0gKCdwcm90b3R5cGUnIGluIENvbXBvbmVudCk7XG5cbiAgICBpZiAoY2FuSW5zdGFudGlhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCBSZWFjdFVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FuSW5zdGFudGlhdGUgfHwgaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAsIHJldHVybmVkICcgKyAnbnVsbC9mYWxzZSBmcm9tIGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgb3IgdHJpZWQgdG8gcmVuZGVyIGFuICcgKyAnZWxlbWVudCB3aG9zZSB0eXBlIGlzIGEgZnVuY3Rpb24gdGhhdCBpc25cXCd0IGEgUmVhY3QgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzdXBwb3J0IEVTNiBpbmhlcml0aW5nIGZyb20gUmVhY3QuQ29tcG9uZW50LCB0aGUgbW9kdWxlIHBhdHRlcm4sXG4gICAgICAgIC8vIGFuZCBzdGF0ZWxlc3MgY29tcG9uZW50cywgYnV0IG5vdCBFUzYgY2xhc3NlcyB0aGF0IGRvbid0IGV4dGVuZFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCB8fCAhY2FuSW5zdGFudGlhdGUgfHwgIShpbnN0IGluc3RhbmNlb2YgQ29tcG9uZW50KSwgJyVzKC4uLik6IFJlYWN0IGNvbXBvbmVudCBjbGFzc2VzIG11c3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQpO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgcm9vdElELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQgJiYgaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5wcm9wVHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LnByb3BUeXBlcywgbmV3UHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdQcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uIChwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICAgIC8vIFRPRE86IFN0b3AgdmFsaWRhdGluZyBwcm9wIHR5cGVzIGhlcmUgYW5kIG9ubHkgdXNlIHRoZSBlbGVtZW50XG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSAnICsgJ2Zyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gZXh0ZW5kIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgZXJyb3JzIGluXG4gICAgICAgICAgLy8gdG9wLWxldmVsIHJlbmRlciBjYWxscywgc28gSSdtIGFic3RyYWN0aW5nIGl0IGF3YXkgaW50b1xuICAgICAgICAgIC8vIGEgZnVuY3Rpb24gdG8gbWluaW1pemUgcmVmYWN0b3JpbmcgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSh0aGlzKTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKSB7XG4gICAgICAgICAgICAvLyBQcmVmYWNlIGdpdmVzIHVzIHNvbWV0aGluZyB0byBibGFja2xpc3QgaW4gd2FybmluZyBtb2R1bGVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29udGV4dCBUeXBlczogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCB8fCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBuZXh0Q29udGV4dCA9IHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQgPyBpbnN0LmNvbnRleHQgOiB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB2YXIgbmV4dFByb3BzO1xuXG4gICAgLy8gRGlzdGluZ3Vpc2ggYmV0d2VlbiBhIHByb3BzIHVwZGF0ZSB2ZXJzdXMgYSBzaW1wbGUgc3RhdGUgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ID09PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgLy8gU2tpcCBjaGVja2luZyBwcm9wIHR5cGVzIGFnYWluIC0tIHdlIGRvbid0IHJlYWQgaW5zdC5wcm9wcyB0byBhdm9pZFxuICAgICAgLy8gd2FybmluZyBmb3IgRE9NIGNvbXBvbmVudCBwcm9wcyBpbiB0aGlzIHVwZ3JhZGVcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dFBhcmVudEVsZW1lbnQucHJvcHMpO1xuICAgICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuXG4gICAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgfHwgIWluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlIHx8IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHNob3VsZFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IGFzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXNlIHR3byBJRHMgYXJlIGFjdHVhbGx5IHRoZSBzYW1lISBCdXQgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHRoaXNJRCA9IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICB2YXIgcHJldkNvbXBvbmVudElEID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9yb290Tm9kZUlEO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHRoaXNJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdENvbXBvbmVudCBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdCBpbnN0YW5jZW9mIFN0YXRlbGVzc0NvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4sICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCcsXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50J1xufSk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01cbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIHJlbmRlciA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdCcsICdyZW5kZXInLCBSZWFjdE1vdW50LnJlbmRlcik7XG5cbnZhciBSZWFjdCA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IHJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIEluc3RhbmNlSGFuZGxlczogUmVhY3RJbnN0YW5jZUhhbmRsZXMsXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyLFxuICAgIFRleHRDb21wb25lbnQ6IFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cbiAgICAvLyBzaGFtc1xuICAgIE9iamVjdC5jcmVhdGUsIE9iamVjdC5mcmVlemVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignT25lIG9yIG1vcmUgRVM1IHNoaW0vc2hhbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb3VzZUxpc3RlbmVyTmFtZXMgPSB7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHByb3BzLCBleGNlcHQgdGhlIG1vdXNlIGxpc3RlbmVyc1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiYgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSB7XG4gICAgICAgIG5hdGl2ZVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKCcuL1JlYWN0RE9NQnV0dG9uJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBDSElMRFJFTiA9IGtleU9mKHsgY2hpbGRyZW46IG51bGwgfSk7XG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbGVnYWN5UHJvcHNEZXNjcmlwdG9yO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbGVnYWN5UHJvcHNEZXNjcmlwdG9yID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucHJvcHMgb2YgYSBET00gbm9kZTsgaW5zdGVhZCwgJyArICdyZWNyZWF0ZSB0aGUgcHJvcHMgYXMgYHJlbmRlcmAgZGlkIG9yaWdpbmFsbHkgb3IgcmVhZCB0aGUgRE9NICcgKyAncHJvcGVydGllcy9hdHRyaWJ1dGVzIGRpcmVjdGx5IGZyb20gdGhpcyBub2RlIChlLmcuLCAnICsgJ3RoaXMucmVmcy5ib3guY2xhc3NOYW1lKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lHZXRET01Ob2RlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmdldERPTU5vZGUoKSBvZiBhIERPTSBub2RlOyAnICsgJ2luc3RlYWQsIHVzZSB0aGUgbm9kZSBkaXJlY3RseS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbGVnYWN5SXNNb3VudGVkKCkge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5pc01vdW50ZWQoKSBvZiBhIERPTSBub2RlLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAhIWNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gbGVnYWN5U2V0U3RhdGVFdGMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0U3RhdGUoKSwgLnJlcGxhY2VTdGF0ZSgpLCBvciAnICsgJy5mb3JjZVVwZGF0ZSgpIG9mIGEgRE9NIG5vZGUuIFRoaXMgaXMgYSBuby1vcC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnNldFByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoY29tcG9uZW50LCBwYXJ0aWFsUHJvcHMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKGNvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlcGxhY2VQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnJlcGxhY2VQcm9wcygpIG9mIGEgRE9NIG5vZGUuICcgKyAnSW5zdGVhZCwgY2FsbCBSZWFjdERPTS5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZXMgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5vdCBoYXZlIGBjaGlsZHJlbmAgb3IgJyArICd1c2UgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHVuZGVmaW5lZDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArICdub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuICcgKyAndXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSA/IGNvbnRhaW5lci5vd25lckRvY3VtZW50IDogY29udGFpbmVyO1xuICAgIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIH1cbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGlkOiBpZCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaWQsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBjcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVhZHlJbnB1dFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NSW5wdXQubW91bnRSZWFkeVdyYXBwZXIodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsIGNhc2VkIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIGluc3QpIHtcbiAgLy8gUGFzcyBkb3duIG91ciB0YWcgbmFtZSB0byBjaGlsZCBjb21wb25lbnRzIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzXG4gIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICB2YXIgaW5mbyA9IGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldO1xuICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKGluZm8sIGluc3QuX3RhZywgaW5zdCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZykge1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBUaGUgcm9vdCBET00gSUQgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQgPSBSZWFjdERPTVNlbGVjdC5wcm9jZXNzQ2hpbGRDb250ZXh0KHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCB0aGlzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2O1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKHt9LCBwcm9wcywgdHJhbnNhY3Rpb24sIGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGVsKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShtb3VudFJlYWR5SW5wdXRXcmFwcGVyLCB0aGlzKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAocHJvcEtleSAhPT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChlbCwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgcmVmZXJlbmNlLWVxdWFsIHRvIHRoZSBvbGQgb25lLCBwYXNzIGRvd24gdGhlIHNhbWVcbiAgICAgIC8vIHByb2Nlc3NlZCBvYmplY3Qgc28gdGhlIHVwZGF0ZSBiYWlsb3V0IGluIFJlYWN0UmVjb25jaWxlciBiZWhhdmVzXG4gICAgICAvLyBjb3JyZWN0bHkgKGFuZCBpZGVudGljYWxseSBpbiBkZXYgYW5kIHByb2QpLiBTZWUgIzUwMDUuXG4gICAgICBpZiAodGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBudWxsKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSAmJiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgbm9kZSkge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIH1cbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudW5tb3VudFdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCAnICsgJzxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhICcgKyAnc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgJyArICdlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcblxuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IHRoaXM7XG4gICAgICBub2RlLmdldERPTU5vZGUgPSBsZWdhY3lHZXRET01Ob2RlO1xuICAgICAgbm9kZS5pc01vdW50ZWQgPSBsZWdhY3lJc01vdW50ZWQ7XG4gICAgICBub2RlLnNldFN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnJlcGxhY2VTdGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5mb3JjZVVwZGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5zZXRQcm9wcyA9IGxlZ2FjeVNldFByb3BzO1xuICAgICAgbm9kZS5yZXBsYWNlUHJvcHMgPSBsZWdhY3lSZXBsYWNlUHJvcHM7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIGxlZ2FjeVByb3BzRGVzY3JpcHRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50IHdpbGwgdXBkYXRlIHRoaXMgcHJvcGVydHkgb24gc3Vic2VxdWVudCByZW5kZXJzXG4gICAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUNvbXBvbmVudCwgJ1JlYWN0RE9NQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50J1xufSk7XG5cbmFzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG5cbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9tYXBPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRhZyBuYW1lIChlLmcuIGBkaXZgKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTUZhY3RvcnkodGFnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5KHRhZyk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KHRhZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IG1hcE9iamVjdCh7XG4gIGE6ICdhJyxcbiAgYWJicjogJ2FiYnInLFxuICBhZGRyZXNzOiAnYWRkcmVzcycsXG4gIGFyZWE6ICdhcmVhJyxcbiAgYXJ0aWNsZTogJ2FydGljbGUnLFxuICBhc2lkZTogJ2FzaWRlJyxcbiAgYXVkaW86ICdhdWRpbycsXG4gIGI6ICdiJyxcbiAgYmFzZTogJ2Jhc2UnLFxuICBiZGk6ICdiZGknLFxuICBiZG86ICdiZG8nLFxuICBiaWc6ICdiaWcnLFxuICBibG9ja3F1b3RlOiAnYmxvY2txdW90ZScsXG4gIGJvZHk6ICdib2R5JyxcbiAgYnI6ICdicicsXG4gIGJ1dHRvbjogJ2J1dHRvbicsXG4gIGNhbnZhczogJ2NhbnZhcycsXG4gIGNhcHRpb246ICdjYXB0aW9uJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjb2RlOiAnY29kZScsXG4gIGNvbDogJ2NvbCcsXG4gIGNvbGdyb3VwOiAnY29sZ3JvdXAnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGFsaXN0OiAnZGF0YWxpc3QnLFxuICBkZDogJ2RkJyxcbiAgZGVsOiAnZGVsJyxcbiAgZGV0YWlsczogJ2RldGFpbHMnLFxuICBkZm46ICdkZm4nLFxuICBkaWFsb2c6ICdkaWFsb2cnLFxuICBkaXY6ICdkaXYnLFxuICBkbDogJ2RsJyxcbiAgZHQ6ICdkdCcsXG4gIGVtOiAnZW0nLFxuICBlbWJlZDogJ2VtYmVkJyxcbiAgZmllbGRzZXQ6ICdmaWVsZHNldCcsXG4gIGZpZ2NhcHRpb246ICdmaWdjYXB0aW9uJyxcbiAgZmlndXJlOiAnZmlndXJlJyxcbiAgZm9vdGVyOiAnZm9vdGVyJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBoMTogJ2gxJyxcbiAgaDI6ICdoMicsXG4gIGgzOiAnaDMnLFxuICBoNDogJ2g0JyxcbiAgaDU6ICdoNScsXG4gIGg2OiAnaDYnLFxuICBoZWFkOiAnaGVhZCcsXG4gIGhlYWRlcjogJ2hlYWRlcicsXG4gIGhncm91cDogJ2hncm91cCcsXG4gIGhyOiAnaHInLFxuICBodG1sOiAnaHRtbCcsXG4gIGk6ICdpJyxcbiAgaWZyYW1lOiAnaWZyYW1lJyxcbiAgaW1nOiAnaW1nJyxcbiAgaW5wdXQ6ICdpbnB1dCcsXG4gIGluczogJ2lucycsXG4gIGtiZDogJ2tiZCcsXG4gIGtleWdlbjogJ2tleWdlbicsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsZWdlbmQ6ICdsZWdlbmQnLFxuICBsaTogJ2xpJyxcbiAgbGluazogJ2xpbmsnLFxuICBtYWluOiAnbWFpbicsXG4gIG1hcDogJ21hcCcsXG4gIG1hcms6ICdtYXJrJyxcbiAgbWVudTogJ21lbnUnLFxuICBtZW51aXRlbTogJ21lbnVpdGVtJyxcbiAgbWV0YTogJ21ldGEnLFxuICBtZXRlcjogJ21ldGVyJyxcbiAgbmF2OiAnbmF2JyxcbiAgbm9zY3JpcHQ6ICdub3NjcmlwdCcsXG4gIG9iamVjdDogJ29iamVjdCcsXG4gIG9sOiAnb2wnLFxuICBvcHRncm91cDogJ29wdGdyb3VwJyxcbiAgb3B0aW9uOiAnb3B0aW9uJyxcbiAgb3V0cHV0OiAnb3V0cHV0JyxcbiAgcDogJ3AnLFxuICBwYXJhbTogJ3BhcmFtJyxcbiAgcGljdHVyZTogJ3BpY3R1cmUnLFxuICBwcmU6ICdwcmUnLFxuICBwcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgcTogJ3EnLFxuICBycDogJ3JwJyxcbiAgcnQ6ICdydCcsXG4gIHJ1Ynk6ICdydWJ5JyxcbiAgczogJ3MnLFxuICBzYW1wOiAnc2FtcCcsXG4gIHNjcmlwdDogJ3NjcmlwdCcsXG4gIHNlY3Rpb246ICdzZWN0aW9uJyxcbiAgc2VsZWN0OiAnc2VsZWN0JyxcbiAgc21hbGw6ICdzbWFsbCcsXG4gIHNvdXJjZTogJ3NvdXJjZScsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3Ryb25nOiAnc3Ryb25nJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1YjogJ3N1YicsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgc3VwOiAnc3VwJyxcbiAgdGFibGU6ICd0YWJsZScsXG4gIHRib2R5OiAndGJvZHknLFxuICB0ZDogJ3RkJyxcbiAgdGV4dGFyZWE6ICd0ZXh0YXJlYScsXG4gIHRmb290OiAndGZvb3QnLFxuICB0aDogJ3RoJyxcbiAgdGhlYWQ6ICd0aGVhZCcsXG4gIHRpbWU6ICd0aW1lJyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHRyOiAndHInLFxuICB0cmFjazogJ3RyYWNrJyxcbiAgdTogJ3UnLFxuICB1bDogJ3VsJyxcbiAgJ3Zhcic6ICd2YXInLFxuICB2aWRlbzogJ3ZpZGVvJyxcbiAgd2JyOiAnd2JyJyxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiAnY2lyY2xlJyxcbiAgY2xpcFBhdGg6ICdjbGlwUGF0aCcsXG4gIGRlZnM6ICdkZWZzJyxcbiAgZWxsaXBzZTogJ2VsbGlwc2UnLFxuICBnOiAnZycsXG4gIGltYWdlOiAnaW1hZ2UnLFxuICBsaW5lOiAnbGluZScsXG4gIGxpbmVhckdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxuICBtYXNrOiAnbWFzaycsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIHBvbHlsaW5lOiAncG9seWxpbmUnLFxuICByYWRpYWxHcmFkaWVudDogJ3JhZGlhbEdyYWRpZW50JyxcbiAgcmVjdDogJ3JlY3QnLFxuICBzdG9wOiAnc3RvcCcsXG4gIHN2ZzogJ3N2ZycsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgdHNwYW46ICd0c3BhbidcblxufSwgY3JlYXRlRE9NRmFjdG9yeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmVhdHVyZUZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlET3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBFcnJvcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90IGJlIHVwZGF0ZWQgd2l0aCBgdXBkYXRlUHJvcGVydHlCeUlEKClgLlxuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMgPSB7XG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlSW5uZXJIVE1MQnlJRCgpYC4nLFxuICBzdHlsZTogJ2BzdHlsZWAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZVN0eWxlc0J5SUQoKWAuJ1xufTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgd2l0aCBuZXcgcHJvcGVydHkgdmFsdWVzLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG9cbiAgICogdXBkYXRlIERPTSBwcm9wZXJ0aWVzIGluIGBET01Qcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgdmFsaWQgcHJvcGVydHkgbmFtZSwgc2VlIGBET01Qcm9wZXJ0eWAuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVQcm9wZXJ0eUJ5SUQ6IGZ1bmN0aW9uIChpZCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgISFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVQcm9wZXJ0eUJ5SUQoLi4uKTogJXMnLCBJTlZBTElEX1BST1BFUlRZX0VSUk9SU1tuYW1lXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIERPTSBub2RlIHRoYXQgZXhpc3RzIGluIHRoZSBkb2N1bWVudCB3aXRoIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGNoaWxkIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIERhbmdlcm91cyBtYXJrdXAgdG8gaW5qZWN0IGluIHBsYWNlIG9mIGNoaWxkLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwfVxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBmdW5jdGlvbiAoaWQsIG1hcmt1cCkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAobm9kZSwgbWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHVwZGF0ZXMsIG1hcmt1cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlc1tpXS5wYXJlbnROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHVwZGF0ZXNbaV0ucGFyZW50SUQpO1xuICAgIH1cbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXModXBkYXRlcywgbWFya3VwKTtcbiAgfVxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0RE9NSURPcGVyYXRpb25zLCAnUmVhY3RET01JRE9wZXJhdGlvbnMnLCB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCcsXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcydcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlucHV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0SUQgPSB7fTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICBtb3VudFJlYWR5V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBDYW4ndCBiZSBpbiBtb3VudFdyYXBwZXIgb3IgZWxzZSBzZXJ2ZXIgcmVuZGVyaW5nIGxlYWtzLlxuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXSA9IGluc3Q7XG4gIH0sXG5cbiAgdW5tb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHdpdGggbm9uLVJlYWN0LlxuICAgICAgdmFyIG90aGVySUQgPSBSZWFjdE1vdW50LmdldElEKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJyArICdzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gaW5zdGFuY2VzQnlSZWFjdElEW290aGVySURdO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogVW5rbm93biByYWRpbyBidXR0b24gSUQgJXMuJywgb3RoZXJJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9IFJlYWN0RE9NU2VsZWN0LnZhbHVlQ29udGV4dEtleTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJyB2aWEgY29udGV4dFxuICAgIHZhciBzZWxlY3RWYWx1ZSA9IGNvbnRleHRbdmFsdWVDb250ZXh0S2V5XTtcblxuICAgIC8vIElmIGNvbnRleHQga2V5IGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09ICcnICsgcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSAnJyArIHByb3BzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBuYXRpdmVQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9ICcnO1xuXG4gICAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gICAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICBSZWFjdENoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBuYXRpdmVQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9ICdfX1JlYWN0RE9NU2VsZWN0X3ZhbHVlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdE1vdW50LmdldE5vZGUoaW5zdC5fcm9vdE5vZGVJRCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgdmFsdWVDb250ZXh0S2V5OiB2YWx1ZUNvbnRleHRLZXksXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG4gIH0sXG5cbiAgcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gUGFzcyBkb3duIGluaXRpYWwgdmFsdWUgc28gaW5pdGlhbCBnZW5lcmF0ZWQgbWFya3VwIGhhcyBjb3JyZWN0XG4gICAgLy8gYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgY2hpbGRDb250ZXh0W3ZhbHVlQ29udGV4dEtleV0gPSBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIHJldHVybiBjaGlsZENvbnRleHQ7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGUgY29udGV4dCB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAodHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gdHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJyA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZXJ2ZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NU2VydmVyID0ge1xuICByZW5kZXJUb1N0cmluZzogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0YXRpY01hcmt1cCxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VydmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBpbiBlbGVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIHVuZGVyZ29cbiAqIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgLy8gVGhpcyBjb25zdHJ1Y3RvciBhbmQgaXRzIGFyZ3VtZW50IGlzIGN1cnJlbnRseSB1c2VkIGJ5IG1vY2tzLlxufTtcblxuYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgICB0aGlzLl9zdHJpbmdUZXh0ID0gJycgKyB0ZXh0O1xuXG4gICAgLy8gUHJvcGVydGllc1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcbiAgICogYW55IGZlYXR1cmVzIGJlc2lkZXMgY29udGFpbmluZyB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcoJ3NwYW4nLCBudWxsLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBjb250ZXh0W1JlYWN0TW91bnQub3duZXJEb2N1bWVudENvbnRleHRLZXldO1xuICAgICAgdmFyIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHJvb3RJRCk7XG4gICAgICAvLyBQb3B1bGF0ZSBub2RlIGNhY2hlXG4gICAgICBSZWFjdE1vdW50LmdldElEKGVsKTtcbiAgICAgIHNldFRleHRDb250ZW50KGVsLCB0aGlzLl9zdHJpbmdUZXh0KTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgaW4gYSBgc3BhbmAgZm9yIHRoZSByZWFzb25zIHN0YXRlZCBhYm92ZSwgYnV0XG4gICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLFxuICAgICAgICAvLyB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxzcGFuICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQocm9vdElEKSArICc+JyArIGVzY2FwZWRUZXh0ICsgJzwvc3Bhbj4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy51cGRhdGVUZXh0Q29udGVudChub2RlLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQodGhpcy5fcm9vdE5vZGVJRCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLlxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIC8vIFdlIHNhdmUgdGhlIGluaXRpYWwgdmFsdWUgc28gdGhhdCBgUmVhY3RET01Db21wb25lbnRgIGRvZXNuJ3QgdXBkYXRlXG4gICAgICAvLyBgdGV4dENvbnRlbnRgICh1bm5lY2Vzc2FyeSBzaW5jZSB3ZSB1cGRhdGUgdmFsdWUpLlxuICAgICAgLy8gVGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzXG4gICAgICAvLyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgKHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZSksXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbmFzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgQ2xpZW50UmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL0NsaWVudFJlYWN0Um9vdEluZGV4Jyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4nKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2VydmVyUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1NlcnZlclJlYWN0Um9vdEluZGV4Jyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEluc3RhbmNlSGFuZGxlKFJlYWN0SW5zdGFuY2VIYW5kbGVzKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0TW91bnQoUmVhY3RNb3VudCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ2xhc3MuaW5qZWN0TWl4aW4oUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudCgnbm9zY3JpcHQnKTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uUm9vdEluZGV4LmluamVjdENyZWF0ZVJlYWN0Um9vdEluZGV4KEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IENsaWVudFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4IDogU2VydmVyUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXgpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuICAgIGlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICAgICAgdmFyIFJlYWN0RGVmYXVsdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdFBlcmYnKTtcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmYuc3RhcnQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSZWFjdERlZmF1bHRQZXJmLl9pbmplY3RlZCkge1xuICAgICAgUmVhY3RQZXJmLmluamVjdGlvbi5pbmplY3RNZWFzdXJlKFJlYWN0RGVmYXVsdFBlcmYubWVhc3VyZSk7XG4gICAgfVxuXG4gICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSB0cnVlO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldExhc3RNZWFzdXJlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0NvbXBvbmVudCBjbGFzcyBuYW1lJzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnVG90YWwgaW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5pbmNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIG1vdW50IHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIHJlbmRlciB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyKSxcbiAgICAgICAgJ01vdW50IHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdSZW5kZXIgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIC8vIFRPRE86IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUoKSBkb2VzIG5vdCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICAvLyBudW1iZXIuXG4gIH0sXG5cbiAgcHJpbnRJbmNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdJbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnRpbWUpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcDogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCB0cnVlKTtcbiAgICByZXR1cm4gc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICBjb25zb2xlLnRhYmxlKFJlYWN0RGVmYXVsdFBlcmYuZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcChtZWFzdXJlbWVudHMpKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBwcmludERPTTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdFtET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRV0gPSBpdGVtLmlkO1xuICAgICAgcmVzdWx0LnR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICByZXN1bHQuYXJncyA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBfcmVjb3JkV3JpdGU6IGZ1bmN0aW9uIChpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3MpIHtcbiAgICAvLyBUT0RPOiB0b3RhbFRpbWUgaXNuJ3QgdGhhdCB1c2VmdWwgc2luY2UgaXQgZG9lc24ndCBjb3VudCBwYWludHMvcmVmbG93c1xuICAgIHZhciB3cml0ZXMgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLndyaXRlcztcbiAgICB3cml0ZXNbaWRdID0gd3JpdGVzW2lkXSB8fCBbXTtcbiAgICB3cml0ZXNbaWRdLnB1c2goe1xuICAgICAgdHlwZTogZm5OYW1lLFxuICAgICAgdGltZTogdG90YWxUaW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9LFxuXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVGltZTtcbiAgICAgIHZhciBydjtcbiAgICAgIHZhciBzdGFydDtcblxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICdmbHVzaEJhdGNoZWRVcGRhdGVzJykge1xuICAgICAgICAvLyBBIFwibWVhc3VyZW1lbnRcIiBpcyBhIHNldCBvZiBtZXRyaWNzIHJlY29yZGVkIGZvciBlYWNoIGZsdXNoLiBXZSB3YW50XG4gICAgICAgIC8vIHRvIGdyb3VwIHRoZSBtZXRyaWNzIGZvciBhIGdpdmVuIGZsdXNoIHRvZ2V0aGVyIHNvIHdlIGNhbiBsb29rIGF0IHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgYW5kIHRoZSBET00gb3BlcmF0aW9ucyB0aGF0IGFjdHVhbGx5XG4gICAgICAgIC8vIGhhcHBlbmVkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIFwid2FzdGVkIHdvcmtcIiBwZXJmb3JtZWQuXG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgICAgICBleGNsdXNpdmU6IHt9LFxuICAgICAgICAgIGluY2x1c2l2ZToge30sXG4gICAgICAgICAgcmVuZGVyOiB7fSxcbiAgICAgICAgICBjb3VudHM6IHt9LFxuICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgZGlzcGxheU5hbWVzOiB7fSxcbiAgICAgICAgICB0b3RhbFRpbWU6IDAsXG4gICAgICAgICAgY3JlYXRlZDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLnRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdfbW91bnRJbWFnZUludG9Ob2RlJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RET01JRE9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01DaGlsZHJlbk9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKSB7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnKSB7XG4gICAgICAgICAgdmFyIG1vdW50SUQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMV0pO1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKG1vdW50SUQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBmb3JtYXRcbiAgICAgICAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlQXJncyA9IHt9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5mcm9tSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLmZyb21JbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRvSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRvSW5kZXggPSB1cGRhdGUudG9JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRleHRDb250ZW50ID0gdXBkYXRlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5tYXJrdXBJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MubWFya3VwID0gYXJnc1sxXVt1cGRhdGUubWFya3VwSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUodXBkYXRlLnBhcmVudElELCB1cGRhdGUudHlwZSwgdG90YWxUaW1lLCB3cml0ZUFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhc2ljIGZvcm1hdFxuICAgICAgICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlkID0gUmVhY3RNb3VudC5nZXRJRChhcmdzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoaWQsIGZuTmFtZSwgdG90YWxUaW1lLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnICYmIChmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgfHwgZm5OYW1lID09PSAndXBkYXRlQ29tcG9uZW50JyB8fCAvLyBUT0RPOiByZWNlaXZlQ29tcG9uZW50KCk/XG4gICAgICBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JykpIHtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSA9PT0gUmVhY3RNb3VudC5Ub3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290Tm9kZUlEID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnID8gYXJnc1swXSA6IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBpc1JlbmRlciA9IGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnO1xuICAgICAgICB2YXIgaXNNb3VudCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JztcblxuICAgICAgICB2YXIgbW91bnRTdGFjayA9IFJlYWN0RGVmYXVsdFBlcmYuX21vdW50U3RhY2s7XG4gICAgICAgIHZhciBlbnRyeSA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuY291bnRzLCByb290Tm9kZUlELCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgZW50cnkuY3JlYXRlZFtyb290Tm9kZUlEXSA9IHRydWU7XG4gICAgICAgICAgbW91bnRTdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5yZW5kZXIsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIHZhciBzdWJNb3VudFRpbWUgPSBtb3VudFN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vdW50U3RhY2tbbW91bnRTdGFjay5sZW5ndGggLSAxXSArPSB0b3RhbFRpbWU7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuZXhjbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUgLSBzdWJNb3VudFRpbWUpO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5kaXNwbGF5TmFtZXNbcm9vdE5vZGVJRF0gPSB7XG4gICAgICAgICAgY3VycmVudDogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgb3duZXI6IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgOiAnPHJvb3Q+J1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG5cbi8vIERvbid0IHRyeSB0byBzYXZlIHVzZXJzIGxlc3MgdGhhbiAxLjJtcyAoYSBudW1iZXIgSSBtYWRlIHVwKVxudmFyIERPTlRfQ0FSRV9USFJFU0hPTEQgPSAxLjI7XG52YXIgRE9NX09QRVJBVElPTl9UWVBFUyA9IHtcbiAgJ19tb3VudEltYWdlSW50b05vZGUnOiAnc2V0IGlubmVySFRNTCcsXG4gIElOU0VSVF9NQVJLVVA6ICdzZXQgaW5uZXJIVE1MJyxcbiAgTU9WRV9FWElTVElORzogJ21vdmUnLFxuICBSRU1PVkVfTk9ERTogJ3JlbW92ZScsXG4gIFNFVF9NQVJLVVA6ICdzZXQgaW5uZXJIVE1MJyxcbiAgVEVYVF9DT05URU5UOiAnc2V0IHRleHRDb250ZW50JyxcbiAgJ3NldFZhbHVlRm9yUHJvcGVydHknOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdzZXRWYWx1ZUZvckF0dHJpYnV0ZSc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ2RlbGV0ZVZhbHVlRm9yUHJvcGVydHknOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICdzZXRWYWx1ZUZvclN0eWxlcyc6ICd1cGRhdGUgc3R5bGVzJyxcbiAgJ3JlcGxhY2VOb2RlV2l0aE1hcmt1cCc6ICdyZXBsYWNlJyxcbiAgJ3VwZGF0ZVRleHRDb250ZW50JzogJ3NldCB0ZXh0Q29udGVudCdcbn07XG5cbmZ1bmN0aW9uIGdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpIHtcbiAgLy8gVE9ETzogcmV0dXJuIG51bWJlciBvZiBET00gb3BzPyBjb3VsZCBiZSBtaXNsZWFkaW5nLlxuICAvLyBUT0RPOiBtZWFzdXJlIGRyb3BwZWQgZnJhbWVzIGFmdGVyIHJlY29uY2lsZT9cbiAgLy8gVE9ETzogbG9nIHRvdGFsIHRpbWUgb2YgZWFjaCByZWNvbmNpbGUgYW5kIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50XG4gIC8vIGNsYXNzIHRoYXQgdHJpZ2dlcmVkIGl0LlxuICB2YXIgdG90YWxUaW1lID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdG90YWxUaW1lICs9IG1lYXN1cmVtZW50LnRvdGFsVGltZTtcbiAgfVxuICByZXR1cm4gdG90YWxUaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgbWVhc3VyZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG1lYXN1cmVtZW50KSB7XG4gICAgT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgbWVhc3VyZW1lbnQud3JpdGVzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZSkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHlwZTogRE9NX09QRVJBVElPTl9UWVBFU1t3cml0ZS50eXBlXSB8fCB3cml0ZS50eXBlLFxuICAgICAgICAgIGFyZ3M6IHdyaXRlLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGRpc3BsYXlOYW1lO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgZGlzcGxheU5hbWUgPSBtZWFzdXJlbWVudC5kaXNwbGF5TmFtZXNbaWRdLmN1cnJlbnQ7XG5cbiAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdID0gY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgaW5jbHVzaXZlOiAwLFxuICAgICAgICBleGNsdXNpdmU6IDAsXG4gICAgICAgIHJlbmRlcjogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG4gICAgICBpZiAobWVhc3VyZW1lbnQucmVuZGVyW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5yZW5kZXIgKz0gbWVhc3VyZW1lbnQucmVuZGVyW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5leGNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmV4Y2x1c2l2ZSArPSBtZWFzdXJlbWVudC5leGNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uaW5jbHVzaXZlICs9IG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuY291bnRzW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChkaXNwbGF5TmFtZSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmV4Y2x1c2l2ZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5leGNsdXNpdmUgLSBhLmV4Y2x1c2l2ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIG9ubHlDbGVhbikge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgaW5jbHVzaXZlS2V5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcbiAgICB2YXIgY2xlYW5Db21wb25lbnRzO1xuXG4gICAgaWYgKG9ubHlDbGVhbikge1xuICAgICAgY2xlYW5Db21wb25lbnRzID0gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBpZiAob25seUNsZWFuICYmICFjbGVhbkNvbXBvbmVudHNbaWRdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBtZWFzdXJlbWVudC5kaXNwbGF5TmFtZXNbaWRdO1xuXG4gICAgICAvLyBJbmNsdXNpdmUgdGltZSBpcyBub3QgdXNlZnVsIGZvciBtYW55IGNvbXBvbmVudHMgd2l0aG91dCBrbm93aW5nIHdoZXJlXG4gICAgICAvLyB0aGV5IGFyZSBpbnN0YW50aWF0ZWQuIFNvIHdlIGFnZ3JlZ2F0ZSBpbmNsdXNpdmUgdGltZSB3aXRoIGJvdGggdGhlXG4gICAgICAvLyBvd25lciBhbmQgY3VycmVudCBkaXNwbGF5TmFtZSBhcyB0aGUga2V5LlxuICAgICAgaW5jbHVzaXZlS2V5ID0gZGlzcGxheU5hbWUub3duZXIgKyAnID4gJyArIGRpc3BsYXlOYW1lLmN1cnJlbnQ7XG5cbiAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSA9IGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGluY2x1c2l2ZUtleSxcbiAgICAgICAgdGltZTogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lICs9IG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuY291bnRzW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoaW5jbHVzaXZlS2V5IGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnRpbWUgLSBhLnRpbWU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpIHtcbiAgLy8gRm9yIGEgZ2l2ZW4gcmVjb25jaWxlLCBsb29rIGF0IHdoaWNoIGNvbXBvbmVudHMgZGlkIG5vdCBhY3R1YWxseVxuICAvLyByZW5kZXIgYW55dGhpbmcgdG8gdGhlIERPTSBhbmQgcmV0dXJuIGEgbWFwcGluZyBvZiB0aGVpciBJRCB0b1xuICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgaXQgdG9vayB0byByZW5kZXIgdGhlIGVudGlyZSBzdWJ0cmVlLlxuICB2YXIgY2xlYW5Db21wb25lbnRzID0ge307XG4gIHZhciBkaXJ0eUxlYWZJRHMgPSBPYmplY3Qua2V5cyhtZWFzdXJlbWVudC53cml0ZXMpO1xuICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgdmFyIGlzRGlydHkgPSBmYWxzZTtcbiAgICAvLyBGb3IgZWFjaCBjb21wb25lbnQgdGhhdCByZW5kZXJlZCwgc2VlIGlmIGEgY29tcG9uZW50IHRoYXQgdHJpZ2dlcmVkXG4gICAgLy8gYSBET00gb3AgaXMgaW4gaXRzIHN1YnRyZWUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJ0eUxlYWZJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkaXJ0eUxlYWZJRHNbaV0uaW5kZXhPZihpZCkgPT09IDApIHtcbiAgICAgICAgaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBpZiBjb21wb25lbnQgbmV3bHkgY3JlYXRlZFxuICAgIGlmIChtZWFzdXJlbWVudC5jcmVhdGVkW2lkXSkge1xuICAgICAgaXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNEaXJ0eSAmJiBtZWFzdXJlbWVudC5jb3VudHNbaWRdID4gMCkge1xuICAgICAgY2xlYW5Db21wb25lbnRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGVhbkNvbXBvbmVudHM7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSB7XG4gIGdldEV4Y2x1c2l2ZVN1bW1hcnk6IGdldEV4Y2x1c2l2ZVN1bW1hcnksXG4gIGdldEluY2x1c2l2ZVN1bW1hcnk6IGdldEluY2x1c2l2ZVN1bW1hcnksXG4gIGdldERPTVN1bW1hcnk6IGdldERPTVN1bW1hcnksXG4gIGdldFRvdGFsVGltZTogZ2V0VG90YWxUaW1lXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgUmVhY3QgZWxlbWVudHMuIFRoaXMgaXMgb25seSB1c2VkIHRvIG1ha2UgdGhpc1xuICogd29yayB3aXRoIGEgZHluYW1pYyBpbnN0YW5jZW9mIGNoZWNrLiBOb3RoaW5nIHNob3VsZCBsaXZlIG9uIHRoaXMgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICByZWYgPSBjb25maWcucmVmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLnJlZjtcbiAgICBrZXkgPSBjb25maWcua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBjb25maWcua2V5O1xuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzW3Byb3BOYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3UHJvcHMpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBvbGRFbGVtZW50LmtleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG5ld1Byb3BzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElmIHRoZSBrZXkgb24gdGhlIG9yaWdpbmFsIGlzIHZhbGlkLCB0aGVuIHRoZSBjbG9uZSBpcyB2YWxpZFxuICAgIG5ld0VsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZDtcbiAgfVxuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChjb25maWcucmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0gZ2V0QWRkZW5kYUZvcktleVVzZSgndW5pcXVlS2V5JywgZWxlbWVudCwgcGFyZW50VHlwZSk7XG4gIGlmIChhZGRlbmRhID09PSBudWxsKSB7XG4gICAgLy8gd2UgYWxyZWFkeSBzaG93ZWQgdGhlIHdhcm5pbmdcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMlcycsIGFkZGVuZGEucGFyZW50T3JPd25lciB8fCAnJywgYWRkZW5kYS5jaGlsZE93bmVyIHx8ICcnLCBhZGRlbmRhLnVybCB8fCAnJykgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU2hhcmVkIHdhcm5pbmcgYW5kIG1vbml0b3JpbmcgY29kZSBmb3IgdGhlIGtleSB3YXJuaW5ncy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVHlwZSBBIGtleSB1c2VkIGZvciBkZS1kdXBpbmcgd2FybmluZ3MuXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqIEByZXR1cm5zIHs/b2JqZWN0fSBBIHNldCBvZiBhZGRlbmRhIHRvIHVzZSBpbiB0aGUgd2FybmluZyBtZXNzYWdlLCBvciBudWxsXG4gKiBpZiB0aGUgd2FybmluZyBoYXMgYWxyZWFkeSBiZWVuIHNob3duIGJlZm9yZSAoYW5kIHNob3VsZG4ndCBiZSBzaG93biBhZ2FpbikuXG4gKi9cbmZ1bmN0aW9uIGdldEFkZGVuZGFGb3JLZXlVc2UobWVzc2FnZVR5cGUsIGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gIGlmICghYWRkZW5kdW0pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgYWRkZW5kdW0gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdIHx8IChvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdID0ge30pO1xuICBpZiAobWVtb2l6ZXJbYWRkZW5kdW1dKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWVtb2l6ZXJbYWRkZW5kdW1dID0gdHJ1ZTtcblxuICB2YXIgYWRkZW5kYSA9IHtcbiAgICBwYXJlbnRPck93bmVyOiBhZGRlbmR1bSxcbiAgICB1cmw6ICcgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgY2hpbGRPd25lcjogbnVsbFxuICB9O1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGFkZGVuZGEuY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHJldHVybiBhZGRlbmRhO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lLCB0eXBlb2YgZXJyb3IpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhuYW1lLCBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWRUeXBlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxudmFyIHBsYWNlaG9sZGVyRWxlbWVudDtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcGxhY2Vob2xkZXJFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50KTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0YW50aWF0ZShwbGFjZWhvbGRlckVsZW1lbnQpO1xufTtcbmFzc2lnbihSZWFjdEVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7fSxcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHJvb3RJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICAgIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5kZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgfVxufSk7XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2YgdGhlIFJlYWN0IElEcyBvZiB0aGUgY29tcG9uZW50cyB0aGF0IHJlbmRlcmVkIHRvXG4vLyBgbnVsbGAgKGluIHJlYWxpdHkgYSBwbGFjZWhvbGRlciBzdWNoIGFzIGBub3NjcmlwdGApXG52YXIgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5ID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQgdG8gbnVsbC5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgcmV0dXJuICEhbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXTtcbn1cblxuLyoqXG4gKiBNYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXSA9IHRydWU7XG59XG5cbi8qKlxuICogVW5tYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGw6IGl0IHJlbmRlcnMgdG8gc29tZXRoaW5nIG5vdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIGRlbGV0ZSBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5ID0ge1xuICBpc051bGxDb21wb25lbnRJRDogaXNOdWxsQ29tcG9uZW50SUQsXG4gIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiByZWdpc3Rlck51bGxDb21wb25lbnRJRCxcbiAgZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRDogZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXJyb3JVdGlsc1xuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHs/U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSwgYikge1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKGEsIGIpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSwgYik7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKlxuICogRmluZHMgdGhlIHBhcmVudCBSZWFjdCBjb21wb25lbnQgb2YgYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fSBQYXJlbnQgY29udGFpbmVyLCBvciBgbnVsbGAgaWYgdGhlIHNwZWNpZmllZCBub2RlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG5vdCBuZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQobm9kZSkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB2YXIgbm9kZUlEID0gUmVhY3RNb3VudC5nZXRJRChub2RlKTtcbiAgdmFyIHJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChub2RlSUQpO1xuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChyb290SUQpO1xuICB2YXIgcGFyZW50ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGNvbnRhaW5lcik7XG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbmFzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICAvLyBUT0RPOiBSZS1lbmFibGUgZXZlbnQucGF0aCBoYW5kbGluZ1xuICAvL1xuICAvLyBpZiAoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQucGF0aCAmJiBib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoLmxlbmd0aCA+IDEpIHtcbiAgLy8gICAvLyBOZXcgYnJvd3NlcnMgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbiAgLy8gICBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoKGJvb2tLZWVwaW5nKTtcbiAgLy8gfSBlbHNlIHtcbiAgLy8gICAvLyBMZWdhY3kgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbiAgLy8gICBoYW5kbGVUb3BMZXZlbFdpdGhvdXRQYXRoKGJvb2tLZWVwaW5nKTtcbiAgLy8gfVxuXG4gIHZvaWQgaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aDsgLy8gdGVtcG9yYXJpbHkgdW51c2VkXG4gIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xufVxuXG4vLyBMZWdhY3kgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRvcExldmVsVGFyZ2V0ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSkgfHwgd2luZG93O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0b3BMZXZlbFRhcmdldDtcbiAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRvcExldmVsVGFyZ2V0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHZhciB0b3BMZXZlbFRhcmdldElEID0gUmVhY3RNb3VudC5nZXRJRCh0b3BMZXZlbFRhcmdldCkgfHwgJyc7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBOZXcgYnJvd3NlcnMgaGF2ZSBhIHBhdGggYXR0cmlidXRlIG9uIG5hdGl2ZSBldmVudHNcbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHBhdGggPSBib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoO1xuICB2YXIgY3VycmVudE5hdGl2ZVRhcmdldCA9IHBhdGhbMF07XG4gIHZhciBldmVudHNGaXJlZCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgIGlmIChjdXJyZW50UGF0aEVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkge1xuICAgICAgY3VycmVudE5hdGl2ZVRhcmdldCA9IHBhdGhbaSArIDFdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBzbG93XG4gICAgdmFyIHJlYWN0UGFyZW50ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGN1cnJlbnRQYXRoRWxlbWVudCk7XG4gICAgaWYgKHJlYWN0UGFyZW50ID09PSBjdXJyZW50UGF0aEVsZW1lbnQpIHtcbiAgICAgIHZhciBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIHZhciBuZXdSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoY3VycmVudFBhdGhFbGVtZW50SUQpO1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goY3VycmVudFBhdGhFbGVtZW50KTtcblxuICAgICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKGN1cnJlbnRQYXRoRWxlbWVudCkgfHwgJyc7XG4gICAgICBldmVudHNGaXJlZCsrO1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIGN1cnJlbnRQYXRoRWxlbWVudCwgdG9wTGV2ZWxUYXJnZXRJRCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGN1cnJlbnROYXRpdmVUYXJnZXQpO1xuXG4gICAgICAvLyBKdW1wIHRvIHRoZSByb290IG9mIHRoaXMgUmVhY3QgcmVuZGVyIHRyZWVcbiAgICAgIHdoaWxlIChjdXJyZW50UGF0aEVsZW1lbnRJRCAhPT0gbmV3Um9vdElEKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgY3VycmVudFBhdGhFbGVtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgY3VycmVudFBhdGhFbGVtZW50SUQgPSBSZWFjdE1vdW50LmdldElEKGN1cnJlbnRQYXRoRWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChldmVudHNGaXJlZCA9PT0gMCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB3aW5kb3csICcnLCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0TmF0aXZlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vUmVhY3RSb290SW5kZXgnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIE5hdGl2ZUNvbXBvbmVudDogUmVhY3ROYXRpdmVDb21wb25lbnQuaW5qZWN0aW9uLFxuICBQZXJmOiBSZWFjdFBlcmYuaW5qZWN0aW9uLFxuICBSb290SW5kZXg6IFJlYWN0Um9vdEluZGV4LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgKGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZUhhbmRsZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1JlYWN0Um9vdEluZGV4Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTRVBBUkFUT1JfTEVOR1RIID0gU0VQQVJBVE9SLmxlbmd0aDtcblxuLyoqXG4gKiBNYXhpbXVtIGRlcHRoIG9mIHRyYXZlcnNhbHMgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGJhZCBJRC5cbiAqL1xudmFyIE1BWF9UUkVFX0RFUFRIID0gMTAwMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTSBJRCBwcmVmaXggdG8gdXNlIHdoZW4gbW91bnRpbmcgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQSB1bmlxdWUgaW50ZWdlclxuICogQHJldHVybiB7c3RyaW5nfSBSZWFjdCByb290IElELlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEU3RyaW5nKGluZGV4KSB7XG4gIHJldHVybiBTRVBBUkFUT1IgKyBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGluIHRoZSBzdXBwbGllZCBJRCBpcyBhIHNlcGFyYXRvciBvciB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yIG9yIGVuZCBvZiB0aGUgSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0JvdW5kYXJ5KGlkLCBpbmRleCkge1xuICByZXR1cm4gaWQuY2hhckF0KGluZGV4KSA9PT0gU0VQQVJBVE9SIHx8IGluZGV4ID09PSBpZC5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELCBtYXliZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJRChpZCkge1xuICByZXR1cm4gaWQgPT09ICcnIHx8IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3QgSUQgaXMgYW4gYW5jZXN0b3Igb2Ygb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc2NlbmRhbnRJRFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgYW5jZXN0b3JJRGAgaXMgYW4gYW5jZXN0b3Igb2YgYGRlc2NlbmRhbnRJRGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzY2VuZGFudElEKSB7XG4gIHJldHVybiBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJiBpc0JvdW5kYXJ5KGRlc2NlbmRhbnRJRCwgYW5jZXN0b3JJRC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBJRCBvZiB0aGUgc3VwcGxpZWQgUmVhY3QgRE9NIElELCBgaWRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHBhcmVudCwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SUQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQuc3Vic3RyKDAsIGlkLmxhc3RJbmRleE9mKFNFUEFSQVRPUikpIDogJyc7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCBET00gSUQgb24gdGhlIHRyZWUgcGF0aCBmcm9tIHRoZSBzdXBwbGllZCBgYW5jZXN0b3JJRGAgdG8gdGhlXG4gKiBzdXBwbGllZCBgZGVzdGluYXRpb25JRGAuIElmIHRoZXkgYXJlIGVxdWFsLCB0aGUgSUQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySUQgSUQgb2YgYW4gYW5jZXN0b3Igbm9kZSBvZiBgZGVzdGluYXRpb25JRGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25JRCBJRCBvZiB0aGUgZGVzdGluYXRpb24gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBJRCBvbiB0aGUgcGF0aCBmcm9tIGBhbmNlc3RvcklEYCB0byBgZGVzdGluYXRpb25JRGAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXROZXh0RGVzY2VuZGFudElEKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIHtcbiAgIShpc1ZhbGlkSUQoYW5jZXN0b3JJRCkgJiYgaXNWYWxpZElEKGRlc3RpbmF0aW9uSUQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKCVzLCAlcyk6IFJlY2VpdmVkIGFuIGludmFsaWQgUmVhY3QgRE9NIElELicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoLi4uKTogUmVhY3QgaGFzIG1hZGUgYW4gaW52YWxpZCBhc3N1bXB0aW9uIGFib3V0ICcgKyAndGhlIERPTSBoaWVyYXJjaHkuIEV4cGVjdGVkIGAlc2AgdG8gYmUgYW4gYW5jZXN0b3Igb2YgYCVzYC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChhbmNlc3RvcklEID09PSBkZXN0aW5hdGlvbklEKSB7XG4gICAgcmV0dXJuIGFuY2VzdG9ySUQ7XG4gIH1cbiAgLy8gU2tpcCBvdmVyIHRoZSBhbmNlc3RvciBhbmQgdGhlIGltbWVkaWF0ZSBzZXBhcmF0b3IuIFRyYXZlcnNlIHVudGlsIHdlIGhpdFxuICAvLyBhbm90aGVyIHNlcGFyYXRvciBvciB3ZSByZWFjaCB0aGUgZW5kIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAgdmFyIHN0YXJ0ID0gYW5jZXN0b3JJRC5sZW5ndGggKyBTRVBBUkFUT1JfTEVOR1RIO1xuICB2YXIgaTtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBkZXN0aW5hdGlvbklELmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkoZGVzdGluYXRpb25JRCwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb25JRC5zdWJzdHIoMCwgaSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgb2YgdHdvIElEcy5cbiAqXG4gKiBVc2luZyB0aGlzIElEIHNjaGVtZSwgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIGlzIHRoZSBsb25nZXN0IGNvbW1vblxuICogcHJlZml4IG9mIHRoZSB0d28gSURzIHRoYXQgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYSBcIm1hcmtlclwiIGluIGJvdGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB0d29JRFxuICogQHJldHVybiB7c3RyaW5nfSBOZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCwgb3IgdGhlIGVtcHR5IHN0cmluZyBpZiBub25lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKG9uZUlELCB0d29JRCkge1xuICB2YXIgbWluTGVuZ3RoID0gTWF0aC5taW4ob25lSUQubGVuZ3RoLCB0d29JRC5sZW5ndGgpO1xuICBpZiAobWluTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXN0Q29tbW9uTWFya2VySW5kZXggPSAwO1xuICAvLyBVc2UgYDw9YCB0byB0cmF2ZXJzZSB1bnRpbCB0aGUgXCJFT0xcIiBvZiB0aGUgc2hvcnRlciBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkob25lSUQsIGkpICYmIGlzQm91bmRhcnkodHdvSUQsIGkpKSB7XG4gICAgICBsYXN0Q29tbW9uTWFya2VySW5kZXggPSBpO1xuICAgIH0gZWxzZSBpZiAob25lSUQuY2hhckF0KGkpICE9PSB0d29JRC5jaGFyQXQoaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgbG9uZ2VzdENvbW1vbklEID0gb25lSUQuc3Vic3RyKDAsIGxhc3RDb21tb25NYXJrZXJJbmRleCk7XG4gICFpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJywgb25lSUQsIHR3b0lELCBsb25nZXN0Q29tbW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGxvbmdlc3RDb21tb25JRDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBwYXRoIGJldHdlZW4gdHdvIElEcyAoZWl0aGVyIHVwIG9yIGRvd24pLiBUaGUgSURzIG11c3RcbiAqIG5vdCBiZSB0aGUgc2FtZSwgYW5kIHRoZXJlIG11c3QgZXhpc3QgYSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHRoZW0uIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0cmF2ZXJzYWwgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0YXJ0IElEIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RvcCBJRCBhdCB3aGljaCB0byBlbmQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIGVhY2ggSUQgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBGaXJzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBmaXJzdCBub2RlLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcExhc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgbGFzdCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnRQYXRoKHN0YXJ0LCBzdG9wLCBjYiwgYXJnLCBza2lwRmlyc3QsIHNraXBMYXN0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgJyc7XG4gIHN0b3AgPSBzdG9wIHx8ICcnO1xuICAhKHN0YXJ0ICE9PSBzdG9wKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gYW5kIHRvIHRoZSBzYW1lIElELCBgJXNgLicsIHN0YXJ0KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAhKHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArICdub3QgaGF2ZSBhIHBhcmVudCBwYXRoLicsIHN0YXJ0LCBzdG9wKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIC8vIFRyYXZlcnNlIGZyb20gYHN0YXJ0YCB0byBgc3RvcGAgb25lIGRlcHRoIGF0IGEgdGltZS5cbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIHRyYXZlcnNlID0gdHJhdmVyc2VVcCA/IGdldFBhcmVudElEIDogZ2V0TmV4dERlc2NlbmRhbnRJRDtcbiAgZm9yICh2YXIgaWQgPSBzdGFydDs7IC8qIHVudGlsIGJyZWFrICovaWQgPSB0cmF2ZXJzZShpZCwgc3RvcCkpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmICgoIXNraXBGaXJzdCB8fCBpZCAhPT0gc3RhcnQpICYmICghc2tpcExhc3QgfHwgaWQgIT09IHN0b3ApKSB7XG4gICAgICByZXQgPSBjYihpZCwgdHJhdmVyc2VVcCwgYXJnKTtcbiAgICB9XG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgaWQgPT09IHN0b3ApIHtcbiAgICAgIC8vIE9ubHkgYnJlYWsgLy9hZnRlci8vIHZpc2l0aW5nIGBzdG9wYC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhKGRlcHRoKysgPCBNQVhfVFJFRV9ERVBUSCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogRGV0ZWN0ZWQgYW4gaW5maW5pdGUgbG9vcCB3aGlsZSAnICsgJ3RyYXZlcnNpbmcgdGhlIFJlYWN0IERPTSBJRCB0cmVlLiBUaGlzIG1heSBiZSBkdWUgdG8gbWFsZm9ybWVkIElEczogJXMnLCBzdGFydCwgc3RvcCwgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIElEcyBhc3NpZ25lZCB0byBET00gcmVwcmVzZW50YXRpb25zIG9mIFJlYWN0IGNvbXBvbmVudHMuIFRoaXNcbiAqIHVzZXMgYSBzcGVjaWZpYyBzY2hlbWUgaW4gb3JkZXIgdG8gdHJhdmVyc2UgdGhlIERPTSBlZmZpY2llbnRseSAoZS5nLiBpblxuICogb3JkZXIgdG8gc2ltdWxhdGUgZXZlbnRzKS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3Qgcm9vdCBJRFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3Qgcm9vdCBJRC5cbiAgICovXG4gIGNyZWF0ZVJlYWN0Um9vdElEOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uIChyb290SUQsIG5hbWUpIHtcbiAgICByZXR1cm4gcm9vdElEICsgbmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoZSBSZWFjdCBjb21wb25lbnQgd2l0aCB0aGUgc3VwcGxpZWQgRE9NIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgRE9NIElEIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFJlYWN0Um9vdElERnJvbU5vZGVJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkICYmIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoU0VQQVJBVE9SLCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaWQuc3Vic3RyKDAsIGluZGV4KSA6IGlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gICAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAgICpcbiAgICogTk9URTogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZVxuICAgKiBub3RoaW5nIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYXZlSUQgSUQgYmVpbmcgbGVmdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudGVySUQgSUQgYmVpbmcgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggZW50ZXJlZC9sZWZ0IElELlxuICAgKiBAcGFyYW0geyp9IHVwQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBsZWZ0IElEcy5cbiAgICogQHBhcmFtIHsqfSBkb3duQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBlbnRlcmVkIElEcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGB0cmF2ZXJzZVR3b1BoYXNlYCBidXQgc2tpcHMgdGhlIGB0YXJnZXRJRGAuXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldDogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2UgYSBub2RlIElELCBjYWxsaW5nIHRoZSBzdXBwbGllZCBgY2JgIGZvciBlYWNoIGFuY2VzdG9yIElELiBGb3JcbiAgICogZXhhbXBsZSwgcGFzc2luZyBgLjAuJHJvdy0wLjFgIHdvdWxkIHJlc3VsdCBpbiBgY2JgIGdldHRpbmcgY2FsbGVkXG4gICAqIHdpdGggYC4wYCwgYC4wLiRyb3ctMGAsIGFuZCBgLjAuJHJvdy0wLjFgLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEOiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0RGVzY2VuZGFudElEOiBnZXROZXh0RGVzY2VuZGFudElELFxuXG4gIGlzQW5jZXN0b3JJRE9mOiBpc0FuY2VzdG9ySURPZixcblxuICBTRVBBUkFUT1I6IFNFUEFSQVRPUlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHtcblxuICAvKipcbiAgICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2U7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdmFsdWU7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElzb21vcnBoaWNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIEhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZyBlbHNlLlxuICBfX3NwcmVhZDogYXNzaWduXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnknKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBub2RlQ2FjaGUgPSB7fTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIG93bmVyRG9jdW1lbnRDb250ZXh0S2V5ID0gJ19fUmVhY3RNb3VudF9vd25lckRvY3VtZW50JCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuICovXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIGBjb250YWluZXJgIG5vZGVzLiAqL1xudmFyIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKiBfX0RFVl9fLW9ubHkgbWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIHJvb3QgZWxlbWVudHMuICovXG4gIHZhciByb290RWxlbWVudHNCeVJlYWN0Um9vdElEID0ge307XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYnJlYWR0aC1maXJzdCBzZWFyY2ggc3RhdGUgaW4gZmluZENvbXBvbmVudFJvb3QuXG52YXIgZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5ID0gW107XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gYSBSZWFjdCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBBIFwicmVhY3RSb290XCIgSUQsIGlmIGEgUmVhY3QgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmdldElEKHJvb3RFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBBY2Nlc3Npbmcgbm9kZVtBVFRSX05BTUVdIG9yIGNhbGxpbmcgZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgb24gYSBmb3JtXG4gKiBlbGVtZW50IGNhbiByZXR1cm4gaXRzIGNvbnRyb2wgd2hvc2UgbmFtZSBvciBJRCBlcXVhbHMgQVRUUl9OQU1FLiBBbGxcbiAqIERPTSBub2RlcyBzdXBwb3J0IGBnZXRBdHRyaWJ1dGVOb2RlYCBidXQgdGhpcyBjYW4gYWxzbyBnZXQgY2FsbGVkIG9uXG4gKiBvdGhlciBvYmplY3RzIHNvIGp1c3QgcmV0dXJuICcnIGlmIHdlJ3JlIGdpdmVuIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAqIERPTSBub2RlIChzdWNoIGFzIHdpbmRvdykuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudHxET01XaW5kb3d8RE9NRG9jdW1lbnR8RE9NVGV4dE5vZGV9IG5vZGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBzdXBwbGllZCBgZG9tTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGdldElEKG5vZGUpIHtcbiAgdmFyIGlkID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKGlkKSB7XG4gICAgaWYgKG5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbaWRdO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gbm9kZSkge1xuICAgICAgICAhIWlzVmFsaWQoY2FjaGVkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVHdvIHZhbGlkIGJ1dCB1bmVxdWFsIG5vZGVzIHdpdGggdGhlIHNhbWUgYCVzYDogJXMnLCBBVFRSX05BTUUsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIFJlYWN0LXNwZWNpZmljIElEIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBUaGUgRE9NIG5vZGUgd2hvc2UgSUQgd2lsbCBiZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHZhbHVlIG9mIHRoZSBJRCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldElEKG5vZGUsIGlkKSB7XG4gIHZhciBvbGRJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChvbGRJRCAhPT0gaWQpIHtcbiAgICBkZWxldGUgbm9kZUNhY2hlW29sZElEXTtcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZShBVFRSX05BTUUsIGlkKTtcbiAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpbnN0YW5jZSBBIHB1YmxpYyBSZWFjdCBpbnN0YW5jZS5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0YW5jZSkuX3Jvb3ROb2RlSUQ7XG4gIGlmIChSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuaXNOdWxsQ29tcG9uZW50SUQoaWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgaXMgXCJ2YWxpZFwiIGlmIGl0IGlzIGNvbnRhaW5lZCBieSBhIGN1cnJlbnRseSBtb3VudGVkIGNvbnRhaW5lci5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSB0byBiZSBjb250YWluZWQgYnkgYSBkb2N1bWVudCBpblxuICogb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGV4cGVjdGVkIElEIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBjb250YWluZWQgYnkgYSBtb3VudGVkIGNvbnRhaW5lci5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZChub2RlLCBpZCkge1xuICBpZiAobm9kZSkge1xuICAgICEoaW50ZXJuYWxHZXRJRChub2RlKSA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFVuZXhwZWN0ZWQgbW9kaWZpY2F0aW9uIG9mIGAlc2AnLCBBVFRSX05BTUUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5zTm9kZShjb250YWluZXIsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2F1c2VzIHRoZSBjYWNoZSB0byBmb3JnZXQgYWJvdXQgb25lIFJlYWN0LXNwZWNpZmljIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gZm9yZ2V0LlxuICovXG5mdW5jdGlvbiBwdXJnZUlEKGlkKSB7XG4gIGRlbGV0ZSBub2RlQ2FjaGVbaWRdO1xufVxuXG52YXIgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbChhbmNlc3RvcklEKSB7XG4gIHZhciBhbmNlc3RvciA9IG5vZGVDYWNoZVthbmNlc3RvcklEXTtcbiAgaWYgKGFuY2VzdG9yICYmIGlzVmFsaWQoYW5jZXN0b3IsIGFuY2VzdG9ySUQpKSB7XG4gICAgZGVlcGVzdE5vZGVTb0ZhciA9IGFuY2VzdG9yO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbm9kZSBpc24ndCBwb3B1bGF0ZWQgaW4gdGhlIGNhY2hlLCBzbyBwcmVzdW1hYmx5IG5vbmUgb2YgaXRzXG4gICAgLy8gZGVzY2VuZGFudHMgYXJlLiBCcmVhayBvdXQgb2YgdGhlIGxvb3AuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWVwZXN0IGNhY2hlZCBub2RlIHdob3NlIElEIGlzIGEgcHJlZml4IG9mIGB0YXJnZXRJRGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIFJlYWN0SW5zdGFuY2VIYW5kbGVzLnRyYXZlcnNlQW5jZXN0b3JzKHRhcmdldElELCBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbCk7XG5cbiAgdmFyIGZvdW5kTm9kZSA9IGRlZXBlc3ROb2RlU29GYXI7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICByZXR1cm4gZm91bmROb2RlO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgaWYgKFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICBjb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgICBjb250ZXh0W293bmVyRG9jdW1lbnRDb250ZXh0S2V5XSA9IGNvbnRhaW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dFtvd25lckRvY3VtZW50Q29udGV4dEtleV0gPSBjb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gZW1wdHlPYmplY3QpIHtcbiAgICAgIGNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGNvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdGFnLCBudWxsKTtcbiAgfVxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgY29tcG9uZW50SW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSBjb21wb25lbnRJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiBmb3JjZUhUTUwgKi9zaG91bGRSZXVzZU1hcmt1cCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIpIHtcbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UpO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxuICogYHVubW91bnRDb21wb25lbnRBdE5vZGVgLCBldGMuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgYSBkaXJlY3QgY2hpbGQgdGhhdCB3YXNcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQobm9kZSkge1xuICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChub2RlKTtcbiAgcmV0dXJuIHJlYWN0Um9vdElEID8gcmVhY3RSb290SUQgIT09IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCkgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCAoZGVlcGVzdCkgYW5jZXN0b3Igb2YgYSBub2RlIHdoaWNoIGlzIHJlbmRlcmVkIGJ5IHRoaXMgY29weVxuICogb2YgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGZpbmRGaXJzdFJlYWN0RE9NSW1wbChub2RlKSB7XG4gIC8vIFRoaXMgbm9kZSBtaWdodCBiZSBmcm9tIGFub3RoZXIgUmVhY3QgaW5zdGFuY2UsIHNvIHdlIG1ha2Ugc3VyZSBub3QgdG9cbiAgLy8gZXhhbWluZSB0aGUgbm9kZSBjYWNoZSBoZXJlXG4gIGZvciAoOyBub2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAvLyBOb3QgYSBET01FbGVtZW50LCB0aGVyZWZvcmUgbm90IGEgUmVhY3QgY29tcG9uZW50XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vZGVJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gICAgaWYgKCFub2RlSUQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQobm9kZUlEKTtcblxuICAgIC8vIElmIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEIGNvbnRhaW5zIHRoZSBjb250YWluZXIgd2UgZmluZCBieSBjcmF3bGluZyB1cFxuICAgIC8vIHRoZSB0cmVlLCB3ZSBrbm93IHRoYXQgdGhpcyBpbnN0YW5jZSBvZiBSZWFjdCByZW5kZXJlZCB0aGUgbm9kZS5cbiAgICAvLyBuYi4gaXNWYWxpZCdzIHN0cmF0ZWd5ICh3aXRoIGNvbnRhaW5zTm9kZSkgZG9lcyBub3Qgd29yayBiZWNhdXNlIHJlbmRlclxuICAgIC8vIHRyZWVzIG1heSBiZSBuZXN0ZWQgYW5kIHdlIGRvbid0IHdhbnQgYSBmYWxzZSBwb3NpdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHZhciBsYXN0SUQ7XG4gICAgZG8ge1xuICAgICAgbGFzdElEID0gaW50ZXJuYWxHZXRJRChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBwYXNzZWQtaW4gbm9kZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIHRoZSBjb250YWluZXIgaXQgd2FzXG4gICAgICAgIC8vIG9yaWdpbmFsbHkgcmVuZGVyZWQgaW50by5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSB3aGlsZSAobGFzdElEICE9PSByZWFjdFJvb3RJRCk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge307XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMucHJvcHMgaXMgYWN0dWFsbHkgYSBSZWFjdEVsZW1lbnRcbiAgcmV0dXJuIHRoaXMucHJvcHM7XG59O1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqIEV4cG9zZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyAqKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IGludG8gdGhlIGluc3RhbmNlIG1hcCBhbmQgc3RhcnRzIHNjcm9sbCB2YWx1ZVxuICAgKiBtb25pdG9yaW5nXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHJldHVybiB7c3RyaW5nfSByZWFjdFJvb3QgSUQgcHJlZml4XG4gICAqL1xuICBfcmVnaXN0ZXJDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0Q29tcG9uZW50LCBjb250YWluZXIpIHtcbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50LnJlZ2lzdGVyQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBuZXh0Q29tcG9uZW50O1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50Ll9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIHJlYWN0Um9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVsZW1lbnQgc3RyaW5nLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gbmV3IFJlYWN0RWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG5leHRFbGVtZW50KTtcblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHM7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgcGFyZW50Q29tcG9uZW50ICE9IG51bGwgPyBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkgOiBlbXB0eU9iamVjdCkuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY29udGFpbmVyIG5vZGUgaW50byB3aGljaCBSZWFjdCBjb21wb25lbnRzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIFRoaXMgYWxzbyBjcmVhdGVzIHRoZSBcInJlYWN0Um9vdFwiIElEIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZWxlbWVudFxuICAgKiByZW5kZXJlZCB3aXRoaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGFzIGEgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBcInJlYWN0Um9vdFwiIElEIG9mIGVsZW1lbnRzIHJlbmRlcmVkIHdpdGhpbi5cbiAgICovXG4gIHJlZ2lzdGVyQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICBpZiAocmVhY3RSb290SUQpIHtcbiAgICAgIC8vIElmIG9uZSBleGlzdHMsIG1ha2Ugc3VyZSBpdCBpcyBhIHZhbGlkIFwicmVhY3RSb290XCIgSUQuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCk7XG4gICAgfVxuICAgIGlmICghcmVhY3RSb290SUQpIHtcbiAgICAgIC8vIE5vIHZhbGlkIFwicmVhY3RSb290XCIgSUQgZm91bmQsIGNyZWF0ZSBvbmUuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgfVxuICAgIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lcjtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICB2YXIgY29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJJRCA9IGludGVybmFsR2V0SUQoY29udGFpbmVyKTtcbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lcklEICYmIGNvbnRhaW5lcklEID09PSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoY29udGFpbmVySUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgY29tcG9uZW50LCBjb250YWluZXIpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBkZWxldGUgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgUmVhY3QgY29tcG9uZW50IHRvIHdoaWNoIHRoZVxuICAgKiBzdXBwbGllZCBET00gYGlkYCBiZWxvbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBgaWRgLlxuICAgKi9cbiAgZmluZFJlYWN0Q29udGFpbmVyRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChpZCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICAgIGlmIChyb290RWxlbWVudCAmJiByb290RWxlbWVudC5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAgIC8vIENhbGwgaW50ZXJuYWxHZXRJRCBoZXJlIGJlY2F1c2UgZ2V0SUQgY2FsbHMgaXNWYWxpZCB3aGljaCBjYWxsc1xuICAgICAgICAvLyBmaW5kUmVhY3RDb250YWluZXJGb3JJRCAodGhpcyBmdW5jdGlvbikuXG4gICAgICAgIGludGVybmFsR2V0SUQocm9vdEVsZW1lbnQpID09PSByZWFjdFJvb3RJRCwgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBJRCBkaWZmZXJlZCBmcm9tIHJlYWN0Um9vdElELicpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29udGFpbmVyQ2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGNvbnRhaW5lckNoaWxkICYmIHJlYWN0Um9vdElEID09PSBpbnRlcm5hbEdldElEKGNvbnRhaW5lckNoaWxkKSkge1xuICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaGFzIGEgbmV3IGNoaWxkIHdpdGggdGhlIHNhbWUgSUQgYXMgdGhlIG9sZFxuICAgICAgICAgIC8vIHJvb3QgZWxlbWVudCwgdGhlbiByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSBpc1xuICAgICAgICAgIC8vIGp1c3Qgc3RhbGUgYW5kIG5lZWRzIHRvIGJlIHVwZGF0ZWQuIFRoZSBjYXNlIHRoYXQgZGVzZXJ2ZXMgYVxuICAgICAgICAgIC8vIHdhcm5pbmcgaXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIGVtcHR5LlxuICAgICAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyQ2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCAnICsgJ2NvbnRhaW5lci4gTmV3IGNvbnRhaW5lcjogJXMnLCByb290RWxlbWVudC5wYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgUmVhY3Qgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIERPTSBub2RlIGluIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFJvb3QgRE9NIG5vZGUgb2YgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGZpbmRSZWFjdE5vZGVCeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290ID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZmluZENvbXBvbmVudFJvb3QocmVhY3RSb290LCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB1cCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBzdXBwbGllZCBub2RlIHRvIGZpbmQgYSBub2RlIHRoYXQgaXMgYVxuICAgKiBET00gcmVwcmVzZW50YXRpb24gb2YgYSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgYnkgdGhpcyBjb3B5IG9mIFJlYWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGVcbiAgICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEZpcnN0UmVhY3RET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGZpbmRGaXJzdFJlYWN0RE9NSW1wbChub2RlKTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAgaW5zaWRlIG9mIHRoZSBzdXBwbGllZFxuICAgKiBgYW5jZXN0b3JOb2RlYC4gIEV4cGxvaXRzIHRoZSBJRCBuYW1pbmcgc2NoZW1lIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICAgKiBxdWlja2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBhbmNlc3Rvck5vZGUgU2VhcmNoIGZyb20gdGhpcyByb290LlxuICAgKiBAcGFyYXJtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZmluZENvbXBvbmVudFJvb3Q6IGZ1bmN0aW9uIChhbmNlc3Rvck5vZGUsIHRhcmdldElEKSB7XG4gICAgdmFyIGZpcnN0Q2hpbGRyZW4gPSBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXk7XG4gICAgdmFyIGNoaWxkSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlZXBlc3RBbmNlc3RvciA9IGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHx8IGFuY2VzdG9yTm9kZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgb24gdGhlIG5leHQgbGluZTsgZ2l2ZSBhbiBlYXJseSB3YXJuaW5nXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkZWVwZXN0QW5jZXN0b3IgIT0gbnVsbCwgJ1JlYWN0IGNhblxcJ3QgZmluZCB0aGUgcm9vdCBjb21wb25lbnQgbm9kZSBmb3IgZGF0YS1yZWFjdGlkIHZhbHVlICcgKyAnYCVzYC4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMgbWVzc2FnZSwgaXQgcHJvYmFibHkgbWVhbnMgdGhhdCAnICsgJ3lvdVxcJ3ZlIGxvYWRlZCB0d28gY29waWVzIG9mIFJlYWN0IG9uIHRoZSBwYWdlLiBBdCB0aGlzIHRpbWUsIG9ubHkgJyArICdhIHNpbmdsZSBjb3B5IG9mIFJlYWN0IGNhbiBiZSBsb2FkZWQgYXQgYSB0aW1lLicsIHRhcmdldElEKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuWzBdID0gZGVlcGVzdEFuY2VzdG9yLmZpcnN0Q2hpbGQ7XG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAxO1xuXG4gICAgd2hpbGUgKGNoaWxkSW5kZXggPCBmaXJzdENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZHJlbltjaGlsZEluZGV4KytdO1xuICAgICAgdmFyIHRhcmdldENoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkSUQgPSBSZWFjdE1vdW50LmdldElEKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSUQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHdlIGZpbmQgdGhlIG5vZGUgd2UncmUgbG9va2luZyBmb3IsIHdlIGZpbmlzaCBsb29waW5nXG4gICAgICAgICAgLy8gdGhyb3VnaCBpdHMgc2libGluZ3MgdG8gZW5zdXJlIHRoZXkncmUgY2FjaGVkIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIHRvIHJldmlzaXQgdGhpcyBub2RlIGFnYWluLiBPdGhlcndpc2UsIHdlIG1ha2Ugbl4yIGNhbGxzIHRvIGdldElEXG4gICAgICAgICAgLy8gd2hlbiB2aXNpdGluZyB0aGUgbWFueSBjaGlsZHJlbiBvZiBhIHNpbmdsZSBub2RlIGluIG9yZGVyLlxuXG4gICAgICAgICAgaWYgKHRhcmdldElEID09PSBjaGlsZElEKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUmVhY3RJbnN0YW5jZUhhbmRsZXMuaXNBbmNlc3RvcklET2YoY2hpbGRJRCwgdGFyZ2V0SUQpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgY2hpbGQgd2hvc2UgSUQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIElELFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gYmUgc3VyZSB0aGF0IHdlIG9ubHkgd2FudCB0byBzZWFyY2ggdGhlIHN1YnRyZWVcbiAgICAgICAgICAgIC8vIHJvb3RlZCBhdCB0aGlzIGNoaWxkLCBzbyB3ZSBjYW4gdGhyb3cgb3V0IHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgLy8gc2VhcmNoIHN0YXRlLlxuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjaGlsZCBoYWQgbm8gSUQsIHRoZW4gdGhlcmUncyBhIGNoYW5jZSB0aGF0IGl0IHdhc1xuICAgICAgICAgIC8vIGluamVjdGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGJyb3dzZXIsIGFzIHdoZW4gYSBgPHRhYmxlPmBcbiAgICAgICAgICAvLyBlbGVtZW50IHNwcm91dHMgYW4gZXh0cmEgYDx0Ym9keT5gIGNoaWxkIGFzIGEgc2lkZSBlZmZlY3Qgb2ZcbiAgICAgICAgICAvLyBgLmlubmVySFRNTGAgcGFyc2luZy4gT3B0aW1pc3RpY2FsbHkgY29udGludWUgZG93biB0aGlzXG4gICAgICAgICAgLy8gYnJhbmNoLCBidXQgbm90IGJlZm9yZSBleGFtaW5pbmcgdGhlIG90aGVyIHNpYmxpbmdzLlxuICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRDaGlsZCkge1xuICAgICAgICAvLyBFbXB0eWluZyBmaXJzdENoaWxkcmVuL2ZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSBpc1xuICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciBjb3JyZWN0bmVzcywgYnV0IGl0IGhlbHBzIHRoZSBHQyByZWNsYWltXG4gICAgICAgIC8vIGFueSBub2RlcyB0aGF0IHdlcmUgbGVmdCBhdCB0aGUgZW5kIG9mIHRoZSBzZWFyY2guXG4gICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q2hpbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRDb21wb25lbnRSb290KC4uLiwgJXMpOiBVbmFibGUgdG8gZmluZCBlbGVtZW50LiBUaGlzIHByb2JhYmx5ICcgKyAnbWVhbnMgdGhlIERPTSB3YXMgdW5leHBlY3RlZGx5IG11dGF0ZWQgKGUuZy4sIGJ5IHRoZSBicm93c2VyKSwgJyArICd1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgbmVzdGluZyB0YWdzICcgKyAnbGlrZSA8Zm9ybT4sIDxwPiwgb3IgPGE+LCBvciB1c2luZyBub24tU1ZHIGVsZW1lbnRzIGluIGFuIDxzdmc+ICcgKyAncGFyZW50LiAnICsgJ1RyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCB3aXRoIFJlYWN0IElEIGAlc2AuJywgdGFyZ2V0SUQsIFJlYWN0TW91bnQuZ2V0SUQoYW5jZXN0b3JOb2RlKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyAnICsgJ3NlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5ICcgKyAnbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uICcgKyAndGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSAnICsgJ21ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvICcgKyAnY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3UgJyArICdzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzICcgKyAnYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0ICcgKyAneW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgJyArICd3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiAnICsgJ1NlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWFya3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICB9XG4gIH0sXG5cbiAgb3duZXJEb2N1bWVudENvbnRleHRLZXk6IG93bmVyRG9jdW1lbnRDb250ZXh0S2V5LFxuXG4gIC8qKlxuICAgKiBSZWFjdCBJRCB1dGlsaXRpZXMuXG4gICAqL1xuXG4gIGdldFJlYWN0Um9vdElEOiBnZXRSZWFjdFJvb3RJRCxcblxuICBnZXRJRDogZ2V0SUQsXG5cbiAgc2V0SUQ6IHNldElELFxuXG4gIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcblxuICBpc1ZhbGlkOiBpc1ZhbGlkLFxuXG4gIHB1cmdlSUQ6IHB1cmdlSURcbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdE1vdW50LCAnUmVhY3RNb3VudCcsIHtcbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6ICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcsXG4gIF9tb3VudEltYWdlSW50b05vZGU6ICdfbW91bnRJbWFnZUludG9Ob2RlJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xuXG4vKipcbiAqIFVwZGF0aW5nIGNoaWxkcmVuIG9mIGEgY29tcG9uZW50IG1heSB0cmlnZ2VyIHJlY3Vyc2l2ZSB1cGRhdGVzLiBUaGUgZGVwdGggaXNcbiAqIHVzZWQgdG8gYmF0Y2ggcmVjdXJzaXZlIHVwZGF0ZXMgdG8gcmVuZGVyIG1hcmt1cCBtb3JlIGVmZmljaWVudGx5LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlRGVwdGggPSAwO1xuXG4vKipcbiAqIFF1ZXVlIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gKlxuICogRWFjaCBvYmplY3QgaGFzIGEgYHR5cGVgIHByb3BlcnR5IHRoYXQgaXMgaW4gYFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzYC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8b2JqZWN0Pn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIFF1ZXVlIG9mIG1hcmt1cCB0byBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXJrdXBRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIEVucXVldWVzIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlSW5zZXJ0TWFya3VwKHBhcmVudElELCBtYXJrdXAsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBtYXJrdXBRdWV1ZS5wdXNoKG1hcmt1cCkgLSAxLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1vdmUocGFyZW50SUQsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlUmVtb3ZlKHBhcmVudElELCBmcm9tSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVNldE1hcmt1cChwYXJlbnRJRCwgbWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgdGV4dCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVRleHRDb250ZW50KHBhcmVudElELCB0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICBpZiAodXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKHVwZGF0ZVF1ZXVlLCBtYXJrdXBRdWV1ZSk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXJzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gIHVwZGF0ZVF1ZXVlLmxlbmd0aCA9IDA7XG4gIG1hcmt1cFF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxuICpcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcbiAgICogdW5tb3VudCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICAvLyBUT0RPOiBUaGUgc2V0VGV4dENvbnRlbnQgb3BlcmF0aW9uIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV4dENvbnRlbnQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuKTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNYXJrdXAobmV4dE1hcmt1cCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEltcHJvdmUgcGVyZm9ybWFuY2UgYnkgaXNvbGF0aW5nIHRoaXMgaG90IGNvZGUgcGF0aCBmcm9tIHRoZSB0cnkvY2F0Y2hcbiAgICAgKiBibG9jayBpbiBgdXBkYXRlQ2hpbGRyZW5gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIG5leHRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdGhpcy5fbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXgobmV4dENoaWxkLCBuYW1lLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICBlbnF1ZXVlTW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UpIHtcbiAgICAgIGVucXVldWVJbnNlcnRNYXJrdXAodGhpcy5fcm9vdE5vZGVJRCwgbW91bnRJbWFnZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBlbnF1ZXVlUmVtb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgZW5xdWV1ZVRleHRDb250ZW50KHRoaXMuX3Jvb3ROb2RlSUQsIHRleHRDb250ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldE1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgICAgZW5xdWV1ZVNldE1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtYXJrdXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQnlOYW1lQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBuYW1lLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROYXRpdmVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyA9IG51bGw7XG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBuYXRpdmUgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICAvLyBUaGlzIGFjY2VwdHMgYSBjbGFzcyB0aGF0IHJlY2VpdmVzIHRoZSB0YWcgc3RyaW5nLiBUaGlzIGlzIGEgY2F0Y2ggYWxsXG4gIC8vIHRoYXQgY2FuIHJlbmRlciBhbnkga2luZCBvZiB0YWcuXG4gIGluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIHRleHQgY29tcG9uZW50IGNsYXNzIHRoYXQgdGFrZXMgdGhlIHRleHQgc3RyaW5nIHRvIGJlXG4gIC8vIHJlbmRlcmVkIGFzIHByb3BzLlxuICBpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIHRleHRDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSBrZXllZCBvYmplY3Qgd2l0aCBjbGFzc2VzIGFzIHZhbHVlcy4gRWFjaCBrZXkgcmVwcmVzZW50cyBhXG4gIC8vIHRhZy4gVGhhdCBwYXJ0aWN1bGFyIHRhZyB3aWxsIHVzZSB0aGlzIGNsYXNzIGluc3RlYWQgb2YgdGhlIGdlbmVyaWMgb25lLlxuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3Nlcykge1xuICAgIGFzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBjb21wb3NpdGUgY29tcG9uZW50IHdyYXBwZXIgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSB0YWcgZm9yIHdoaWNoIHRvIGdldCB0aGUgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIFJlYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH1cbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFnVG9Db21wb25lbnRDbGFzc1t0YWddO1xuICBpZiAoY29tcG9uZW50Q2xhc3MgPT0gbnVsbCkge1xuICAgIHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXSA9IGNvbXBvbmVudENsYXNzID0gYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKHRhZyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufVxuXG4vKipcbiAqIEdldCBhIG5hdGl2ZSBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHtcbiAgZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50OiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQsXG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TmF0aXZlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IgJiYgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJycpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVByb3BzJyk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCAnICsgJ2JlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlYWN0UGVyZiBpcyBhIGdlbmVyYWwgQU9QIHN5c3RlbSBkZXNpZ25lZCB0byBtZWFzdXJlIHBlcmZvcm1hbmNlLiBUaGlzXG4gKiBtb2R1bGUgb25seSBoYXMgdGhlIGhvb2tzOiBzZWUgUmVhY3REZWZhdWx0UGVyZiBmb3IgdGhlIGFuYWx5c2lzIHRvb2wuXG4gKi9cbnZhciBSZWFjdFBlcmYgPSB7XG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIG1lYXN1cmVtZW50LiBTZXQgdG8gZmFsc2UgYnkgZGVmYXVsdCB0byBwcmV2ZW50XG4gICAqIGFjY2lkZW50YWwgbG9nZ2luZyBhbmQgcGVyZiBsb3NzLlxuICAgKi9cbiAgZW5hYmxlTWVhc3VyZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEhvbGRzIG9udG8gdGhlIG1lYXN1cmUgZnVuY3Rpb24gaW4gdXNlLiBCeSBkZWZhdWx0LCBkb24ndCBtZWFzdXJlXG4gICAqIGFueXRoaW5nLCBidXQgd2UnbGwgb3ZlcnJpZGUgdGhpcyBpZiB3ZSBpbmplY3QgYSBtZWFzdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc3RvcmVkTWVhc3VyZTogX25vTWVhc3VyZSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TmFtZVxuICAgKiBAcGFyYW0ge29iamVjdDxzdHJpbmc+fSBtZXRob2ROYW1lc1xuICAgKi9cbiAgbWVhc3VyZU1ldGhvZHM6IGZ1bmN0aW9uIChvYmplY3QsIG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2ROYW1lcykge1xuICAgICAgICBpZiAoIW1ldGhvZE5hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IFJlYWN0UGVyZi5tZWFzdXJlKG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzW2tleV0sIG9iamVjdFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIHRvIHdyYXAgbWV0aG9kcyB5b3Ugd2FudCB0byBtZWFzdXJlLiBaZXJvIG92ZXJoZWFkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1lYXN1cmVkRnVuYyA9IG51bGw7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlKSB7XG4gICAgICAgICAgaWYgKCFtZWFzdXJlZEZ1bmMpIHtcbiAgICAgICAgICAgIG1lYXN1cmVkRnVuYyA9IFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZWFzdXJlZEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBwZXIuZGlzcGxheU5hbWUgPSBvYmpOYW1lICsgJ18nICsgZm5OYW1lO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1lYXN1cmVcbiAgICAgKi9cbiAgICBpbmplY3RNZWFzdXJlOiBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUgPSBtZWFzdXJlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTaW1wbHkgcGFzc2VzIHRocm91Z2ggdGhlIG1lYXN1cmVkIGZ1bmN0aW9uLCB3aXRob3V0IG1lYXN1cmluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIF9ub01lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gIHJldHVybiBmdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UGVyZjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJyk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHJldHVybiAnPDxhbm9ueW1vdXM+Pic7XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oZm9yY2VIVE1MKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdFRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSAhZm9yY2VIVE1MICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQ7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY2FsbCBSZWFjdFJlZi5hdHRhY2hSZWZzIHdpdGggdGhpcyBjb21wb3NpdGUgY29tcG9uZW50LCBzcGxpdCBvdXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpb25zIGluIHRoZSB0cmFuc2FjdGlvbiBtb3VudC1yZWFkeSBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoUmVmcygpIHtcbiAgUmVhY3RSZWYuYXR0YWNoUmVmcyh0aGlzLCB0aGlzLl9jdXJyZW50RWxlbWVudCk7XG59XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgIGludGVybmFsSW5zdGFuY2UudW5tb3VudENvbXBvbmVudCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGbHVzaCBhbnkgZGlydHkgY2hhbmdlcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24pIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGF0dGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG5cbiAgcmV0dXJuKFxuICAgIC8vIFRoaXMgaGFzIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyB3L3IvdCBlbXB0eSBjb21wb25lbnRzLlxuICAgIHByZXZFbXB0eSB8fCBuZXh0RW1wdHkgfHwgbmV4dEVsZW1lbnQuX293bmVyICE9PSBwcmV2RWxlbWVudC5fb3duZXIgfHwgbmV4dEVsZW1lbnQucmVmICE9PSBwcmV2RWxlbWVudC5yZWZcbiAgKTtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJvb3RJbmRleEluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IF9jcmVhdGVSZWFjdFJvb3RJbmRleFxuICAgKi9cbiAgaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uIChfY3JlYXRlUmVhY3RSb290SW5kZXgpIHtcbiAgICBSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCA9IF9jcmVhdGVSZWFjdFJvb3RJbmRleDtcbiAgfVxufTtcblxudmFyIFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogbnVsbCxcbiAgaW5qZWN0aW9uOiBSZWFjdFJvb3RJbmRleEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJvb3RJbmRleDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZS4gRHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIHdlIGRvbid0IHdhbnQgdG9cbiAgICAvLyBzY2hlZHVsZSBhbnkgdXBkYXRlcy4gV2Ugd2lsbCBzaW1wbHkgaWdub3JlIHRoZW0uXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cFxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdHJpbmcoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKGZhbHNlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICB2YXIgbWFya3VwID0gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgICByZXR1cm4gUmVhY3RNYXJrdXBDaGVja3N1bS5hZGRDaGVja3N1bVRvTWFya3VwKG1hcmt1cCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICAvLyBSZXZlcnQgdG8gdGhlIERPTSBiYXRjaGluZyBzdHJhdGVneSBzaW5jZSB0aGVzZSB0d28gcmVuZGVyZXJzXG4gICAgLy8gY3VycmVudGx5IHNoYXJlIHRoZXNlIHN0YXRlZnVsIG1vZHVsZXMuXG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwLCB3aXRob3V0IHRoZSBleHRyYSBSZWFjdCBJRCBhbmQgY2hlY2tzdW1cbiAqIChmb3IgZ2VuZXJhdGluZyBzdGF0aWMgcGFnZXMpXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0YXRpY01hcmt1cCgpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQodHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgZW1wdHlPYmplY3QpO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gUmV2ZXJ0IHRvIHRoZSBET00gYmF0Y2hpbmcgc3RyYXRlZ3kgc2luY2UgdGhlc2UgdHdvIHJlbmRlcmVyc1xuICAgIC8vIGN1cnJlbnRseSBzaGFyZSB0aGVzZSBzdGF0ZWZ1bCBtb2R1bGVzLlxuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IHJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogcmVuZGVyVG9TdGF0aWNNYXJrdXBcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGBDYWxsYmFja1F1ZXVlYCBxdWV1ZSBmb3IgY29sbGVjdGluZyBgb25ET01SZWFkeWAgY2FsbGJhY2tzXG4gKiBkdXJpbmcgdGhlIHBlcmZvcm1pbmcgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIGNsb3NlOiBlbXB0eUZ1bmN0aW9uXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxuICovXG5mdW5jdGlvbiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKHJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSBmYWxzZTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gJyArICcoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlLicsIGNhbGxlck5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGludGVybmFsSW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmVhY3RVcGRhdGVRdWV1ZSBhbGxvd3MgZm9yIHN0YXRlIHVwZGF0ZXMgdG8gYmUgc2NoZWR1bGVkIGludG8gYSBsYXRlclxuICogcmVjb25jaWxpYXRpb24gc3RlcC5cbiAqL1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICEodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlbnF1ZXVlQ2FsbGJhY2soLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgLCBgcmVwbGFjZVByb3BzYCwgJyArICdgc2V0U3RhdGVgLCBgcmVwbGFjZVN0YXRlYCwgb3IgYGZvcmNlVXBkYXRlYCB3aXRoIGEgY2FsbGJhY2sgdGhhdCAnICsgJ2lzblxcJ3QgY2FsbGFibGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRQcm9wcycpO1xuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRQcm9wc0ludGVybmFsKGludGVybmFsSW5zdGFuY2UsIHBhcnRpYWxQcm9wcyk7XG4gIH0sXG5cbiAgZW5xdWV1ZVNldFByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgdG9wTGV2ZWxXcmFwcGVyID0gaW50ZXJuYWxJbnN0YW5jZS5fdG9wTGV2ZWxXcmFwcGVyO1xuICAgICF0b3BMZXZlbFdyYXBwZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0UHJvcHMoLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIHdyYXBFbGVtZW50ID0gdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCB8fCB0b3BMZXZlbFdyYXBwZXIuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50ID0gd3JhcEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMod3JhcEVsZW1lbnQsIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcykpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZSh0b3BMZXZlbFdyYXBwZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIE5ldyBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgcHJvcHMpO1xuICB9LFxuXG4gIGVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIHRvcExldmVsV3JhcHBlciA9IGludGVybmFsSW5zdGFuY2UuX3RvcExldmVsV3JhcHBlcjtcbiAgICAhdG9wTGV2ZWxXcmFwcGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlcGxhY2VQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGByZXBsYWNlUHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIHdyYXBFbGVtZW50ID0gdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCB8fCB0b3BMZXZlbFdyYXBwZXIuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50ID0gd3JhcEVsZW1lbnQucHJvcHM7XG4gICAgdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyh3cmFwRWxlbWVudCwgUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKHRvcExldmVsV3JhcHBlcik7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5ld0VsZW1lbnQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5ld0VsZW1lbnQ7XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGRpcnR5Q29tcG9uZW50cyA9IFtdO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyAnICsgJ3N0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCAvKiBmb3JjZUhUTUwgKi9mYWxzZSk7XG59XG5cbmFzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gJyArICdtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5mbHVzaEJhdGNoZWRVcGRhdGVzID0gUmVhY3RQZXJmLm1lYXN1cmUoJ1JlYWN0VXBkYXRlcycsICdmbHVzaEJhdGNoZWRVcGRhdGVzJywgZmx1c2hCYXRjaGVkVXBkYXRlcyk7XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRQcm9wcywgc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJlJyArICd1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VmVyc2lvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMC4xNC43JzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgY2xpcFBhdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGR4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZmlsbE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250RmFtaWx5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9udFNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyRW5kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyTWlkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyU3RhcnQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBvZmZzZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBvcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBhdHRlcm5Vbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBvaW50czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcng6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHNwcmVhZE1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0b3BDb2xvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0b3BPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlTGluZWNhcDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZU9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VXaWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRleHRBbmNob3I6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB0cmFuc2Zvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2ZXJzaW9uOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdmlld0JveDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHgxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtBY3R1YXRlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtBcmNyb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtIcmVmOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtSb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtTaG93OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUaXRsZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbEJhc2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxMYW5nOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sU3BhY2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gICAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICAgIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gICAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICAgIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICAgIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gICAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gICAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICAgIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gICAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gICAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgICB2aWV3Qm94OiAndmlld0JveCcsXG4gICAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gICAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gICAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gICAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gICAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gICAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICAgIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gICAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlbGVjdEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG52YXIgT05fU0VMRUNUX0tFWSA9IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSk7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpIHx8IHRvcExldmVsVGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fU0VMRUNUX0tFWSkge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VydmVyUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIHJlYWN0Um9vdCBJRCBzcGFjZS4gV2UgZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnMgZm9yIFJlYWN0IHJvb3RcbiAqIElEcyBhbmQgaWYgdGhlcmUncyBhIGNvbGxpc2lvbiB0aGUgZXZlbnRzIGFuZCBET00gdXBkYXRlIHN5c3RlbSB3aWxsXG4gKiBnZXQgY29uZnVzZWQuIEluIHRoZSBmdXR1cmUgd2UgbmVlZCBhIHdheSB0byBnZW5lcmF0ZSBHVUlEcyBidXQgZm9yXG4gKiBub3cgdGhpcyB3aWxsIHdvcmsgb24gYSBzbWFsbGVyIHNjYWxlLlxuICovXG52YXIgR0xPQkFMX01PVU5UX1BPSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcblxudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVByZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlQcmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5VXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkRGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhdXNlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXVzZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblByb2dyZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Qcm9ncmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2VkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVrZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVraW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVraW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVraW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3RhbGxlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3RhbGxlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdXNwZW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdXNwZW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdXNwZW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BWb2x1bWVDaGFuZ2U6IGV2ZW50VHlwZXMudm9sdW1lQ2hhbmdlLFxuICB0b3BXYWl0aW5nOiBldmVudFR5cGVzLndhaXRpbmcsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlRm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBkaXNwYXRjaE1hcmtlcjtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xufVxuXG5hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGV2ZW50LCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBjYWxsaW5nIGBwcmV2ZW50RGVmYXVsdGAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGV2ZW50LCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBjYWxsaW5nIGBzdG9wUHJvcGFnYXRpb25gIG9uIGEgJyArICdyZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiBUaGlzIGlzIGEgbm8tb3AuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gIH1cblxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gIGFzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0ZvY3VzRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0tleWJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUb3VjaEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVUlFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljV2hlZWxFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLmdldFRyYW5zYWN0aW9uV3JhcHBlcnMoKTtcbiAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGEpIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XG4gICAgfVxuICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc0luVHJhbnNhY3Rpb246IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBudWxsLFxuXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2lzSW5UcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIHdpdGhpbiBhIHNhZmV0eSB3aW5kb3cuIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsXG4gICAqIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gbGFyZ2UgYW1vdW50cyBvZiBjb21wdXRhdGlvbi9tdXRhdGlvbnMgdGhhdCB3b3VsZFxuICAgKiBuZWVkIHRvIGJlIHNhZmV0eSBjaGVja2VkLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGhlbHBzIHByZXZlbnQgdGhlIG5lZWRcbiAgICogdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWVtYmVyIG9mIHNjb3BlIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBTY29wZSB0byBpbnZva2UgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGIgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBjIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZCBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGUgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBmIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSAnICsgJ2lzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBUcmFuc2FjdGlvbiA9IHtcblxuICBNaXhpbjogTWl4aW4sXG5cbiAgLyoqXG4gICAqIFRva2VuIHRvIGxvb2sgZm9yIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICovXG4gIE9CU0VSVkVEX0VSUk9SOiB7fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBWaWV3cG9ydE1ldHJpY3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG5cbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbiAoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0TWV0cmljczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWNjdW11bGF0ZUludG9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICB2YXIgY3VycmVudElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICB2YXIgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHQpO1xuXG4gIGlmIChjdXJyZW50SXNBcnJheSAmJiBuZXh0SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChjdXJyZW50SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChuZXh0SXNBcnJheSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkbGVyMzJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICBmb3IgKDsgaSA8IE1hdGgubWluKGkgKyA0MDk2LCBtKTsgaSArPSA0KSB7XG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgfVxuICAgIGEgJT0gTU9EO1xuICAgIGIgJT0gTU9EO1xuICB9XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICBhICU9IE1PRDtcbiAgYiAlPSBNT0Q7XG4gIHJldHVybiBhIHwgYiA8PCAxNjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW5EZWZpbmVQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgY2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5EZWZpbmVQcm9wZXJ0eTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRlcHJlY2F0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFRoaXMgd2lsbCBsb2cgYSBzaW5nbGUgZGVwcmVjYXRpb24gbm90aWNlIHBlciBmdW5jdGlvbiBhbmQgZm9yd2FyZCB0aGUgY2FsbFxuICogb24gdG8gdGhlIG5ldyBBUEkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdNb2R1bGUgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYWNrYWdlIFRoZSBtb2R1bGUgdGhhdCBmbiB3aWxsIGV4aXN0IGluXG4gKiBAcGFyYW0geyp9IGN0eCBUaGUgY29udGV4dCB0aGlzIGZvcndhcmRlZCBjYWxsIHNob3VsZCBydW4gaW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBmb3J3YXJkIG9uIHRvXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCB3YXJuIG9uY2UgYW5kIHRoZW4gY2FsbCBmblxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKGZuTmFtZSwgbmV3TW9kdWxlLCBuZXdQYWNrYWdlLCBjdHgsIGZuKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbmV3Rm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsXG4gICAgICAvLyBSZXF1aXJlIGV4YW1wbGVzIGluIHRoaXMgc3RyaW5nIG11c3QgYmUgc3BsaXQgdG8gcHJldmVudCBSZWFjdCdzXG4gICAgICAvLyBidWlsZCB0b29scyBmcm9tIG1pc3Rha2luZyB0aGVtIGZvciByZWFsIHJlcXVpcmVzLlxuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBidWlsZCB0b29scyB3aWxsIGF0dGVtcHQgdG8gYnVpbGQgYSAnJXMnIG1vZHVsZS5cbiAgICAgICdSZWFjdC4lcyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICVzLiVzIGZyb20gcmVxdWlyZScgKyAnKFxcJyVzXFwnKSAnICsgJ2luc3RlYWQuJywgZm5OYW1lLCBuZXdNb2R1bGUsIGZuTmFtZSwgbmV3UGFja2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBmbiBhcmUgY29waWVkIG92ZXIuXG4gICAgLy8gSW4gcGFydGljdWxhciwgdGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBQcm9wVHlwZXNcbiAgICByZXR1cm4gYXNzaWduKG5ld0ZuLCBmbik7XG4gIH1cblxuICByZXR1cm4gZm47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJzwnOiAnJmx0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3Oydcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGdldERPTU5vZGUgb3IgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG4gIGlmIChSZWFjdEluc3RhbmNlTWFwLmhhcyhjb21wb25lbnRPckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZ2V0Tm9kZUZyb21JbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9XG4gICEoY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PSBudWxsIHx8IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb3JFYWNoQWNjdW11bGF0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbiAoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRJdGVyYXRvckZuXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdEVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAhKGVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSAnICsgJ29yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcmlseSBhdmFpbGFibGUgZm9yIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9ucy4gSS5lLiBBUlQuIE9uY2UgdGhvc2UgYXJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4gZHJvcCB0aGlzIGNvZGUgcGF0aC5cbiAgICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZShlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJywgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBjYW4gYmUgbW91bnRlZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFNldHMgdXAgdGhlIGluc3RhbmNlLiBUaGlzIGNhbiBwcm9iYWJseSBqdXN0IG1vdmUgaW50byB0aGUgY29uc3RydWN0b3Igbm93LlxuICBpbnN0YW5jZS5jb25zdHJ1Y3Qobm9kZSk7XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9pc093bmVyTmVjZXNzYXJ5ID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBpbnN0YW5jZXMgc2hvdWxkIGZ1bGx5IGNvbnN0cnVjdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXkgc2hvdWxkXG4gIC8vIG5vdCBnZXQgYW55IG5ldyBmaWVsZHMgYWRkZWQgdG8gdGhlbSBhdCB0aGlzIHBvaW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBkb2N1bWVudCk7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0gfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzXG4gKiBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0cyBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGVcbiAqIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG8gYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmVcbiAqIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdENvbXBvbmVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnb25seUNoaWxkIG11c3QgYmUgcGFzc2VkIGEgY2hpbGRyZW4gd2l0aCBleGFjdGx5IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQucmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldElubmVySFRNTFxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG4vLyBXaW44IGFwcHM6IEFsbG93IGFsbCBodG1sIHRvIGJlIGluc2VydGVkXG5pZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9KTtcbiAgfTtcbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcbiAgLy8gd2hpdGVzcGFjZSBpcyByZW1vdmVkLiBXaGVuIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGUgd2l0aCBpbm5lckhUTUxcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcblxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gJyAnO1xuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgICAvLyBNYWdpYyB0aGVvcnk6IElFOCBzdXBwb3NlZGx5IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYWRkZWQgYW5kIHVwZGF0ZWRcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcbiAgICAgIC8vIHRoZSBpbml0aWFsIGFuZCBtb3JlIGZhdm9yYWJsZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLlxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFsc28gaW1wbGVtZW50IGEgd29ya2Fyb3VuZCBmb3Igbm9uLXZpc2libGUgdGFncyBkaXNhcHBlYXJpbmcgaW50b1xuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XG4gICAgICAvLyBhbmQgc2ltcGx5IGNoZWNrIGlmIGFueSBub24tdmlzaWJsZSB0YWdzIGFwcGVhciBpbiB0aGUgc291cmNlLlxuICAgICAgaWYgKFdISVRFU1BBQ0VfVEVTVC50ZXN0KGh0bWwpIHx8IGh0bWxbMF0gPT09ICc8JyAmJiBOT05WSVNJQkxFX1RFU1QudGVzdChodG1sKSkge1xuICAgICAgICAvLyBSZWNvdmVyIGxlYWRpbmcgd2hpdGVzcGFjZSBieSB0ZW1wb3JhcmlseSBwcmVwZW5kaW5nIGFueSBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFxcdUZFRkYgaGFzIHRoZSBwb3RlbnRpYWwgYWR2YW50YWdlIG9mIGJlaW5nIHplcm8td2lkdGgvaW52aXNpYmxlLlxuICAgICAgICAvLyBVZ2xpZnlKUyBkcm9wcyBVK0ZFRkYgY2hhcnMgd2hlbiBwYXJzaW5nLCBzbyB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAvLyBpbiBob3BlcyB0aGF0IHRoaXMgaXMgcHJlc2VydmVkIGV2ZW4gaWYgXCJcXHVGRUZGXCIgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gdGhlIGFjdHVhbCBVbmljb2RlIGNoYXJhY3RlciAoYnkgQmFiZWwsIGZvciBleGFtcGxlKS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvYmxvYi92Mi40LjIwL2xpYi9wYXJzZS5qcyNMMjE2XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5TRVBBUkFUT1I7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCA9IHtcbiAgJz0nOiAnPTAnLFxuICAnLic6ICc9MScsXG4gICc6JzogJz0yJ1xufTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1s9LjpdL2c7XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVzZXJQcm92aWRlZEtleUVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIHdyYXBVc2VyUHJvdmlkZWRLZXkoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBjb21wb25lbnQga2V5IHNvIHRoYXQgaXQgaXMgc2FmZSB0byB1c2UgaW4gYSByZWFjdGlkLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgdXNlclByb3ZpZGVkS2V5RXNjYXBlcik7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyB3cmFwVXNlclByb3ZpZGVkS2V5KGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB2YWxpZGF0ZURPTU5lc3RpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIHBhcmVudFRhZzogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IGFzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLnBhcmVudFRhZyA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIC8qZXNsaW50LWRpc2FibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICBkbyB7XG4gICAgICAvKmVzbGludC1lbmFibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiA8JXM+IGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiAnICsgJ1NlZSAlcy4lcycsIGNoaWxkVGFnLCBhbmNlc3RvclRhZywgb3duZXJJbmZvLCBpbmZvKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleSA9ICdfX3ZhbGlkYXRlRE9NTmVzdGluZ19hbmNlc3RvckluZm8kJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5wYXJlbnRUYWc7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuIl19
